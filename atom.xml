<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wincer&#39;s Blog</title>
  
  <subtitle>言念君子，温其如玉。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.itswincer.com/"/>
  <updated>2019-07-04T11:47:43.000Z</updated>
  <id>https://blog.itswincer.com/</id>
  
  <author>
    <name>Wincer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次反向代理的搭建</title>
    <link href="https://blog.itswincer.com/posts/1352252a/"/>
    <id>https://blog.itswincer.com/posts/1352252a/</id>
    <published>2019-07-04T11:47:43.000Z</published>
    <updated>2019-07-04T11:47:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近和朋友聊天时，他说发现了一个云计算服务商：「<a href="https://zeit.co" target="_blank" rel="noopener">ZEIT</a>」，可以为程序免费提供托管，想问问我有没有什么好的想法。我查看了一下发现这货在全球提供的线路还真不少（亚洲大部分地区都有），用作代理软件想必体验会比较不错。</p><p>于是我首先想到搭建 ShadowSocks、V2Ray 这类代理软件，不过很可惜 ZEIT 在部署上有限制：不支持 WebSocket（当然更不支持 SOCKS5 了），且虽然线路的延迟比较低，但在带宽上却有限制，于是我暂时放弃了正向代理，把注意打到了反向代理的头上。</p><a id="more"></a><p>反向代理相比正向代理的限制不少，最大限制的在于一次只能代理一个网站。想了想还是决定代理一个搜索引擎——<a href="https://www.startpage.com/" target="_blank" rel="noopener">Startpage</a>，用于手机等不那么方便翻墙的设备搜索。至于为什么选择它嘛，有两点原因：</p><ol><li>它是一个非常「干净」的搜索引擎，隐私性做得非常好，甚至没有登录功能，用户偏好也只是用 Cookie 实现；</li><li>它匿名地向 Google 提交查询，再将结果返回给用户（某种意义上来说，它也算 Google 的反向代理），所以搜索质量约等于 Google。</li></ol><p>至于为什么不选择 Google，答案也很简单，Google 会检测计算机的异常流量，一旦检测到异常，则必须通过「reCAPTCHA」检测才能继续使用。尤其是在使用反代的时候，出现检测的机率非常高，这对想迅速得到搜索引擎反馈的用户来说，无疑是一种灾难。</p><h2 id="思路"><a href="posts/1352252a/#思路" class="headerlink" title="思路"></a>思路</h2><p>反向代理的核心思路或者说原理其实很简单：中转服务器把来自客户端的请求发送给服务端，再将服务端的应答返还给客户端。单纯地实现这一功能也非常简单，使用 Golang，你甚至不需要借助第三方库便可搭建一个很简单的反向代理。</p><pre><code class="go">func Proxy(w http.ResponseWriter, r *http.Request) {    reverseURL, err := url.Parse(protocal + host)    proxy := httputil.NewSingleHostReverseProxy(reverseURL)    r.Host = host    proxy.ServeHTTP(w, r)}</code></pre><p>这几行代码就足以搞定 Google 的反向代理了，也能让你愉快地使用 DuckDuckGo 了，然而却无法使用 Startpage。</p><p>是的，可能因为「Startpage」本身就相当于对 Google 的反代，所以它对反向代理极其不友好，具体见下。</p><h2 id="薛定谔的-Bug-们"><a href="posts/1352252a/#薛定谔的-Bug-们" class="headerlink" title="薛定谔的 Bug 们"></a>薛定谔的 Bug 们</h2><h3 id="绝对路径"><a href="posts/1352252a/#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>当我运行刚刚的程序，打开浏览器并输入地址满心欢喜地看着 Startpage 的首页一点点出现时，我几乎以为已经成功了，可是当我输入关键字搜索时，打开 Firefox 的调试工具却发现它的请求资源都是从「Startpage」域名返回的。</p><p>是的，Startpage 很「聪明地」将静态文件的引用使用了绝对路径，而不是大多数网站都使用的相对路径，这意味着我还需要修改 Response Body，将原域名都替换成自己的域名，这一点倒是没什么难度（当时我是这么想的），正好 Golang 也提供了 ModifyResponse 用于 Response 的修改。</p><p>可当我代码写好了然后发现运行结果仍和原来一样时，我开始觉得有点难办了。</p><h3 id="传输编码"><a href="posts/1352252a/#传输编码" class="headerlink" title="传输编码"></a>传输编码</h3><p>造成这个问题的原因其实很明显，但我却花了半天的时间才找到：Startpage 在网页传输时启用了 GZIP 的压缩编码，因此直接替换 <code>www.startpage.com</code> 是行不通的，需要将 Response Body 解码之后再替换。</p><p>完成解码替换之后，终于如愿看到请求资源都是从本域名返回的，我又一次以为自己要成功了。可是当我点击搜索结果的下一页时，网页却久久处于加载之中，我开始觉得或许不应该选择代理「Startpage」了。</p><h3 id="域名改变"><a href="posts/1352252a/#域名改变" class="headerlink" title="域名改变"></a>域名改变</h3><p>打开 Firefox 的调试工具之后，发现它居然把第二页的域名给换成了与首页完全不同的二级域名——「www」会变成类似「s2-us8」、「s3-us6」这的前缀，而具体变成什么样是由首次搜索的时候随机返回的。</p><p>这个问题其实应该是无解的——除非你把所有出现的二级域名都进行代理（类似 YouTube 其实也是把每个视频的源文件放在不同域名的服务器上），不过很可惜，Startpage 只是单纯把域名换了，实测之后直接输入域名前缀也是可以正常使用的，因此只需要把代理的 URL 从 <code>www.startpage.com</code> 换成 <code>s3-us6.startpage.com</code> 就可以加载后几页的内容了。</p><h3 id="处理-Header"><a href="posts/1352252a/#处理-Header" class="headerlink" title="处理 Header"></a>处理 Header</h3><p>在修复了以上三个 Bug 之后，搜索功能已经很完善了，不过还有一个小问题，就是用户的偏好设置无法保存，比如自定义背景、偏好语言等，点击保存按钮会 301 重定向至 <code>www.startpage.com</code> 页面，是的，这又是「Startpage」为反向代理设置的一道关卡。（没办法，自己选的路，哭着也要走完 : ）</p><p>在修改完 301 的重定向地址后，点击保存发现虽然不会跳转到「Startpage」域名了，但是设置依然没有保存下来，一番 Debug 后发现是 Cookie 的问题，Cookie 设置的 Domain 不是同样使用的是绝对路径，「Startpage」为了不让别人反代真是煞费苦心呐！</p><p>在直接把 Cookie 的 Domian 字段干掉之后，使用起来终于和原网站无异了。</p><h2 id="总结"><a href="posts/1352252a/#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然一开始只想着反代一个搜索引擎，但中途想着还是把普适性做得更广一些，让它能代理任意的网站，因此考虑的方面也比较多，但最终的成就感还是挺爽的，自己也对 HTTP 各字段的理解更深刻了。</p><p>目前这个反向代理工具支持文本替换、重定向替换、Cookie 替换等，源码<a href="https://github.com/WincerChan/mirror" target="_blank" rel="noopener">已开源</a>在 GitHub，部署在 ZEIT 上，如果你想部署在自己的服务器上，建议使用 master 分支。</p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/13130341/reading-gzipped-http-response-in-go" target="_blank" rel="noopener">Reading gzipped HTTP response in Go</a></li><li><a href="https://spectrum.chat/zeit/now/golang-example-multi-route-multi-lambda-with-dependencies~fb35e1e2-9f29-47b2-87a2-0977775fc45c" target="_blank" rel="noopener">Golang Example: multi-route, multi-lambda with dependencies</a></li><li><a href="https://stackoverflow.com/questions/41313949/how-to-dump-a-response-of-an-http-get-request-and-write-it-in-http-responsewrite" target="_blank" rel="noopener">How to dump a response of an HTTP GET request and write it in http.ResponseWriter</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近和朋友聊天时，他说发现了一个云计算服务商：「&lt;a href=&quot;https://zeit.co&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ZEIT&lt;/a&gt;」，可以为程序免费提供托管，想问问我有没有什么好的想法。我查看了一下发现这货在全球提供的线路还真不少（亚洲大部分地区都有），用作代理软件想必体验会比较不错。&lt;/p&gt;
&lt;p&gt;于是我首先想到搭建 ShadowSocks、V2Ray 这类代理软件，不过很可惜 ZEIT 在部署上有限制：不支持 WebSocket（当然更不支持 SOCKS5 了），且虽然线路的延迟比较低，但在带宽上却有限制，于是我暂时放弃了正向代理，把注意打到了反向代理的头上。&lt;/p&gt;
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="反向代理" scheme="https://blog.itswincer.com/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
      <category term="Startpage" scheme="https://blog.itswincer.com/tags/Startpage/"/>
    
      <category term="搜索引擎" scheme="https://blog.itswincer.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>我的学生时代（高中篇）</title>
    <link href="https://blog.itswincer.com/posts/5fdce618/"/>
    <id>https://blog.itswincer.com/posts/5fdce618/</id>
    <published>2019-06-15T13:53:44.000Z</published>
    <updated>2019-06-15T13:53:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>在临毕业的这段时间，生活似乎短暂地失去了目标，并不是丧，我也没有认为这是一件坏事——至少我可以有更多的时间思考并记录我的想法，当然更多时间我在好好地、不带任何负担地放松自己。</p><p>直到前几天 <a href="https://wakatime.com/" target="_blank" rel="noopener">WakaTime</a> 发邮件过来说已经两周时间没收到我的 Code Activity 了，问是不是插件出了什么问题：「Please <a href="https://wakatime.com/plugins" target="_blank" rel="noopener">reinstall the plugin</a> to continue using the WakaTime dashboard」。其实并不是插件出了什么问题，而是我真的两周没有编程了（笑。</p><a id="more"></a><p>休养够了，也终于意识到应该做或写点什么了：于是我开始了本文的创作。本文决定聊聊我的高中以及大学生活（其实我一直都有些畏惧谈论这个话题，原因之后会提到）。</p><h2 id="错愕"><a href="posts/5fdce618/#错愕" class="headerlink" title="错愕"></a>错愕</h2><p>从进初中开始，快班里的我们便只有一个目标——进入省重点高中，为学校赚来更好的名誉（当然也为自己的前途）。中考结束，很遗憾，我离省重点的分数线还有几分的差距，当时班上有几个和我分数差不多的人选择了市重点：学杂费全免，直接去最好的班，还有奖学金。当时的我，对于省重点和市重点没有什么明确的概念，所以还是听从家人的想法：交「择校费」，进入了省重点。</p><p>我仍然记得从初中班主任（我和他关系很不错，他曾不止一次地鼓励我，甚至在我说因为回家太晚而不想上晚自习时，提出可以每天晚上开车送我回家；在中考前，让我不用做数学卷子，把心用在其它学科上）手里接过录取通知书时，他脸上那种复杂的表情——惋惜与错愕。前者在于我最终还是没能过省重点的分数线，后者在于我居然还是上了这所学校。</p><h2 id="堕落"><a href="posts/5fdce618/#堕落" class="headerlink" title="堕落"></a>堕落</h2><p>高一上学期，还未分班，想学文的和想学理的混在一起上课，我所在的班级不巧在以后会成为文科班，一想到反正以后也会转班，那就转班后再好好学习吧！恰巧在朋友的安利下，又接触了网络小说（玄幻啊，都市啊<del>，言情啊</del>），于是一发不可收拾彻底沉迷于小说，而「转班后再好好学习」也成为了我心安理得的借口。</p><p>当时的化学老师非常照顾我（因为我第一次摸底考试化学考了并列第一名，当然是吃初中的老本），他也是最早发现我堕落的老师，因此找我谈过几次话，虽然我并没有因谈话而上进，但我仍然感激他在我陷入黑暗的时候愿意拉我一把。</p><p>在未分班时，考试排名差我也有理由搪塞：文科我不会。可到了高一下学期，便进行了预分班，我被分到了一个新的班级，预想中的「重新做人」并没有出现在我身上，反而是更加的堕落——因为我同桌也看小说。与此同时，「文科我不会」的谎言也不攻自破（虽然是预分班，但学校会针对文理科的学生单独出一份文理科目的排名）。家人以为是我沉迷手机（说实话当时也确实沉迷手机，毕竟是智能机刚兴起的时代，但不是沉迷于网络，而是沉迷于折腾手机 ROOT 之类的），于是把我的手机没收。仅留下一个 MP4，但 MP4 仍然可以看小说，于是我仍沉迷于小说。</p><p>最终，堕落的高一以我期末考试 1062 的名次（年级不到一千两百人）结尾，而我也没有和家人扯什么「其它人中考分比我高，我学不过他们」这种诛心的理由。</p><p>高二上学期，上课看小说的情况似乎并没有得到改观，反而是我在与老师斗志斗勇的过程中成长了——「发明」了一种能上课看小说而不被抓到的方法：用书在课桌的前面和右侧各摆一摞，形成一个角落，一有风吹草动就把「作案工具」塞到书下面专门预留的缝隙里。得益此「发明」，我上课看小说没有被老师抓到过一次。可惜之后效仿的同学越来越多，班主任就禁止桌面上的书摆放成这种形状了（话说我这也算是迫使别人改变规则的人了 233333）。</p><h2 id="奋起"><a href="posts/5fdce618/#奋起" class="headerlink" title="奋起"></a>奋起</h2><p>似乎很难想起当初选择从堕落的深渊里爬出来的理由（或许不是想不起，而是我自己也不知道），但终究还是选择往上爬了——我开始严格控制看小说的频率，并开始学习了。</p><p>没过多久，正巧班主任把我调换了座位，我的同桌变成了班长，前桌坐的是班上第一名，我们三人「一见如故」：感兴趣的课（数理化）会一起认真听讲，一起听数学老师讲人生道理；在另外的某些课上则会小范围地互相逗乐、互相扯淡，那段时间不仅是我高二过得最快乐的时光，也是进步最大的时候，我很感谢他俩，也开始明白为什么家人一定要送我来这所学校了。</p><p>除了他们，我还想说说老师们，尤其是数学老师。在他的课上，我学会了数学这种严禁的思考方式，以及他那近乎到自恋的自信（名言：答案和我不一样就是答案错了），兴趣来了，成绩也就水到渠成了。高二下，我数学考了全班第一——145 分，数学老师似乎开始注意到我这个默默无闻的学生了，从那之后，我像是想证明什么似的，每次数学都很尽力地考，可却再也没考上过 130，可也没低于过 110。</p><p>语文课，永远都是睡觉的课——语文老师是学佛的，也非常佛系：发现你睡觉时，便会很温柔地抚摸你的背让你不要睡觉，大部分人在被叫醒后仍然继续倒头就睡，他也不恼，继续上他的课。英语老师也非常有趣：经常在课上和我们这些成绩不太好的学生「互动」，还经常放电影给我们看，得益于她，我拾起了对英语的兴趣。</p><p>好景不长，高二下学期过了才两个月，我们三人组的欢乐时光被班主任强行结束（原因是某人告密说我们三人上课讲话影响课堂纪律），也因此，高二的我对班主任怨念颇深。</p><h2 id="荒诞"><a href="posts/5fdce618/#荒诞" class="headerlink" title="荒诞"></a>荒诞</h2><p>上了高三，学校开始要求学生要上两节晚自习（七点到八点半以及八点四十到十点），我们的班主任又要求早上六点五十就要到校，而且我还要搭公交往返，这样一来的话一天根本无法保证八个小时睡眠，于是我就让父亲和老师说我不上第二节晚自习，好在当时我的成绩稳定下来了，也有了底气提出这个要求。</p><p>虽然每天晚上比同学早一个多小时回家，但我早上仍旧无法那么早起床（尤其是冬天），迟到成为了我的家常便饭，基本高三大部分的早自习我都是被罚站在教室后面背书，最多的一次罚站了近二十人，这也算我们班独特的风景线了。</p><p>在临近高考的几个月里，我过得比之前更放松了：会在老师要求我们自习时和坐最后一排的朋友一起靠在墙上看《奔跑吧兄弟》，却又不敢笑出声；会在早自习下课的五分钟时间内和同学跑去食堂吃碗面条，然后理所应当地迟到十几分钟才进教室，并打赌班主任不会守在门口……多么美好的时光啊，美好而短暂。</p><p>高考前夕，我玩得特别好的一朋友（他成绩比我好，高三的摸底考试基本都比预估的一本分数线高四十分，而我一般高十分左右）问我：</p><p>「你要是没过一本线，会不会复读？」</p><p>「不会」，我不假思索地回答到。</p><p>「我也不会」，他透过黑框眼镜，深沉地看着我说：「除非我二本都没考上」。那是我们第一次比较正经地谈论我们的未来。</p><p>那年是湖北省高考自主命题的最后一年，出卷老师似乎拼了命想让这届高考的学生记住他一样，数学卷异常地难。导致湖北当年的一本分数线是十几年来最低，而我，也倒在了我最擅长的数学上（没考到 80 分，我现在还觉得有些对不起数学老师）。</p><p>去学校领分数条的那天，阴霾天空，我遇到了那朋友：</p><p>「考多少分啊？」，他问我。</p><p>「不好意思说」，我摇了摇头，眼睛望向地面。</p><p>「我不信你还能有我低，我四百五都没到」，我猛地抬起了头望向他，却只看到他嘴角的苦涩。那是我们第二次，无比正经地谈论我们的未来。</p><p>高中啊，以「我没过一本线，他没过二本线」这样荒诞地结束了。</p><hr><p>高中部分已完，由于大学部分需要写的东西比较多，我会另起一篇文章，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在临毕业的这段时间，生活似乎短暂地失去了目标，并不是丧，我也没有认为这是一件坏事——至少我可以有更多的时间思考并记录我的想法，当然更多时间我在好好地、不带任何负担地放松自己。&lt;/p&gt;
&lt;p&gt;直到前几天 &lt;a href=&quot;https://wakatime.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WakaTime&lt;/a&gt; 发邮件过来说已经两周时间没收到我的 Code Activity 了，问是不是插件出了什么问题：「Please &lt;a href=&quot;https://wakatime.com/plugins&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;reinstall the plugin&lt;/a&gt; to continue using the WakaTime dashboard」。其实并不是插件出了什么问题，而是我真的两周没有编程了（笑。&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="感想" scheme="https://blog.itswincer.com/tags/%E6%84%9F%E6%83%B3/"/>
    
      <category term="学生时代" scheme="https://blog.itswincer.com/tags/%E5%AD%A6%E7%94%9F%E6%97%B6%E4%BB%A3/"/>
    
      <category term="高中" scheme="https://blog.itswincer.com/tags/%E9%AB%98%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>奇安信（原 360 企业安全）服务端开发面经</title>
    <link href="https://blog.itswincer.com/posts/d42e79bb/"/>
    <id>https://blog.itswincer.com/posts/d42e79bb/</id>
    <published>2019-05-18T12:34:04.000Z</published>
    <updated>2019-05-19T12:02:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在说起来我自己都不信，之前我居然一直以为秋招是为当年毕业的学生准备的，直到我们班有人签了百度，我才知道秋招原来是为次年的应届生准备的😅，不过当时已经十月，秋招已经基本结束，于是只好准备来年的春招了。</p><a id="more"></a><p>话说回来，本次春招我准备的也不算特别充分，很大一部分原因是毕业设计选题选了一个自己陌生的领域，并且还准备评优秀毕业论文，所以年后一直在准备毕设，空闲时间才会找公司投递。我对公司还是挺挑的（钱多事少离家近，起码要满足两点吧），而且还要招 Python 岗，可供选择的公司就更少了，找来找去也只投递了一家公司——奇安信（原 360 企业安全），所幸最后也拿到了 Offer。</p><p>本文是对这次招聘流程的一个总结。</p><h2 id="笔试"><a href="posts/d42e79bb/#笔试" class="headerlink" title="笔试"></a>笔试</h2><p>我是三月底投递的简历，四月中旬发来的笔试通知。有两道编程题，一道非递减数列（AC 67%，这题 Python3 的输入格式有问题），一道实现哈希表（AC 91%，同上，Python3 输入仍然有问题），这两题难度均介于 Leetcode 的 Easy 和 Medium 之间。</p><p>由于两道编程题都没 100% AC，我以为凉了，结果在 4 月 23 日晚上十一点发来面试通知，通知我 25 号下午面试，当时就有点慌，面试时间太近，只有一天时间准备（24 号上午还要去看复联 4 首映，本来想不去了，后来想想首映一辈子就这一次😅），于是看完电影赶紧把数据库和操作系统还有计算机网络复习了一下。</p><h2 id="一面（30-分钟）"><a href="posts/d42e79bb/#一面（30-分钟）" class="headerlink" title="一面（30 分钟）"></a>一面（30 分钟）</h2><p>等了小半个钟，面试官才姗姗来迟（可能是因为面试的太多了），面试官是一个中年微胖的大叔：</p><ol><li>先做个自我介绍吧</li><li>元组和字典的区别（我当时以为我听错了，心想这俩完全没一点相似的啊）</li><li>Node.js 的特性，与 Python 的区别（这一点应该是看我简历上有写）</li><li>Python2 和 Python3 的区别</li><li>Python2 和 Python3 在多线程有什么区别（我当时想了一下，觉得好像没区别，就说 Python2 多线程不太了解）</li><li>说说多线程的锁</li><li>多进程有什么用</li><li>说说函数式编程的特性</li><li>框架了解吗，说说 Django 和 Flask</li><li>Django 的一次请求流程</li><li>Django 里用了哪些标准库（好奇怪的问题😳）</li><li>写一个 Python 的注解（我以为他问的是 Type Hints，后来意识到可能说的是装饰器，就把装饰器的概念说了一遍，问他具体是哪一个，结果他也说不清楚，说自己好久没接触 Python 了，于是这个问题就过了）</li><li>Numpy 了解吗？Numpy 里新增了什么类型？为什么 Numpy 效率高？</li><li>Elasticsearch 用过吗，说说分片（我当时已经很久没用 ES 了，有些基础概念忘掉了，就说我只知道分桶，不清楚分片）</li><li>算法了解吗？说说堆排序和快排（不知道堆排序，就说了一下快排）</li><li>手撕代码——单链表赋值（还比较简单）</li><li>Python 和 C 的区别</li><li>有什么想问我的（这里我作了一个小死，问了一下面试官觉得我怎么样？回答是思维比较发散、活跃，也比较喜欢钻研新东西，但对某些东西背后的原理挖掘不够深入，总体来说算挺不错了😉）</li></ol><p>与我想象中的面试还是有很大的区别，计算机网络一点没问，操作系统一点没问，数据库一点没问（让我一天的复习付诸流水😅），总体来说都是按照简历来发问，很 Nice 的体验。</p><p>几分钟后收到二面的短信。</p><h2 id="二面（18-分钟）"><a href="posts/d42e79bb/#二面（18-分钟）" class="headerlink" title="二面（18 分钟）"></a>二面（18 分钟）</h2><p>也等了小半个钟，二面面试官应该是小组或者部门的 Leader 了，特别温和，居然用了「您」来称呼我：</p><ol><li>自我介绍</li><li>说说你印象最深的一个项目（我说去年的实习可以吗？他说可以），我说了七八分钟，他偶尔会打断并针对我的叙述提问</li><li>你觉得这段实习你在其中学到了什么，阐述了三个方面，又说了五分钟</li><li>听说你想去武汉啊？（对，离家比较近）来北京吧，武汉可能没有这个岗位了，北京钱多，又是核心部门，我目前的组就是服务端开发的 blabla…</li><li>然后就没问我问题了，说会在技术方面给我评分，一会 HR 会有三面，问一些其它的事情</li></ol><p>原本我以为一面没问数据库、网络，二面怎么也该问了吧，可是还是没有（看来是真的不按套路出牌啊😅），面试官超级 Nice。</p><p>几分钟后收到三面的短信。</p><h2 id="三面（28-分钟）"><a href="posts/d42e79bb/#三面（28-分钟）" class="headerlink" title="三面（28 分钟）"></a>三面（28 分钟）</h2><p>这一面 HR 问的问题实在是太多，跟查户口一样，又没有录音，只能回忆起一部分了：</p><ol><li>你是哪人</li><li>Docker 为什么最近火了起来</li><li>Docker 和虚拟机有啥区别</li><li>实习的时候具体做什么，大概多久适应团队</li><li>为什么读计算机专业（开始讲故事）</li><li>高考失常了吗（开始讲故事 × 2）</li><li>为什么不复读（开始讲故事 × 3）</li><li>想过考研吗，为什么不考研？</li><li>有其它公司的面试吗（惭愧，没有）</li><li>你觉得前两位面试官怎么样</li><li>你觉得笔试题难度怎么样</li><li>你对自己的评价怎么样</li><li>对自己的职业规划是怎么样</li><li>公司如果要求转岗你怎么办</li><li>工作地点想选择哪个城市</li><li>对我们公司了解吗</li><li>有什么想问我的<ol><li>有调休吗😅（HR 还有点蒙，转头问了一下其它人）</li><li>薪资待遇怎么样（HR 说最近在集中面试，等面试结束后会逐一评定薪资）</li></ol></li></ol><p>我这俩提问都是比较迫切的，问的并不算好，不过和 HR 聊天还是比较愉快的。</p><h2 id="后记"><a href="posts/d42e79bb/#后记" class="headerlink" title="后记"></a>后记</h2><p>等待 Offer 的过程不可谓不煎熬，5 月 16 号在群里看到有人说接到 Offer Call 了，当时心里就凉了半截，17 号晚上九点看到有人已经收到 Offer 了，一看我的邮箱，心另半截也凉了。结果十点一看发现我也收到了😅，当天激动得一晚上没睡好。</p><p>祝各位都能拿到心仪的 Offer~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在说起来我自己都不信，之前我居然一直以为秋招是为当年毕业的学生准备的，直到我们班有人签了百度，我才知道秋招原来是为次年的应届生准备的😅，不过当时已经十月，秋招已经基本结束，于是只好准备来年的春招了。&lt;/p&gt;
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="面经" scheme="https://blog.itswincer.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="奇安信" scheme="https://blog.itswincer.com/tags/%E5%A5%87%E5%AE%89%E4%BF%A1/"/>
    
      <category term="服务端" scheme="https://blog.itswincer.com/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>高校生使用教育网的一点姿势</title>
    <link href="https://blog.itswincer.com/posts/36b4c1ab/"/>
    <id>https://blog.itswincer.com/posts/36b4c1ab/</id>
    <published>2019-04-27T09:53:04.000Z</published>
    <updated>2019-04-27T09:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直忙于毕业的相关事项，所以也没有新文章产出——并非是找不到写作素材，实在是没写作时间。虽然这几天依旧很忙，但总算也抽出了一点时间完成了本文，希望能给广大高校生在办理宽带时带来一些帮助。</p><a id="more"></a><h2 id="前言"><a href="posts/36b4c1ab/#前言" class="headerlink" title="前言"></a>前言</h2><p>目前大部分高校的校园宽带应该都对使用者作出了诸多限制，比如：一号一机，禁止使用路由器（破解后才可以共享）；与校方合作垄断，导致价钱比家用宽带贵一大截等。在校生也只能被迫接受——毕竟，你总不能真的不用电脑上网吧？</p><p>好在目前越来越多的高校里校园网已经开始支持 IPv6 了，而一般校园网只针对 IPv4 的流量计费，对 IPv6 产生的流量是不计费的，至于原因，我猜测有两方面原因：一是 IPv6 相关技术还不是特别完善，IPv4 计费系统可能需要修改；二是目前国内 99% 的网站都不支持 IPv6，而纯 IPv6 环境下是无法访问 IPv4 网站的，所以干脆就没做这一限制。</p><blockquote><p>连接上校园网后，不要认证，戳<a href="https://ipv6-test.com/" target="_blank" rel="noopener">这里</a>来测试是否支持 IPv6，当然也可以直接打开 Google，目前 Google 可以通过 IPv6 直连。</p></blockquote><p>但，谁让我是学计算机的呢，这并不能难倒我。既然无法通过 IPv6 直接连接 IPv4 的网站，那利用一个同时支持 IPv4 和 IPv6 的 VPS 做一层代理不就可以绕过这一限制了吗？原理见下拓扑图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1Q5w0S9zqK1RjSZFp761kSXXaO.png" alt="原理"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">原理</figure></p><p>这就意味着，只要你具备 IPv6 网络，<strong>便可以通过此方法绕过诸多限制，从而免费上网</strong>。</p><h2 id="获取-IPv6"><a href="posts/36b4c1ab/#获取-IPv6" class="headerlink" title="获取 IPv6"></a>获取 IPv6</h2><p>目前比较出名的 VPS 服务商除搬瓦工外，大部分都原生支持 IPv6 连接，包括：Vultr、Linode、DigitalOcean。而搬瓦工的 VPS 中 OpenVZ 架构自带 IPv6，KVM 架构则需要利用 Tunnel Broker 技术来提供 IPv6 隧道给只支持 IPv4 的用户（我的搬瓦工 CN2 主机便是通过 Tunnel Broker 来获取 IPv6 支持的，这也是搬瓦工的客服推荐的方案），它定义在 <a href="https://tools.ietf.org/html/rfc3053" target="_blank" rel="noopener">RFC 3053</a>。</p><p><strong>如果你的 VPS 原生支持 IPv6 连接的话，便可以跳过这一步。</strong></p><h3 id="获取-Tunnel"><a href="posts/36b4c1ab/#获取-Tunnel" class="headerlink" title="获取 Tunnel"></a>获取 Tunnel</h3><p>目前 Hurricane Electric 免费提供 Tunnel Broker 服务（我 TM 吹爆！），该公司运营了世界上以对等数目计算的最大 IPv6 网络，所以服务方面是不用担心的。戳<a href="https://www.tunnelbroker.net/register.php" target="_blank" rel="noopener">这里</a>注册。</p><p>随后点击左侧的 <code>Create Regular Tunnel</code>，再在框内输入 VPS 的 IP 地址，再选择一个地区服务器来作为隧道的一端，这里建议根据服务器的地区来就近选择，我这里选择的是 Los Angeles。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1556005626/ovm2o8n4mjlp7wsqrp3g.png" alt="Tunnel 面板"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">Tunnel 面板</figure></p><h3 id="配置-IPv6"><a href="posts/36b4c1ab/#配置-IPv6" class="headerlink" title="配置 IPv6"></a>配置 IPv6</h3><p>创建成功后，在以下页面选择你的系统，如果是 Debian 系就选择 Debian/Ubuntu，其余就选择 Linux-net-tools。</p><p>框中会出现几行命令，登陆 VPS，依次运行这几行命令就行了。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1p5F6SxnaK1RjSZFB763W7VXaM.png" alt="IPv6 配置命令"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">IPv6 配置命令</figure></p><p><strong>第四行被我抹去的地址便是公网 IPv6 的地址。</strong></p><blockquote><p>如果对  Tunnel 的速度需要更换的话，可以删除该 Tunnel 后在 VPS 运行  <code>modprobe -r sit</code> 命令或者直接重启，再重新创建一个 Tunnel。</p></blockquote><h3 id="测试"><a href="posts/36b4c1ab/#测试" class="headerlink" title="测试"></a>测试</h3><p>不出意外，这时 VPS 已经可以使用 IPv6 连接了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1QJtRSxjaK1RjSZFA762dLFXaT.png" alt="测试 IPv6 连接"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">测试 IPv6 连接</figure></p><p>需要注意的是，如果选择非北美地区的服务器，会绕道美国，所以这里的 PING 值会略高。</p><h2 id="配置代理"><a href="posts/36b4c1ab/#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p>代理可以选择 Shadowsocks，但本次要介绍的不是它，而是另一款代理软件：V2Ray。该代理软件比 Shadowsocks 多了许多种伪装流量的方法，且占用内存更低（毕竟是 Go 写的），这对于小内存的 VPS 来说，非常重要。只不过其配置文件比 Shadowsocks 要劝退小白一些。</p><h3 id="服务端安装"><a href="posts/36b4c1ab/#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h3><p>输入以下一行代码进行安装，系统需支持 Systemd：</p><pre><code class="bash">bash &lt;(curl -L -s https://install.direct/go.sh)</code></pre><p>有关更详细的安装教程见<a href="https://www.v2ray.com/chapter_00/install.html#linuxscript" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="服务端配置"><a href="posts/36b4c1ab/#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>如果是通过以上命令安装的话，配置文件在 <code>/etc/v2ray/config.json</code> 目录，以下是我的配置文件，没有流量伪装等进阶配置：</p><pre><code class="json">{  &quot;log&quot;: {    &quot;loglevel&quot;: &quot;warning&quot;,    &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,    &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;  },  &quot;inbounds&quot;: [{    &quot;port&quot;: 10086,    &quot;protocol&quot;: &quot;vmess&quot;,    &quot;settings&quot;: {      &quot;clients&quot;: [        {           &quot;id&quot;: &quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;,          &quot;alterId&quot;: 4        }      ]    }  }],  &quot;outbounds&quot;: [{    &quot;protocol&quot;: &quot;freedom&quot;,    &quot;settings&quot;: {}  }]}</code></pre><p><code>inbounds</code>：入站配置，是一个<strong>数组</strong>。</p><p>注意协议这里填的是：<code>VMess</code> ，由 V2Ray 原创的一份加密传输协议。</p><p><code>clients</code> 是一个 Object 数组，每一个元素里的 id 必须满足 UUID 格式，且服务端客户端需保持一直，作用类似于 Shaowsocks 中的密码。</p><p><code>outbounds</code>：出站配置，也是一个<strong>数组</strong>。</p><h3 id="客户端安装"><a href="posts/36b4c1ab/#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h3><p>Linux 客户端的安装与服务端一致。</p><p>Windows 建议使用 <a href="https://github.com/2dust/v2rayN/releases" target="_blank" rel="noopener">V2RayN</a>，带有图形化界面，下载 <code>V2RayN-Core.zip</code> 解压，下载 <code>V2RayN.zip</code> 解压出的 .exe 文件放入刚刚的目录下。</p><p>目录应该与以下类似：</p><pre><code>.├── config.json├── geoip.dat├── geosite.dat├── guiLogs│   ├── 20190421.txt│   ├── 20190422.txt│   └── 20190423.txt├── guiNConfig.json├── pac.txt├── readme.md├── user-wininet.json├── v2ctl.exe├── v2ctl.exe.sig├── v2ray.exe├── v2ray.exe.sig├── v2rayN.exe├── wv2ray.exe└── wv2ray.exe.sig</code></pre><h3 id="客户端配置"><a href="posts/36b4c1ab/#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><h4 id="Linux"><a href="posts/36b4c1ab/#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>格式与服务端一致，你需要修改的仅有 address 和 id 部分：address 填写服务端的 IPv6 地址；id 需与服务端一致。 </p><pre><code class="json">{  &quot;log&quot;: {    &quot;loglevel&quot;: &quot;warning&quot;,    &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,    &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;  },  &quot;inbounds&quot;: [{    &quot;port&quot;: 1081,    &quot;listen&quot;: &quot;127.0.0.1&quot;,    &quot;protocol&quot;: &quot;socks&quot;,    &quot;settings&quot;: {      &quot;netword&quot;: &quot;udp&quot;    }  }],  &quot;outbounds&quot;: [{    &quot;protocol&quot;: &quot;vmess&quot;,    &quot;settings&quot;: {      &quot;vnext&quot;: [{        &quot;address&quot;: &quot;xxxx:xxxx:xxxx::xxxx&quot;,        &quot;port&quot;: 10086,        &quot;users&quot;: [          {            &quot;id&quot;: &quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;,            &quot;alterId&quot;: 4          }        ]      }]    }  },{    &quot;protocol&quot;: &quot;freedom&quot;,    &quot;tag&quot;: &quot;direct&quot;,    &quot;settings&quot;: {}  }]}</code></pre><p>这时，打开网络代理，填入：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1ewfaXvc3T1VjSZLe762ZsVXa0.png" alt></p><p>注意，<strong>这里一定要选择手动代理模式</strong>，不能使用 PAC/自动模式，因为我们的目的是要本地的所有流量都走代理。而 PAC 仅会当遇到被墙的 IP 时才会走代理。</p><h4 id="Windows"><a href="posts/36b4c1ab/#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>双击 V2RayN.exe 后，点击右上角的<code>添加 VMess 服务器</code>：</p><p>填入地址，端口，id 即可：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1gzJSSrrpK1RjSZTE763WAVXaO.png" alt="Windows 配置"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">Windows 配置</figure></p><p>再将右下角的系统代理模式改为全局模式，道理同 Linux 类似：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1YdVUSq6qK1RjSZFm7600PFXac.png" alt></p><p>这样，不出意外的话，就已经成功了，你的仅支持 IPv6 的电脑已经该可以通过代理来访问非 IPv6 的网站了。</p><h2 id="连接测试"><a href="posts/36b4c1ab/#连接测试" class="headerlink" title="连接测试"></a>连接测试</h2><h3 id="网速测试"><a href="posts/36b4c1ab/#网速测试" class="headerlink" title="网速测试"></a>网速测试</h3><p>正好手头最近入了一个原生支持 IPv6 的 VPS，贴一下与搬瓦工的对比，以下均在同一时段做的测试：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1Q14Ege3tHKVjSZSg7604QFXac.png" alt="原生 IPv6"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">原生 IPv6</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1xkAOS7voK1RjSZFw763iCFXay.png" alt="搬瓦工 + Tunnel Broker"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">搬瓦工 + Tunnel Broker</figure></p><p>原生支持 IPv6 的机器可以直接观看 2K 视频并且不会出现卡顿现象（可以看到已经缓冲了一分钟了），而使用 Tunnel Broker 的就没这么好了，不仅连接速度只有三分之一，而且无法较为流畅的观看 2K 视频，时不时会出现卡顿。考虑到 YouTube 的线路优化已经很强了，国内的视频或者直播应当只能观看 720p（码率最好不要超过 3000）甚至更低了，而前者直播时蓝光 8M 无压力。</p><h3 id="延迟与丢包测试"><a href="posts/36b4c1ab/#延迟与丢包测试" class="headerlink" title="延迟与丢包测试"></a>延迟与丢包测试</h3><p>首先是搬瓦工的，经过了 15 个节点，教育网的入口和出口丢包率很高：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1X9ZNS3HqK1RjSZFE763GMXXa0.png" alt="搬瓦工 + Tunnel Broker"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">搬瓦工 + Tunnel Broker</figure></p><p>这是原生 IPv6 的，经过了 19 个节点，同样教育网的入口和出口丢包率较高（但还不是最高的）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB17MsKS3HqK1RjSZFg7617JXXaj.png" alt="原声 IPv6"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">原声 IPv6</figure></p><p>可以看到其原生自带 IPv6 的主机其实也用的是 HE 的 IPv6 网络（前 13 个节点都一样），那么看来是返程的时候出问题了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1tAUOS9zqK1RjSZFj762lCFXaU.png" alt="原生的 IPv6 返程"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">原生的 IPv6 返程</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1GPs0S7voK1RjSZFw763iCFXan.png" alt="搬瓦工的返程"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">搬瓦工的返程</figure></p><p>果然，问题出在返程上面，原生的 IPv6 并没有走 HE 的线路，丢包率为 0。而相比于浏览网页，在看视频时返程的网络状况会直接影响观看体验，这一点也确实在之前的网速测试中体现了。</p><p>所以，购买建议是：</p><p>如果你还没有购买 VPS 的话，建议购买原生自带 IPv6 连接的 VPS，使用体验会好很多，不过由于电脑是全局的代理，所以要注意 VPS 流量的使用哦~</p><p>最后附赠一个国内的 IPv6 电视网站：<a href="https://iptv.tsinghua.edu.cn/v2/list/channel/%E9%AB%98%E6%B8%85%E9%A2%91%E9%81%93" target="_blank" rel="noopener">清华大学 IPTV</a>。</p><p>参考：</p><ol><li><a href="https://www.bandwagonhost.net/2144.html" target="_blank" rel="noopener">给搬瓦工 KVM 版 VPS 配置 IPv6 支持（基于 Linux CentOS 7）</a></li><li><a href="https://www.v2ray.com/chapter_00/start.html" target="_blank" rel="noopener">Project V 官方网站</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直忙于毕业的相关事项，所以也没有新文章产出——并非是找不到写作素材，实在是没写作时间。虽然这几天依旧很忙，但总算也抽出了一点时间完成了本文，希望能给广大高校生在办理宽带时带来一些帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="IPv6" scheme="https://blog.itswincer.com/tags/IPv6/"/>
    
      <category term="教育网" scheme="https://blog.itswincer.com/tags/%E6%95%99%E8%82%B2%E7%BD%91/"/>
    
      <category term="破解校园网" scheme="https://blog.itswincer.com/tags/%E7%A0%B4%E8%A7%A3%E6%A0%A1%E5%9B%AD%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux 与 Android 同步剪贴板的通用方案</title>
    <link href="https://blog.itswincer.com/posts/d691e748/"/>
    <id>https://blog.itswincer.com/posts/d691e748/</id>
    <published>2019-01-12T12:01:23.000Z</published>
    <updated>2019-01-12T12:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例，还是在每篇文章的开头扯几句不相关的：元旦前就从学校回家了，在家的十几天过得很是舒坦：闲的时候，上午玩两小时游戏或者看看直播，下午就看会 Coursera，晚上有时间就看部电影，没整段的空余时间就找朋友聊聊天、刷刷 V2EX；当然在不闲的时候也是做了一些事的，就比如本文将要说到的——让移动平台和桌面平台同步剪贴板的方案。</p><a id="more"></a><p>我为什么想到做这个呢：两周前，我把用了一年半的 Manjaro 格式化了（忍受不了 KDE 巨多的 Bug，还有硬盘都被我用完了），装上了 Ubuntu，桌面环境选择了 Budgie——一个新出的 DE。比 GNOME 漂亮，比 KDE 稳定，稍加配置即可满足我这个强迫症的审美需求：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB15xNmaOzxK1RjSspj763S.pXaS.png" alt="桌面截图"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">桌面截图</figure></p><p>从 KDE 转成 Budgie 之后，最让我不习惯的就是手机和电脑再也不能愉快地共享剪贴板和文件了，当然我也在网上找了一些现成的解决方案，但体验都不佳，于是我便考虑自己造一个轮子。</p><h2 id="设计思路"><a href="posts/d691e748/#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>由于移动端（客户端）、桌面端（服务端）二者需要进行数据的双向传输，HTTP 协议肯定是无法做到了：于是选用了 WebSocket 作为底层的传输协议。同时，为了让适用性更广，桌面端开发选择了 Golang；移动端则使用 React Native 开发。但这两门高级的语言（Golang、JavaScript）都无法为剪贴板添加监听事件，于是我只好自己用轮询的方式对比当前剪贴板的内容与上一次内容的差异，再考虑是否发送数据。</p><h2 id="桌面端"><a href="posts/d691e748/#桌面端" class="headerlink" title="桌面端"></a>桌面端</h2><p>桌面端的开发语言选择 Golang 其实我是有些不情愿的：</p><ol><li>太过高级：无法提供系统底层的 API（比如监控剪贴板）；</li><li>语法太过丑陋：我想把 log 信息封装一下，结果用 struct 封装了半天，代码反而看起来更「💩」了，还不如用 Switch，可 Switch 导致暴露出的接口又不够简洁 . . .</li></ol><p>其它语言我也找了个遍：Python 虽可监听剪贴板的变化（通过 gi 这个库），但这个库并没有办法跨平台，且我 Windows 没有安装编程环境，我也不想安装。</p><p>总之，能监听剪贴板的无法跨平台，能跨平台的无法监听剪贴板。</p><p>So . . . 哪怕 Go 有万般不是，但在跨平台这一点的易用性上也足以让我抛弃其它的所有（纯静态链接库 + 交叉编译）。</p><p>于是乎，</p><p>「真香」。</p><h2 id="移动端"><a href="posts/d691e748/#移动端" class="headerlink" title="移动端"></a>移动端</h2><p>其实我本想用 Flutter 来开发的，但遇到了一些问题：</p><ol><li>在我电脑上无法热加载，这在修改样式的时候可太难受了；</li><li>Dart 似乎无法在已有的 WebSocket 连接上绑定一个新的连接，即使原来的连接已经失效了（不知是 Bug 还是咋样）。</li></ol><p>于是我选择了 React Native。有了 React 的基础，上手确实很快，并且 JavaScript 写起来感觉还是挺爽的。</p><p>之所以会有刚刚提到的（重新绑定 WebSocket 的）需求，是因为在不同的网络环境中，电脑的 IP 可能有所改变，而我暂时想不到一个方法让手机自动识别同一网络的哪一台电脑使用了共享剪贴板的工具（逐一扫描 IP？那也太丑陋了）。</p><p>所以在初始化连接时需要手动输入一次电脑的 IP 地址，随后地址信息会被保存，之后就不用再输入了。</p><h2 id="使用"><a href="posts/d691e748/#使用" class="headerlink" title="使用"></a>使用</h2><p>只需保持这两个软件在后台，会自动监控剪贴板的内容并发送。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1nepnaIfrK1RkSnb4760HRFXaf.png" alt="桌面端"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">桌面端</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1dj0maN_rK1RkHFqDq6yJAFXam.jpg" alt="移动端"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">移动端</figure></p><h2 id="下载"><a href="posts/d691e748/#下载" class="headerlink" title="下载"></a>下载</h2><p>由于代码写的有点不满意，功能也不太完善，等以后有空重构之后加上文件共享功能，会开源的。这里先放出各平台的可执行程序：<a href="https://bit.ly/clipboard_shared" target="_blank" rel="noopener">戳我👈</a>。</p><hr><p>愿能有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;按照惯例，还是在每篇文章的开头扯几句不相关的：元旦前就从学校回家了，在家的十几天过得很是舒坦：闲的时候，上午玩两小时游戏或者看看直播，下午就看会 Coursera，晚上有时间就看部电影，没整段的空余时间就找朋友聊聊天、刷刷 V2EX；当然在不闲的时候也是做了一些事的，就比如本文将要说到的——让移动平台和桌面平台同步剪贴板的方案。&lt;/p&gt;
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="Clipboard" scheme="https://blog.itswincer.com/tags/Clipboard/"/>
    
      <category term="剪贴板" scheme="https://blog.itswincer.com/tags/%E5%89%AA%E8%B4%B4%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>我的 2018 轨迹</title>
    <link href="https://blog.itswincer.com/posts/e4e1357d/"/>
    <id>https://blog.itswincer.com/posts/e4e1357d/</id>
    <published>2018-12-27T10:52:16.000Z</published>
    <updated>2018-12-27T10:52:16.000Z</updated>
    
    <content type="html"><![CDATA[<div id="aplayer" musicid="498134"></div><script src="https://api.itswincer.com/music/v1/" async></script><p>实习回到学校十几天后，便开始思考年终总结怎么写，之所以这么早就开始构思，或许是我笃定在这 2018 最后的半个月内也不会发生什么值得记录的大事。当然我也期待着能发生什么事来冲击一下现有的生活——在校的时光实在是太安逸了，想来是应当正处于心理空窗期了。</p><a id="more"></a><p>本次总结将会就学习、生活、工作（实习）三个方面来描绘一下今年的生活轨迹。</p><h2 id="学习"><a href="posts/e4e1357d/#学习" class="headerlink" title="学习"></a>学习</h2><p>我应该算是「兴趣驱动学习」的典范了：每当我抱着很强的目的性或功利性去学习的时候，总是坚持不了多久。Princeton 的算法课从两年前就开始学，学到现在也才把排序看完。</p><p>不过今年在学习方面还是有不少收获的：借助 Coursera 这一平台，观看了 Node.js 的开发，Golang 的入门等网课。我在学习一门新语言的时候总会选择看视频，如果从一开始就看书的话，我会觉得有些乏味和枯燥，尤其是动辄上千页的技术类书籍，看厚度就有一种劝退感。而在入门后，想要深入了解一门的语言的底层，我才会选择翻阅一些书籍。</p><p>除了学习新东西之外，对 Functional Programing（函数式编程，以下简称 FP）也有了更深刻地理解。比如，为什么 FP 中多以递归来代替 Imperative programming（命令式编程）中的循环语句。原因在于数学家和逻辑学家们验证递归的正确性比验证循环的正确性要容易得多。</p><p>一个很简单的例子，分别用 Java 和 Haskell 实现快速排序：</p><p>Java：</p><pre><code class="java">public class Sorter {    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void quicksort(T[] list) {        quicksort(list, 0, list.length - 1);    }    private static &lt;T extends Comparable&lt;? super T&gt;&gt; void quicksort(T[] list, int low, int high) {        if (low &gt;= high)            return;        int i = low - 1, j = high + 1;        T pivot = list[low];        for (;;) {            do {                ++i;            } while (list[i].compareTo(pivot) &lt; 0);            do {                --j;            } while (list[j].compareTo(pivot) &gt; 0);            if (i &gt;= j)                break;            T tmp = list[i];            list[i] = list[j];            list[j] = tmp;        }        quicksort(list, low, j);        quicksort(list, j + 1, high);    }}</code></pre><p>Haskell：</p><pre><code class="haskell">quicksort :: (Ord a) =&gt; [a] -&gt; [a]quicksort[] = []quicksort(pivot : rest) =     quicksort[x| x &lt;- rest, x &lt; pivot]    ++ [pivot]    ++ quicksort[x| x &lt;- rest, x &gt;= pivot]</code></pre><p>以上两段代码，哪一段的正确性更容易验证？答案不言自明。</p><p>对于前者，指定了计算的详细过程，而后者，仅指定了计算的规则（原则）。这也是 FP 的特点之一：不关心如何计算，更关心计算的结果（的正确性）。</p><p>「正确」是 FP 设计的重中之重。究其根本在于 FP 的鼻祖 Lisp 与 λ 演算那密不可分的联系。</p><h2 id="生活"><a href="posts/e4e1357d/#生活" class="headerlink" title="生活"></a>生活</h2><p>生活方面似乎并没有什么改变，相比去年——好吧，并不是。我的体重告诉我比去年重了 ×× 斤。去杭实习不仅没瘦，反而重了。而且似乎睡得还更晚了，不过似乎「互联网依赖症」减轻了不少，比如本文初稿就是纯手写的。</p><p>在读书方面，算是有了一些进步，今年在豆瓣读书上为 15 本书贴上了「已读」的标签（不过仍未达到两周一本的目标）。文学类和技术类都有，技术类对我影响最大的毫无疑问就是《流畅的 Python》这本书了，断断续续地看了近三个月，做了万余字的笔记。</p><p>至于文学类嘛，《哲学家们都干了些什么》是让我眼前一亮：枯燥的哲学似乎在作者笔下都「皮」了起来。但印象最深地却是伊坂幸太郎的《金色梦乡》，等下，《白夜行》好像印象也很深刻，《解忧杂货店》构思也很巧妙（这么说来我果然很喜欢日系推理），钱锺书的《围城》也不错…好吧，文无第一，今年看的文学类书籍都非常不错。</p><p>接下来就该到电影方面了：今年在豆瓣电影为 72 部电影（包括剧集）贴上了「已看」标签。比较喜欢的剧集似乎都是日剧（非自然死亡，胜者即是正义）；电影的话，《我不是药神》一枝独秀，在电影院里哭得还朝旁边的妹子借纸；动漫也看了不少：来自深渊（新番），怪化猫（旧番）都不错，属于能给灵魂带来冲击的番。</p><p>谈话类节目仍然强推《圆桌派》，可惜第三季之后窦文涛似乎就跑路了。纪录片这块则必须让陈晓卿的《风味人间》安排上，对于一个吃货来说，本节目的美食引起了强烈不适。不过还是作为吃货，即使吃不着，退而求其次，能过过眼瘾也是一种享受。此外，本节目还会介绍与美食相关的风土，人情，文化，品味等，美食之所以被冠以「美」字，绝不仅仅在于它的味道，更在于人们赋予它的某种意义，或者说是其背后所蕴含着的丰富内涵，这才是其绵延不绝的生命力所在。</p><h2 id="工作"><a href="posts/e4e1357d/#工作" class="headerlink" title="工作"></a>工作</h2><p>如果说搭建这个博客是去年我做的最有意义的事，那么实习应该就是今年我所做的最有意义的事了。</p><p>九月份时我并没有走校招，原因有两方面：一方面我并没有发现有什么企业校招 Python 岗（大部分都是前端和 Java）；另一方面是估计实习时间也不会太久，本学期期末学校肯定一大堆事，于是也没怎么考虑公司，面了一家，就进去了。</p><p>我面的是 Python 岗，本以为进来之后也是写 Python。谁知阴差阳错上了 Node.js 的贼船，当然这有一部分的原因在于我：Leader 问我能不能用 Node.js，我说之前接触过一些，然后他就给了我几天时间让我熟悉一下。不过好在是从零开始写的，不用「接盘」前人的代码，倒是省了不少事。在公司待的两个半月时间内，也帮同事解决了不少 Python 问题，不过多是业务方面的逻辑。除此之外，收获最大的就是 Elasticsearch（以下简称 Elastic）的相关组件（我编写的 API 是直接与 Elastic 交互的）的部署和维护了，因为个人的项目很难直接接触到 Elastic 这一庞大的生态系统。</p><p>不过我是有些认为面试的时候公司没有把我的水平面出来（颇有些怀才不遇的感觉），简历上写的大部分细节都没问。只是问了问笔试题，感觉有点憋屈。能力未充分得到挖掘带来的问题就是资源的浪费。一方面是职员能力的浪费（能力得不到体现），一方面是公司资源的浪费（项目进度跟不上，业绩无法按时达标），于是就会导致某些人上班只需要花费很少的时间即可完成公司的任务，剩下一堆可自由支配的时间，而另一些人不仅上班时间不够用，还需要加班才能勉强完成。在这个公司时，我应当时属于前者，虽然有些不好意思，但我在公司的空余时间还是会学些自己的东西。</p><p>同时我也感觉写业务写久了，脑子里也只剩下业务了。对技术反而没什么提升，而对于当下的我来说，技术仍远比业务重要。正在这时候，学校要求我们回去准备毕设的事。于是，我辞职了，开始享受这为数不多的大学时光。</p><p>如果说之前的我还对未来的道路存疑的话，那么这两个半月的实习生活让我开始明确了未来的道路——Python 开发相关。同时也明白：校园的时光虽然让人十分享受，但也总有毕业的那一天。如果说大学的象牙塔是我最后的天堂，那就让我从天堂里一步一步地走出来。</p><hr><p>似乎该结尾了，我不想再像去年一样为我的 2019 立什么 Flag 了（去年的 Flag 一大半都没实现），不过我想毕业的年份应当过得比较有趣吧？</p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer&quot; musicid=&quot;498134&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://api.itswincer.com/music/v1/&quot; async&gt;&lt;/script&gt;
&lt;p&gt;实习回到学校十几天后，便开始思考年终总结怎么写，之所以这么早就开始构思，或许是我笃定在这 2018 最后的半个月内也不会发生什么值得记录的大事。当然我也期待着能发生什么事来冲击一下现有的生活——在校的时光实在是太安逸了，想来是应当正处于心理空窗期了。&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="随笔" scheme="https://blog.itswincer.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="2018" scheme="https://blog.itswincer.com/tags/2018/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 集群备份指南</title>
    <link href="https://blog.itswincer.com/posts/92d76830/"/>
    <id>https://blog.itswincer.com/posts/92d76830/</id>
    <published>2018-10-27T21:55:12.000Z</published>
    <updated>2018-10-27T21:55:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch 官方对其的定义是一种搜索引擎，但我更喜欢把它当作一种非关系型数据库来看待，而作为数据库来看待的话，保障其中数据的安全性和可靠性自然是重中之重了。</p><p>首先声明，本文对 Elasticsearch 数据的备份是基于<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html" target="_blank" rel="noopener">官方提供的 API</a>，其它的诸如 <a href="https://github.com/taskrabbit/elasticsearch-dump" target="_blank" rel="noopener">elasticsearch-dump</a> 等第三方工具暂且不谈。官方的提供的备份方式是一种 Snapshot，其中备份路径可以选择云端或本地，本文想就备份集群数据到本地写一份指南，并对遇到的问题做一些解答。 </p><a id="more"></a><h2 id="搭建集群文件系统"><a href="posts/92d76830/#搭建集群文件系统" class="headerlink" title="搭建集群文件系统"></a>搭建集群文件系统</h2><p>为了创建一个 Elasticsearch 集群的 Snapshot，首先必须先搭建一个集群文件系统，用以确保集群的所有节点对同一个目录具有操作权限——这里推荐使用 NFS（Network File System）。</p><p>NAS 需要指定集群的某一个节点的文件夹作为服务器来提供硬盘存储，也是 NAS 存储文件的实际位置，集群的其他节点作为客户端挂载服务端的共享文件夹。</p><h3 id="安装"><a href="posts/92d76830/#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="shell">sudo apt install nfs-kernel-server # 服务端sudo apt install nfs-common # 客户端</code></pre><h3 id="创建共享文件夹"><a href="posts/92d76830/#创建共享文件夹" class="headerlink" title="创建共享文件夹"></a>创建共享文件夹</h3><p>这里是我踩的第一个坑。<strong>服务端的共享文件夹所有者必须也是运行 Elasticsearch 程序的用户</strong>，不然 Elasticsearch 是无法将数据备份到该文件夹的，比如运行 Elasticsearch 的用户是 els 的话，可以用如下命令来创建共享文件夹：</p><pre><code class="shell">sudo -u els mkdir /path/to/backups -p</code></pre><h3 id="修改配置文件"><a href="posts/92d76830/#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>在服务端的 <code>/etc/exports</code> 中添加以下内容：</p><pre><code class="conf">/path/to/backups 192.168.1.1(insecure,rw,sync,no_subtree_check,no_root_squash,no_acl)</code></pre><p>其中 <code>192.168.1.1</code> 就是服务器本机的 IP。括号内的是配置参数，稍稍解释一下：</p><ul><li><code>insecure</code>：允许客户端从大于 1024 的端口号连接。</li><li><code>rw</code>：所有连接者都具有读写权限。</li><li><code>sync</code>：将更改都提交到稳定存储之后再回复请求。</li><li><code>no_subtree_check</code>：禁用子树检查。</li><li><code>no_root_squash</code>：关闭 root 压缩。</li><li><code>no_acl</code>：不要向客户端显示 ACLs。</li></ul><p>更多的参数可以参考<a href="https://linux.die.net/man/5/exports" target="_blank" rel="noopener">这里</a>。</p><h3 id="生效配置"><a href="posts/92d76830/#生效配置" class="headerlink" title="生效配置"></a>生效配置</h3><pre><code class="shell">exportfs -r</code></pre><p>这时你可以使用 <code>showmount -e localhost</code> 来查看本机的挂载情况：</p><pre><code class="shell">/path/to/backups 192.168.1.1</code></pre><h3 id="客户端"><a href="posts/92d76830/#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>注意，客户端也一定要使用运行 Elasticsearch 的用户的权限来创建相同的文件夹，这一点非常重要。然后把服务端的文件夹挂在到各个节点：</p><pre><code class="shell">mount -t nfs 192.168.1.1:/path/to/backups /path/to/backups</code></pre><p>没有报错的话，就挂载成功了。</p><h2 id="Elasticsearch-配置"><a href="posts/92d76830/#Elasticsearch-配置" class="headerlink" title="Elasticsearch 配置"></a>Elasticsearch 配置</h2><p>需在每一个节点的 <code>elasticsearch.yml</code> 中加上一行：</p><pre><code class="yaml">path.repo: [&quot;/path/to/backups&quot;]</code></pre><p>然后重启 Elasticsearch。</p><p>这时就可以尝试创建一个 Snapshot 的仓库了：</p><pre><code class="json">PUT /_snapshot/my_backup{    &quot;type&quot;: &quot;fs&quot;,    &quot;setting&quot;: {        &quot;location&quot;: &quot;/path/to/backups&quot;    }}</code></pre><p>如果没有报了权限错误的话，就 OK 了。</p><p>如果报了权限错误，请检查 Elasticsearch 对该文件夹是否具有写权限。如果确认具有写权限，那么就需要把集群各节点运行 Elasticsearch 的用户的 UID 和 GID 统一起来，具体做法见附录。这里是我踩的第二个坑。</p><h2 id="创建一个备份"><a href="posts/92d76830/#创建一个备份" class="headerlink" title="创建一个备份"></a>创建一个备份</h2><p>你可以以如下命令来创建一个备份：</p><pre><code class="json">PUT /_snapshot/my_backup/snap1?wait_for_completion=true{    &quot;indices&quot;: &quot;index_1,index_2&quot;}</code></pre><p>其中 <code>wait_for_completion</code> 参数并不会马上返回结果，而是等备份完成之后再返回结果，如果备份的索引很多的话，可能会花费很多时间才返回，所以并不建议加上这个参数。可以为 <code>PUT</code> 加上请求体，指定索引，如上指定 <code>index_1</code>、<code>index_2</code> 两个索引备份，如果不加请求体的话会默认备份全部索引。</p><p>当 Snapshot 正在生成中的时候，可以使用如下命令来获取备份的进度：</p><pre><code class="json">GET /_snapshot/my_backup/snap1</code></pre><p>其返回的 <code>state</code> 项的值即是备份进度条。</p><p>Elasticsearch 是采取增量备份的形式，但需注意，Snapshot 不可重复创建，也就是说 Snapshot 的名字不能相同。</p><h2 id="从备份中恢复"><a href="posts/92d76830/#从备份中恢复" class="headerlink" title="从备份中恢复"></a>从备份中恢复</h2><p>可采取如下命令从 Snapshot 中恢复：</p><pre><code class="json">POST /_snapshot/my_backup/snap1/_restore</code></pre><p>默认所有的索引都会恢复，当然你也可以指定索引：</p><pre><code class="json">POST /_snapshot/my_backup/snap1._restore{    &quot;indices&quot;: &quot;index_1,index_2&quot;}</code></pre><p>而有关恢复的进度，Elasticsearch 并不提供查询像备份进度那样的 API，所以只能使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-recovery.html" target="_blank" rel="noopener">indices recovery</a> 和 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-recovery.html" target="_blank" rel="noopener">cat recovery</a> 来查询恢复进度。</p><p>与备份和恢复更详细的讲解请参照<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="附：更改-UID-和-GID-的方法"><a href="posts/92d76830/#附：更改-UID-和-GID-的方法" class="headerlink" title="附：更改 UID 和 GID 的方法"></a>附：更改 UID 和 GID 的方法</h2><p>首先假设各节点运行 Elasticsearch 的用户名为 <code>els</code>。先假设：他的旧 UID 为 1005，旧 GID 为 2000，要把他改成 UID 为 2005，GID 为 3000 的新用户。</p><p>首先为 <code>els</code> 更改新的 UID 和 GID：</p><pre><code class="shell">sudo usermod -u 2005 elssudo groupmod -g 3000 els</code></pre><p>这就算完成了，可以用 <code>id els</code> 命令来查看用户的 UID 和 GID 是否被成功更改。</p><p>当然，这只是把用户名的 UID 和 GID 做了简单的更改，还需要把原用户的所有文件、目录的所有者都改成新的，不然是无法成功运行 Elasticsearch 的，会报权限错误。</p><p>以下命令来更改：</p><pre><code class="shell">sudo find / -group 2000 -exec chgrp -h els {} \;sudo find / -user 1005 -exec chown -h els {} \;</code></pre><p>其中 <code>-exec</code> 参数对每个文件执行 <code>chgrp</code> 和 <code>chown</code> 命令。<code>-h</code> 参数是对符号链接起作用，而不是应用文件。</p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/44955219/snapshot-api-not-working" target="_blank" rel="noopener">Snapshot API not working</a></li><li><a href="http://smallasa.com/2017/03/09/elasticsearch-backup-and-restore/" target="_blank" rel="noopener">elasticsearch backup and restore</a></li><li><a href="https://www.cyberciti.biz/faq/linux-change-user-group-uid-gid-for-all-owned-files/" target="_blank" rel="noopener">How to Change a USER and GROUP ID on Linux For All Owned Files</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Elasticsearch 官方对其的定义是一种搜索引擎，但我更喜欢把它当作一种非关系型数据库来看待，而作为数据库来看待的话，保障其中数据的安全性和可靠性自然是重中之重了。&lt;/p&gt;
&lt;p&gt;首先声明，本文对 Elasticsearch 数据的备份是基于&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方提供的 API&lt;/a&gt;，其它的诸如 &lt;a href=&quot;https://github.com/taskrabbit/elasticsearch-dump&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;elasticsearch-dump&lt;/a&gt; 等第三方工具暂且不谈。官方的提供的备份方式是一种 Snapshot，其中备份路径可以选择云端或本地，本文想就备份集群数据到本地写一份指南，并对遇到的问题做一些解答。 &lt;/p&gt;
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="Elasticsearch" scheme="https://blog.itswincer.com/tags/Elasticsearch/"/>
    
      <category term="备份" scheme="https://blog.itswincer.com/tags/%E5%A4%87%E4%BB%BD/"/>
    
      <category term="恢复" scheme="https://blog.itswincer.com/tags/%E6%81%A2%E5%A4%8D/"/>
    
      <category term="backup" scheme="https://blog.itswincer.com/tags/backup/"/>
    
  </entry>
  
  <entry>
    <title>Python 知多少（二）——继承</title>
    <link href="https://blog.itswincer.com/posts/58dd3c61/"/>
    <id>https://blog.itswincer.com/posts/58dd3c61/</id>
    <published>2018-10-21T18:18:20.000Z</published>
    <updated>2018-10-21T18:18:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>好像又有一段日子没写技术类博文，翻了翻归档，发现最近一篇技术类文章已经是俩月多之前的事了，吓得我赶紧<del>水</del>写一篇的技术文章不然怕是要被人当成生活博主了。思来想去写些什么好，还是继续上次开的新坑，来聊聊 Python 中的继承。</p><a id="more"></a><p> Python 作为一种具备多种编程范式的语言，面向对象自然也是它所具备的范式之一；而继承，作为面向对象程序设计的三大特性之一，其重要性也是不容忽视的。尤其这一特性在支持面向对象范式的语言里还有着不同的规则，如：C++ 同时支持普通继承和虚继承；Java 则是将其它语言中的 class 细分为 class 和 interface；还有 Python，「无痛地」支持多重继承。 </p><h2 id="多重继承"><a href="posts/58dd3c61/#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>当一个语言支持多重继承时，至少需要解决这两个问题，以下图为例逐个分析 C++、Java、Python 对多重继承的支持情况：</p><pre><code class="markdown">            A          /   \         B     C          \   /            D</code></pre><ol><li>怎么处理共同的父类（基类、超类）</li><li>多个父类方法名重复的问题</li></ol><h3 id="C"><a href="posts/58dd3c61/#C" class="headerlink" title="C++"></a>C++</h3><p>首先看看 C++ 是怎么解决第一个问题的：C++ 在遇到这种情况时，最顶层的基类（A）会被创建两次，虽然可以通过将 A 设置为 B、C 的虚基类来解决，但这种虚继承是有副作用的：不只是在获取成员会更慢、占用内存更多，在和虚函数一起出现时会更难以理解：当 A、B、C、D 中都有一个虚函数 f 时， <code>D::f</code> 内部调用了 <code>B::f</code> 和 <code>C::f</code>；<code>B::f</code>和<code>C::f</code>内部都调用了<code>A::f</code>，于是 <code>A::f</code>就被调用了两次。当然也不是没有办法解决，<a href="https://books.google.com/books?id=PSUNAAAAQBAJ&amp;lpg=PA767&amp;ots=DrtrIigY4J&amp;dq=27.4.%20Template%20Parameters%20as%20Base%20Classes&amp;hl=zh-CN&amp;pg=PA767#v=onepage&amp;q&amp;f=false" target="_blank" rel="noopener">Template Parameters as Base Classes</a> 就是 C++ 之父专门用于解决这个问题所开发的技术。</p><p>第二个问题：如果这里的 B 和 C 同时实现了 <code>hello</code> 方法，同时 D 中没有实现 <code>hello</code> 方法，那么在调用 <code>d.hello()</code>（d 为 D 的 instance） 的时候会调用哪一个？编译器对于这种 Ambiguous base classes 的情况会直接报错，解决方法也简单粗暴，你必须显式指定 <code>d.B::hello()</code> 来调用 B 中的 <code>hello</code>。虽然以上两个问题在 C++ 中都解决的并不好，但也总归是解决了。下面来说说 Java。</p><h3 id="Java"><a href="posts/58dd3c61/#Java" class="headerlink" title="Java"></a>Java</h3><p>Java 之父觉得 C++ 太难用了，于是他决定创造一门语言来取代 C++，这门语言需要保留 C++ 的优点，但又需要把 C++ 中较为混乱、复杂、危险的部分剔除（其中就包括了多重继承），于是，Java 就在这样的理念里诞生了。在 Java 诞生之初，对多重继承的支持少的可怜：一个 class 仅可继承（实现）多个 interface。本来是挺好的，但是在 Java 8 中为 interface 中的方法引入了 default 关键字，这就让 interface 里定义的方法可以有方法体了。</p><p>那么 inteface 有了方法体之后，对这解决这两个问题有什么影响呢？将上例中的 A、B、C、D 换成四个 interface：</p><p>第一个问题：Java 遇到了和 C++ 中的虚函数一样的问题，即 D 中如果想同时调用 B 和 C 中的某方法，且 B、C 中也调用了 A 的方法，那么 A 的该方法会重复运行两次。并且 Java 无法像 C++ 中使用模板技术来解决这个问题。</p><p>第二个问题：Java 8 之前一个 class 可以实现多个 interface，即使 interface 有同名方法也没关系，毕竟 inteface 里定义的方法没有方法体，所以不会导致二义性。但有了 default method 之后，Java 反而无法处理这个问题了：D 不允许同时继承两个实现了 default 方法的接口（一个实现了，另一个没有实现也不行）。</p><p>C++ 解决的不好，Java 压根就没解决。所以我认为 Java 在多重继承这一方面比 C++ 处理的更加不好。</p><h3 id="Python"><a href="posts/58dd3c61/#Python" class="headerlink" title="Python"></a>Python</h3><p>终于到 Python 了，那么先来看看 Python 是如何解决第一个问题的：如果 D 中需要同时调用 B 和 C 中的 <code>hello</code> 方法，且 B、C 中也需要调用 A 的 <code>hello</code> 方法，那么仅需在 B、C、D 的该方法中写下 <code>super().hello()</code> 即可。因为继承图的缘故，Python 中的 <code>super()</code> 会沿着继承图顺序依次找寻 D 的所有超类。</p><p>第二个问题：还是得益于继承图，当 D 中没有实现 <code>hello</code> 方法时，Python 会依据继承图顺序来寻找 D 的所有超类中是否有该方法，直到找到为止，而这个顺序也就是方法解析顺序。</p><p>Python 完美的解决了这两个问题，这也是为什么我说 Python「无痛地」支持多重继承。</p><p>既然这两个问题都是靠方法解析顺序解决的，那么它到底是个什么东西？看官先别急，下面会着重阐述。</p><h2 id="方法解析顺序"><a href="posts/58dd3c61/#方法解析顺序" class="headerlink" title="方法解析顺序"></a>方法解析顺序</h2><p>方法解析顺序（Method Resolution Order，简写为 MRO），是描述该类自继承顶层超类的一种顺序，它在类中以 <code>__mro__</code> 属性存放，值是一个元组（<code>.mro()</code> 返回的则是一个列表，然而这列表并不可变），上例中的 D 的 MRO 为：</p><pre><code class="python">&gt;&gt;&gt; D.mro()[__main__.D, __main__.B, __main__.C, __main__.A, object]</code></pre><p>这里的意思是：D 的最顶层超类为 <code>object</code>（新式类中所有类都继承自 <code>object</code>），其次是 A、C、B。</p><p>下面来具体看看 Python 的代码是如何解决上文提到的第一个问题的：</p><pre><code class="python">class A:    def hello(self):        print(&quot;Hello from A&quot;)class B(A):    def hello(self):        print(&quot;Hello from B&quot;)        super().hello()class C(A):    def hello(self):        print(&quot;Hello from C&quot;)        super().hello()class D(B, C):    def hello(self):        print(&quot;Hello from D&quot;)        super().hello()&gt;&gt;&gt; d = D()&gt;&gt;&gt; d.hello()Hello from DHello from BHello from CHello from A</code></pre><p>在 D 中遇到的 <code>super()</code> 会沿着 D 的 MRO 依次向上寻找超类中的 <code>hello</code> 方法并执行，即依次执行 D -&gt; B -&gt; C -&gt; A 这个顺序。</p><p>那么为什么 Java 或 C++ 无法通过这种写法解决呢，原因在于 Java 的 <code>super</code> 在多重继承中必须指定父类是哪一个，因为编译器是无法获知你想要运行的是哪一个父类的方法。而一旦指定了父类（B），那么与这个父类同时继承的另一个父类（C）你也必须要指定，而这两个父类又具有相同的更高层次的父类（A），所以就导致了最顶层的父类（A）中的方法被调用了两次。</p><p>下面来具体说说 Python 中的 <code>super</code> 类。</p><h2 id="super-的作用"><a href="posts/58dd3c61/#super-的作用" class="headerlink" title="super 的作用"></a>super 的作用</h2><p>在 Python 中某 class 使用了 <code>super()</code> 后，<code>super</code> 即会沿着最初调用 <code>super()</code> 的那个 class 的 MRO 向上寻找超类：</p><pre><code class="python">&gt;&gt;&gt; B.mro()[__main__.B, __main__.A, object]&gt;&gt;&gt; C.mro()[__main__.C, __main__.A, object]</code></pre><p>也就是说：在 B 中调用的 <code>super</code> 不会顺着 B 的 MRO 来向上寻找，而是从最初调用的 D 的 MRO 来向上寻找。那么 <code>super</code> 是怎么知道最初的 class 是哪一个呢？</p><p>嘿嘿，你可能已经猜到了，没错，就是通过 <code>self</code> 这个参数来指定的：当我们调用 <code>d.hello()</code>时 ，实际上调用的是：<code>D.hello(d)</code>，而我们调用的 <code>super()</code> 也只是 Python 3 对 <code>super(a_class, a_instance)</code> （其实这里的 <code>instance</code> 也可以换成 <code>class</code>）的简写，所以其实 B、C、D 中的 <code>super()</code> 中的 <code>a_instance</code> 其实都是 d。 </p><p>当我们以 <code>super(a_class, a_instance)</code> 调用时，这里的 MRO 即为 <code>a_instance.__class__</code> 的 MRO，而 <code>a_class</code> 必须为该 MRO 中的某一项，也就是说 <code>isinstance(a_instance, a_class) == True</code>。</p><p><strong>简单来说</strong>，<code>super()</code> 做的事就是：你提供给它一个 class 以及一个 instance，它返回从该 instance 的 MRO 中排在 class 之后的类里，查找方法的对象。</p><p>说了这么多，那么这个 MRO 到底是怎么产生的？</p><h2 id="C3-算法"><a href="posts/58dd3c61/#C3-算法" class="headerlink" title="C3 算法"></a>C3 算法</h2><p>在 Python 2.3 之后，MRO 是由 C3 算法来计算得出的，而在 2.3 之前是按照如下规则计算：新式类是广度优先，经典类是深度优先。这里仅讨论 Python 2.3 版本之后的 MRO 计算方法，也就是 C3 算法：</p><p>为表述方便，先做出如下规定：<br></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>head([C_1,C_2,…,C_N]) = C_1<br></div><p></p><p></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>tail([C_1,C_2,…,C_N]) = [C_2, C_3,…,C_N]<br></div><p></p><p></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>L[C(C_1,…,C_N)]=[C]+merge(L[C_1],…L[C_N],[C_1,…,C_N])<br></div><p></p><p>则用 C3 算法计算这个列表的线性化可以用公式 (4) 表示，其中的 C 是继承自 C1，C2，… CN 的类。</p><p>对其中的 merge 操作可以解释为：</p><ol><li>选取等号右边 merge 列表的第一项 L[C1] 为 K；</li><li>如果 head(K) 没有在 merge 中的任何列表的 tail 中出现（这时称 head(K) 为 <code>good head</code>），则把 head(K) 加入 C 的线性化列表中，并将 head(K) 从 merge 的所有列表中删除，重复 2；</li><li>否则，设置 merge 中的下一项 L[C2] 为 K，如果 head(K) 为 <code>good head</code>，重复 2；</li><li>重复以上操作直到所有的 class 都被移除或者已经找不到 <code>good head</code> 为止；如果找不到 <code>good head</code> 那么就抛出异常，否则创建成功。</li></ol><p>来看个例子吧：</p><pre><code class="python">A = objectclass B(A): ...class C(A): ...class D(C, B): ...class E(C, D): ...</code></pre><p>首先 L[A] = [A]，然后：<br></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>L[B]=[B]+merge(L[A],[A])=[B, A]<br></div><p></p><p></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>L[C]=[C]+merge(L[A],[A])=[C,A]<br></div><p></p><p>这两个等式很简单，没什么好说的，来看个稍微复杂一点的：<br></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>\begin{aligned}<br>L[D]&amp;=[D]+merge(L[C],L[B],[C,B])\\<br>&amp;=[D]+merge([C,A],[B,A],[C, B])\\<br>&amp;=[D,C]+merge([A],[B,A],[B])\\<br>&amp;=[D,C,B]+merge([A], [A])\\<br>&amp;= [D,C,B]<br>\end{aligned}<br></div><p><br>稍微解释一下：</p><p>第二行，设置 K 为 [C, A]，其中 C，也就是 head(K) 是一个 <code>good head</code>，那么就把 C 加入 D 的列表，并把 C 删去；</p><p>第三行，这时设置 K 为 [A]，A 此时并不是一个 <code>good head</code>，因为他在 tail([B, A]) 中出现了，所以要设置下一项 [B, A] 为 K，此时 B 是一个 <code>good head</code>，那么就把 B 加入列表，并删除 B；</p><p>第四行，这时 K 为 [A]，A 此时是一个 <code>good head</code>，加入列表，并删除 A，此时所有 class 都已经被移除，算法结束。</p><p>来个错误的例子：<br></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>\begin{aligned}<br>L[E]&amp;=E+merge(L[C],L[D],[C,D])\\<br>&amp;=E+merge([C,A],[D,C,B,A],[C,D])<br>\end{aligned}<br></div><p><br>这时算法好像没有办法继续往下走了：因为设置 K 为 [C, A]，head(K) 并不是一个 <code>good head</code>，那么就把 K 设置为 [D, C, B, A]，这时还是不行，因为 D 也在后面列表中的 tail 出现了。</p><p>所以是无法选择 (C, D) 为基类来创建 E 的，如果你在解释器中执行一下代码，你就会发现，它报错了：</p><pre><code class="python">Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: Cannot create a consistent method resolutionorder (MRO) for bases C, D</code></pre><hr><p>以上，</p><p>愿对你有所帮助。</p><p>参考：</p><ul><li><a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">The Python 2.3 Method Resolution Order</a></li><li><a href="https://harttle.land/2015/09/07/effective-cpp-40.html" target="_blank" rel="noopener">Item 40：明智地使用多继承</a></li><li><a href="https://mozillazg.com/2016/12/python-super-is-not-as-simple-as-you-thought.html" target="_blank" rel="noopener">Python: super 没那么简单 - Huang Huang 的博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好像又有一段日子没写技术类博文，翻了翻归档，发现最近一篇技术类文章已经是俩月多之前的事了，吓得我赶紧&lt;del&gt;水&lt;/del&gt;写一篇的技术文章不然怕是要被人当成生活博主了。思来想去写些什么好，还是继续上次开的新坑，来聊聊 Python 中的继承。&lt;/p&gt;
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="Python" scheme="https://blog.itswincer.com/tags/Python/"/>
    
      <category term="继承" scheme="https://blog.itswincer.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="super" scheme="https://blog.itswincer.com/tags/super/"/>
    
      <category term="知多少" scheme="https://blog.itswincer.com/tags/%E7%9F%A5%E5%A4%9A%E5%B0%91/"/>
    
  </entry>
  
  <entry>
    <title>杭州见闻</title>
    <link href="https://blog.itswincer.com/posts/2848ddef/"/>
    <id>https://blog.itswincer.com/posts/2848ddef/</id>
    <published>2018-09-21T21:11:33.000Z</published>
    <updated>2018-09-21T21:11:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>似乎很难说出为什么我对杭州这座城市如此「情有独钟」，以至于暑假就和同学计划着来杭州实习，虽然还是拖到了开学。出发之前也没有准备许多东西，只是简单收拾了一下衣服。所幸到达杭州后遇到的问题（比如租房、工作等）都比较顺利的解决了：遇到了很棒的宾馆老板、主动给我指路的老奶奶、很 Nice 的面试官（随后顺利入职）……这一切都让我对杭州这座城市更有好感，也让如今的我庆幸没有来错杭州。</p><a id="more"></a><h2 id="面试"><a href="posts/2848ddef/#面试" class="headerlink" title="面试"></a>面试</h2><p>来杭州前，我和同学都约了面试，不同的是，他约了 5 场，我只约了 1 场。 在学校临走前的几天他都挺慌的，说 5 场万一都不合适怎么办，非要约 10 场差不多心里才有底，我就安慰他说没事，我才 1 场，我都不慌，你慌什么。他反而对我说，对啊，我要是你估计都慌得不敢去了，不知道你怎么这么有信心。</p><p>当时的我也不知道为什么这么有信心，似乎根本没有想过万一在杭州找不到工作怎么办。就这样，我抱着三分紧张，两分忐忑，五分兴奋的心情，进行了我人生中第一次面试。</p><p>面试中技术问题主要针对的是之前做的笔试题，而笔试题中大部分都是算法的，所幸虽然我虽好久没接触算法了，但也没有完全忘记。不过让我感到奇怪的是我简历中的项目反而问的不是很仔细，似乎公司更看重的是学习能力和思考方式，而说到学习能力我自然是不会虚谁了，毕竟现在掌握的技能大部分都是自学来的 :）</p><p>技术问题过后就是较为老套的提问流程了，比如你为什么要来杭州啊，你对我们公司想要了解什么啊，你对自己未来的职业规划是怎么样的啊等等。与面试官的沟通交流较为顺畅，面试官也说我是来面试中很优秀的了，两天后，顺利的拿到了 Offer。公司名字就不透露了，在和瑞科技园。</p><h2 id="蟹黄汤包"><a href="posts/2848ddef/#蟹黄汤包" class="headerlink" title="蟹黄汤包"></a>蟹黄汤包</h2><p>随后在等面试结果的一天里，让朋友领着逛了逛杭州。</p><p>那天早上朋友说带我去吃蟹黄汤包（青芝坞那家），当时已经早上十点了，朋友准备早午饭一起在那里吃，而我当时已经吃过早饭了，就准备到美院的食堂去吃午饭（我十分庆幸没有去美院的食堂吃，走了一圈愣是没找到食堂在哪），但禁不住朋友一直说这里的蟹黄汤包多么好吃多么好吃，于是我也点了一份。</p><p>等了差不多十几分钟，它才姗姗来迟。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1TBOGXiHrK1Rjy0Flq6AsaFXaE.jpg" alt="蟹黄汤包"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">蟹黄汤包</figure></p><p>外表乍一看和普通的汤包没什么区别，细看还是可以看出馅儿是偏黄一些的。我马上夹起一个就塞到了嘴里，差点没烫哭出来。朋友笑了，然后告诉我说汤包要先从褶子里把汤吸掉，要不然会很烫的。</p><p>想我以前在学校的时候，哪吃过现蒸的汤包啊，食堂大妈早就蒸好了，然后拿布盖着保温，虽然算不上冷，但也绝对算不上烫。</p><p>味道嘛，还算好吃。</p><h2 id="中国美院"><a href="posts/2848ddef/#中国美院" class="headerlink" title="中国美院"></a>中国美院</h2><p>话说其实一开始我不是很想去美院的（但没办法，谁让相机在我朋友手上呢），因为我觉得学校嘛，再好看还能比旅游景点好看？直到我见到美院的大门那一刻我才知道我错了。</p><p>前方多图预警（这个预警并没有什么卵用，因为当你点进这个页面的时候图片已经加载完毕了 :）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1kSeGXcnrK1RjSspkq6yuvXXab.jpg" alt="通向「幸福」的阶梯"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">通向「幸福」的阶梯</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB186SIchnaK1RjSZFtq6zC2VXa1.jpg" alt="这好像是自习室"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">这好像是自习室</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1mruHXojrK1RkHFNRq6ySvpXak.jpg" alt="可能是幸存的「变形金刚」"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">可能是幸存的「变形金刚」</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1r7yGXcnrK1RjSspkq6yuvXXaJ.jpg" alt="博物馆的侧面"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">博物馆的侧面</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1T0uHXh2rK1RkSnhJq6ykdpXaR.jpg" alt="我忘记这建筑是哪了"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">我忘记这建筑是哪了</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1VtaHXdzvK1RkSnfoq6zMwVXaO.jpg" alt="另一个博物馆的外层围墙"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">另一个博物馆的外层围墙</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1Wa9HXojrK1RkHFNRq6ySvpXas.jpg" alt="喵喵"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">喵喵</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1ztKHXh2rK1RkSnhJq6ykdpXaT.jpg" alt="山上的「宫殿」"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">山上的「宫殿」</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1t_iGXc_vK1RkSmRyq6xwupXao.jpg" alt="轮胎制椅子"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">轮胎制椅子</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1LNWGXjzuK1RjSspeq6ziHVXa6.jpg" alt="某建筑内部"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">某建筑内部</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1Pd9HXovrK1RjSszfq6xJNVXax.jpg" alt="超大的榕树"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">超大的榕树</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1XW5HXffsK1RjSszbq6AqBXXaw.jpg" alt="竹制的避雨场所"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">竹制的避雨场所</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1W7KGXoLrK1Rjy1zbq6AenFXaK.jpg" alt="奇奇怪怪的东西"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">奇奇怪怪的东西</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1xeGGXjzuK1Rjy0Fpq6yEpFXaw.jpg" alt="一个伪装成火车头的咖啡店"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">一个伪装成火车头的咖啡店</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB17xCGXirxK1RkHFCcq6AQCVXaV.jpg" alt="同上，不过换了一个滤镜"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">同上，不过换了一个滤镜</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1almGXozrK1RjSspmq6AOdFXaT.jpg" alt="校园的边界"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">校园的边界</figure></p><p>（不知是因为杭州的美女多还是因为学艺术的女生都比较有气质，真的不愧是<del>中国美女学院</del>中国美术学院。）</p><p>这次好像只逛了一半的校园，因为校园里面的建筑真的和迷宫一样，从一个建筑进去绕了一圈就不知道原先从哪出来的了，导致进校园和出校园都在同一侧，下次有机会还要去逛逛。</p><h2 id="工作"><a href="posts/2848ddef/#工作" class="headerlink" title="工作"></a>工作</h2><p>我目前所在的公司是早上九点上班，下午六点下班，中午午休一小时，一周五天。除了中午休息时间有一点短之外，几乎完美了，而我除了第一、第二天在下午会稍稍犯困之外，后面几天都挺精神的（当然，代价是晚上十点半就要睡觉，这对我反而是好事，正好能调整到健康的作息时间 :)</p><p>公司的同事都很年轻，办公氛围也比较轻松，不会像部分其它的公司那么压抑。那个 Nice 的面试官也成为了我目前所在项目组的 Leader。</p><p>我现在的日常生活就是每天早上睡到八点起，洗漱一下，买个早饭走十几分钟去公司，中午和同事一起去食堂吃午饭，晚上回来之后就写写博客或者看部电影。呐，惬意的生活啊。</p><p>今天也是第一周的最后一天班，早上去公司的时候发现桌上摆着一盒「蛋黄酥」，应该是中秋的礼物了。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1iCmHXorrK1RkSne1q6ArVVXaK.jpg" alt="蛋黄酥，还挺好吃"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">蛋黄酥，还挺好吃</figure></p><p>说到中秋，这应该是我第一个不在家过的中秋了吧，有些伤感。</p><p>最后，还是祝大家中秋节快乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;似乎很难说出为什么我对杭州这座城市如此「情有独钟」，以至于暑假就和同学计划着来杭州实习，虽然还是拖到了开学。出发之前也没有准备许多东西，只是简单收拾了一下衣服。所幸到达杭州后遇到的问题（比如租房、工作等）都比较顺利的解决了：遇到了很棒的宾馆老板、主动给我指路的老奶奶、很 Nice 的面试官（随后顺利入职）……这一切都让我对杭州这座城市更有好感，也让如今的我庆幸没有来错杭州。&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="杭州" scheme="https://blog.itswincer.com/tags/%E6%9D%AD%E5%B7%9E/"/>
    
      <category term="生活" scheme="https://blog.itswincer.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="旅游" scheme="https://blog.itswincer.com/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>写给 21 岁的自己</title>
    <link href="https://blog.itswincer.com/posts/d9253d8c/"/>
    <id>https://blog.itswincer.com/posts/d9253d8c/</id>
    <published>2018-08-29T00:00:00.000Z</published>
    <updated>2018-08-31T10:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<div id="aplayer" musicid="31861287"></div><script src="https://api.itswincer.com/music/v1/" async></script><p>人类似乎总是对自己无法掌控的事物有些畏惧，比如时间。我就有些害怕时间的流逝，总觉得去年那篇<a href="https://blog.itswincer.com/posts/11ab0263/">写给 20 岁的自己</a>的文章还历历在目，如今又到了该写这系列文章的时候了。我很早就开始构思这篇文章该写什么，却直到最近才了有些明确的思路。</p><p>去年，我曾对自己说，希望可以「不在意别人的眼光，不为了生存而活，为了自己的热爱」那样真实的活着。所幸我应当是在大部分时候都做到了，因此这一年过得很自在。但怎么说呢，近来关于这个问题我却有些困惑了。</p><a id="more"></a><p>前几天一朋友在群里说他辞职了。</p><p>问：为啥啊？这工作不好吗？</p><p>答：工作挺好的，划水都能拿 12k。</p><p>更奇怪了，又问：划水都能拿这么高，还有啥不满意的？</p><p>答：感觉生活没有目的，突然想辞职冷静一下。</p><p>当时还不太能理解他的想法，因为在我看来这简直是梦寐以求的工作啊：划水意味着我就有更多的时间投入到我所喜爱的事情上，但我没有说出口，只是默默听着。他继续说辞职亲戚朋友都反对，但他还是辞了——「迷茫了，每天这么混，不知道该干什么」，他说。听他说完这句话时我就有点理解了，是啊，<strong>没有以自我认可为目的的生活，又有什么可以阻止它慢慢滑向悬崖的另一侧呢</strong>。</p><hr><p>说来有些不好意思，我的自我认可很大一部分来自两部电影——《搏击俱乐部》和《三傻大闹宝莱坞》：做自己想做的事，不要做自己应该做的事情。具体解释就是我不想也没有必要活成别人眼中的自己。像别人一样告诉自己先买车、后买房、再结婚？这都是自己作，一辈子忙忙碌碌都不知道为什么而活，生命只有一次，为什么就不能为自己而活呢？做自己想做的事，不是很开心吗？</p><p>而现在我的想法好像有了些许的改变：在社会福利好的发达国家，也许公民是真的可以做到我梦想的这样：看起来不求上进，赚到钱就花，遇到热爱的事情就去做，一辈子都过得很开心、很舒服。但是在中国不行。</p><p>想成为自己、为自己而活当然没错。这也是电影想告诉我们的，但电影没有告诉我们的是，今天的自己是自己，明天的也是。十年后，三五十年后的都是自己。对于「自己」来说目前所有的选择都是自由的，可以选择自己所热爱的事，也可以按部就班地选择自己应该做的事。仅需记住目前做出的选择所造成的千差万别也是未来的自己所必须接受的。在中国如果按照我之前的那种想法去选择，可能并不会让三十年后的自己开心。当然，这种选择不能说是错的，更不应该被批判，只是说我们在自己没想清楚的时候可能会选择了以后的自己不想要的未来。</p><p>写到这忽然有点明白卢梭的那句「人生而自由，却又无往不在枷锁之中」中的意味了。</p><hr><p>关于我 21 岁的谈人生<del>瞎扯淡</del>就在这里告一段落了。确实，我没有像去年那样在全文中都很明确的表达出一个观点并以此作为我接下来一年生活的座右铭。反而是给了一个模棱两可的答案。但我想，相比去年，这个答案确实更好了——因为得出这个答案我思考得更全面了。或许我需要像阿甘一样，连续奔跑三年才知道自己为什么要奔跑。谁知道呢，也许我明天就想明白了，Life was like a box of chocolates. You never know what you’re gonna get（译文：人呐，就都不知道（命运），自己就不可以预料）。</p><p>用杨绛答复别人回信作为结尾吧：</p><blockquote><p>你们这些年轻人啊！ too young too simple, sometimes naive！你们啊，还是要提高自己的知识水平。</p></blockquote><p>啊不好意思，皮了一下，是下面这句：</p><blockquote><p>「你的问题主要在于读书不多而想得太多」——杨绛。</p></blockquote><p>最后，二十一岁快乐。</p><p>送给自己。</p>]]></content>
    
    <summary type="html">
    
      &lt;div id=&quot;aplayer&quot; musicid=&quot;31861287&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://api.itswincer.com/music/v1/&quot; async&gt;&lt;/script&gt;
&lt;p&gt;人类似乎总是对自己无法掌控的事物有些畏惧，比如时间。我就有些害怕时间的流逝，总觉得去年那篇&lt;a href=&quot;https://blog.itswincer.com/posts/11ab0263/&quot;&gt;写给 20 岁的自己&lt;/a&gt;的文章还历历在目，如今又到了该写这系列文章的时候了。我很早就开始构思这篇文章该写什么，却直到最近才了有些明确的思路。&lt;/p&gt;
&lt;p&gt;去年，我曾对自己说，希望可以「不在意别人的眼光，不为了生存而活，为了自己的热爱」那样真实的活着。所幸我应当是在大部分时候都做到了，因此这一年过得很自在。但怎么说呢，近来关于这个问题我却有些困惑了。&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://blog.itswincer.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="成长" scheme="https://blog.itswincer.com/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="感想" scheme="https://blog.itswincer.com/tags/%E6%84%9F%E6%83%B3/"/>
    
      <category term="21" scheme="https://blog.itswincer.com/tags/21/"/>
    
  </entry>
  
  <entry>
    <title>博客折腾小记</title>
    <link href="https://blog.itswincer.com/posts/50658b02/"/>
    <id>https://blog.itswincer.com/posts/50658b02/</id>
    <published>2018-08-22T11:31:58.000Z</published>
    <updated>2018-09-11T20:12:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>八个月前，我把建站之初就使用的 NexT 主题换成了 Material 主题，依稀还记得当时告诉自己：以后就好好写文章，绝对不再耗费时间在这没啥价值的事情上（让你立 Flag！后悔了吧？）。时隔半年多，如今发现对我来说好像不折腾比折腾还要难一些，原因嘛，自然是新鲜感与强迫症在作祟，这次折腾的起因就在于新鲜感——我看上了一个主题。</p><a id="more"></a><h2 id="优点与缺点"><a href="posts/50658b02/#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h2><p>这次更换的主题是 <a href="https://github.com/elmorec/hexo-theme-inside" target="_blank" rel="noopener">inside</a>，该主题相较于其它 hexo 主题的特殊之处就在于它的本质是采用 Angular 编写的 SPA（single page web application，单页应用程序）。优点就在于每次点击不同的链接只产生一个 HTTP 请求，返回的是一个 <code>.json</code> 文件，包含该页面的内容（内容已在 <code>hexo g</code> 时已经转成 HTML 格式了），而一旦接收到 <code>.json</code> 文件后，就会将文件的内容通过 <code>innerHTML</code> 属性嵌入页面。</p><p>而缺点在于相较于普通的页面，可能对 SEO 不那么友好。因为阻止页面呈现的 JavaScript 可能会对用户体验造成不好的影响，而我为此在额外方面做了补足：添加了 27 个 <code>&lt;meta&gt;</code> 标签，用 Google Chrome 测试 SEO 那一项拿了 89 分，应该还算不错了（拿不到满分是因为部分字体小于 16px）。</p><h2 id="URL-后缀"><a href="posts/50658b02/#URL-后缀" class="headerlink" title="URL 后缀"></a>URL 后缀</h2><p>采用 Angular 编写的 SPA 有一个 <del>Bug</del>Feature，即在路由时会自动去掉 URL 结尾的斜线（slash），这就很尴尬了，因为我的博客 URL 是默认在结尾都有一个斜线的，比如：<code>posts/xxxxxx/</code>，我对此的解决办法是：</p><ol><li><del>为每一个页面都添加一个 <code>canonical</code> 标记，其中标记的链接末尾都加上一个斜线；</del></li><li><del>但这样并不能解决 Google Analytics 的链接地址的问题，因为 Google Analytics 分析发送的 URL 是获取 HTTP 首部信息里的 referrer，为此我修改了发送 Google Analytics 的那部分代码：将每一个 URL 的尾部都加上了斜线；</del></li></ol><p>我在 Stack Overflow 上找到了更好的<a href="https://stackoverflow.com/questions/48425111/angular-5-allow-trailing-slash-in-routes" target="_blank" rel="noopener">解决方法</a>，原理是根据请求 URL 的每一个路由地址在末尾都加上斜线。</p><p>但若想完美的解决这个问题，还需同时为每个匹配的路由路径在末尾都补足一个斜线（否则带斜线的 URL 一刷新就会出现路由无法匹配的情况）。</p><pre><code class="typescript">...{ path: &#39;page/:page&#39;, component: VPostListComponent. resolve: { postList: PostListResolver }, data: { id: &#39;posts&#39; } },// =&gt;{ path: &#39;page/:page/&#39;, component: VPostListComponent. resolve: { postList: PostListResolver }, data: { id: &#39;posts&#39; } },...</code></pre><p>这样一来的话，斜线的问题算是解决了。（这部分也是我折腾耗时最多的部分。）</p><h2 id="用户体验"><a href="posts/50658b02/#用户体验" class="headerlink" title="用户体验"></a>用户体验</h2><p>我针对用户体验方面做了如下改进：</p><ul><li><p>字体</p><p>原主题的默认字体大小是 14px，我将正文修改成了 16px，代码字体修改为了 15px，这应该会比原主题看起来舒服一点。并且我移除了主题额外加载的字体文件，而纯粹改用 <code>font-family</code> 来呈现。参考了 <a href="https://zenozeng.github.io/fonts.css/" target="_blank" rel="noopener">fonts.css</a>。<del>我能吞下玻璃而不伤身体。The quick brown fox jumps over the lazy dog.</del></p></li><li><p>Service Worker</p><p>原主题不带 Service Worker 功能，但我还是为我的博客注册了 Service Worker 功能。</p></li><li><p>启用<a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">盘古之白</a></p><p>主要是为了解决中英文混排时的问题。因为研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。<del>终于找到了我之前过得如此不得意的原因了，看来从此之后我可以走上人生巅峰了。</del></p></li><li><p>Disqus</p><p>原主题对 Disqus 的 identifier 和 url 识别有误，自己新增的页面会在在首部添加 <code>posts/</code> 字段，比如我的 <code>life/</code> 页面会变成 <code>posts/life/</code>，这并不是我希望的。我针对当前 URL 简单的做了一个判断，根据 URL 的不同来生成指定的 identifier。</p></li><li><p>API</p><p>我将原主题的 API 请求前缀改了一下，不从源站请求。因为我的网站是使用 Cloudflare 来<del>减</del>加速访问，但国内的速度却不佳，而我博客大部分用户还是国内的。将 API 请求源放在了国内的 CDN 后，会更大的提升页面的访问速度——访问页面几乎感觉不到页面的加载时间。</p></li></ul><h2 id="个人喜好"><a href="posts/50658b02/#个人喜好" class="headerlink" title="个人喜好"></a>个人喜好</h2><p>相较之前的 material 主题，我去除了 <code>localStorage</code> 功能，因为现在的博客内容需要用 JavaScript 来呈现，而放入 <code>localStorage</code> 的资源取出的速度是不如直接从 Service Worker 请求的速度来的快。</p><p>同时我也移除了 lazyload-image 的功能，因为之前朋友告诉我说她从 RSS 阅读器阅读文章的时候图片没有显示，想了想应该是 lazyload 的 JS 没有加载所导致的，于是乎干脆去掉了，等以后有空的时候再试试 Angular 的 lazyload 是否也有这个问题。</p><p>由于该主题文章的内容是以 <code>innerHTML</code> 呈现的，故 <code>&lt;script&gt;</code> 标签里的内容是不会运行的，导致我的音乐插件 Aplayer 无法加载，于是我另写了一个页面专门呈现单独的音乐插件，再以 <code>iframe</code> 嵌入当前页面，算是比较完美的一个解决方案了。</p><h2 id="尾巴"><a href="posts/50658b02/#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>这篇文章一发布，预示着我博客栈的目录收录的文章也已到达两位数（10 篇）[^1]，强迫症终于满足了。</p><p>最后我想说：</p><ul><li>我真的再也不！想！写！前！端！了！</li><li>这绝对是我最后一次折腾博客！</li><li><del>真香！</del></li></ul><p>[^1]: 最近我将写得不是很满意的文章隐藏了起来（原本想删除的，后来想了想实在有些舍不得），有二十余篇，我的博客现在不提供这些文章的入口，你仍然可以通过我的 <a href="https://github.com/WincerChan/MyBlog" target="_blank" rel="noopener">MyBlog</a> 仓库查看这些文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;八个月前，我把建站之初就使用的 NexT 主题换成了 Material 主题，依稀还记得当时告诉自己：以后就好好写文章，绝对不再耗费时间在这没啥价值的事情上（让你立 Flag！后悔了吧？）。时隔半年多，如今发现对我来说好像不折腾比折腾还要难一些，原因嘛，自然是新鲜感与强迫症在作祟，这次折腾的起因就在于新鲜感——我看上了一个主题。&lt;/p&gt;
    
    </summary>
    
      <category term="博客栈" scheme="https://blog.itswincer.com/categories/%E5%8D%9A%E5%AE%A2%E6%A0%88/"/>
    
    
      <category term="主题" scheme="https://blog.itswincer.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
      <category term="博客" scheme="https://blog.itswincer.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="字体" scheme="https://blog.itswincer.com/tags/%E5%AD%97%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>Python 知多少（一）——不常见的数据结构</title>
    <link href="https://blog.itswincer.com/posts/dbcdebb/"/>
    <id>https://blog.itswincer.com/posts/dbcdebb/</id>
    <published>2018-08-08T11:30:32.000Z</published>
    <updated>2018-08-08T11:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>近来准备写几篇文章用于介绍 Python 较高级一些的特性，归为一个系列。本文是这个系列的第一篇文章，主要介绍一下内置的一些数据结构。</p><p>对 Pythoner 而言，元组（tuple）、列表（list）、字典（dict）这三个应该最熟悉的数据结构了，恰当使用这三个数据结构的话的确可以应对大部分的使用场合了，但有时因为其它方面的问题（内存占用、插入效率、删除效率等），我们仍有必要学习其它不那么常见的数据结构。</p><a id="more"></a><h2 id="数组"><a href="posts/dbcdebb/#数组" class="headerlink" title="数组"></a>数组</h2><p>初学者可能会认为在 Python 里，列表（list） 就是数组（array），其实不然。数组应当是一系列类型相同的变量的集合，而 Python 中的列表却可以存放任何不同类型的数据。Python 里也是有数组这个概念的，与列表有所不同的是数组里数据的存放方式（类型）并不是 Python 的基础类型（int、float、char）等，而是数字的机器标识（说白了就是和在 C 语言中存储方式一样），也因此，在将数据存入和读取文件时效率会更高一些。</p><p><code>array.array</code> 支持的数据类型包括整数、浮点数、字符三种，其中创建每个数组需要一个类型码（Type code），用以标识在 C 语言中存放怎样的数据类型，比如 <code>array(&#39;l&#39;)</code> 这样创建的就是存放四个字节大小的整数，范围从 - 2^31 到 2^31 - 1（更多的类型码使用 help(array) 查看）。</p><pre><code class="python">from array import arrayfrom reprlib import reprints = array(&#39;l&#39;, (i for i in range(10**7)))&gt;&gt;&gt; repr(ints)&quot;array(&#39;l&#39;, [0, 1, 2, 3, 4, ...])&quot;# write to filewith open(&#39;ints.bin&#39;, &#39;wb&#39;) as fp:    ints.tofile(fp)ints2 = array(&#39;l&#39;)# read from filewith open(&#39;ints.bin&#39;, &#39;wb&#39;) as fp:    ints2.fromfile(fp, 10**7)</code></pre><p>数组支持列表的大部分操作（准确地说是支持所有和可变序列的有关的操作），包括 <code>pop()</code>、<code>insert()</code>、<code>extend()</code> 等。</p><pre><code class="python">&gt;&gt;&gt; len(ints)10000000&gt;&gt;&gt; ints[-1]9999999&gt;&gt;&gt; ints.pop()9999999</code></pre><p>在排序这里与列表有一点小区别，列表支持 <code>list.sort()</code> 这种就地排序的方法，但数组不支持，所以想对数组进行排序的话，得用 <code>sorted</code> 新建一个数组：</p><pre><code class="python">tmp = array(ints.typecode, sorted(ints))</code></pre><h2 id="队列"><a href="posts/dbcdebb/#队列" class="headerlink" title="队列"></a>队列</h2><p>队列的特性是先进先出，虽然我们可以把列表当作队列来使用：<code>append()</code> 来模拟进队列，<code>pop(0)</code> 来模拟出队列：</p><pre><code class="python">class Queue:    def __init__(self, queue):        self.queue = list(queue)    def pop(self):        return self.queue.pop(0)    def push(self, num):        self.queue.append(num)    def __repr__(self):        return &#39;Queue&lt;%s&gt;&#39; % self.queueq = Queue(range(5))&gt;&gt;&gt; qQueue&lt;[0, 1, 2, 3, 4]&gt;&gt;&gt;&gt; q.push(5)&gt;&gt;&gt; qQueue&lt;[1, 2, 3, 4, 5]&gt;&gt;&gt;&gt; q.pop()1</code></pre><p>似乎看上去很完美，但是这种方法的弹出操作是很耗时的，因为删除列表的第一个元素会牵扯到移动列表里的所有元素。</p><p>这里介绍标准库中两种不同的队列：</p><h3 id="双向队列"><a href="posts/dbcdebb/#双向队列" class="headerlink" title="双向队列"></a>双向队列</h3><p><code>collections.deque</code> 类提供了一个双向队列，也就是说 <code>deque</code> 也完全可以栈来使用。它的 <code>append()</code>、<code>appendleft()</code> 和 <code>pop()</code>、<code>popleft()</code> 都是原子操作，这也意味这 <code>deque</code> 是线程安全的。<code>deque</code> 同样实现了所有和可变序列相关的操作。<code>deque</code> 可以接受一个可选参数（<code>maxlen</code>）表示队列可容纳元素的数量：</p><pre><code class="python">from collections import dequedq = deque(range(5), maxlen=5)&gt;&gt;&gt; dqdeque([0, 1, 2, 3, 4])&gt;&gt;&gt; dq.append(5)&gt;&gt;&gt; dqdeque([1, 2, 3, 4, 5])&gt;&gt;&gt; dq.popleft()1&gt;&gt;&gt; dqdeque([2, 3, 4, 5])&gt;&gt;&gt; dq.appendleft(1)deque([1, 2, 3, 4, 5])</code></pre><p>需注意，一旦添加了 <code>maxlen</code> 属性，这个属性就无法修改了。当对一个已满的队列进行添加操作时（第 5 行），另一头的元素会被挤掉。</p><h3 id="单向队列"><a href="posts/dbcdebb/#单向队列" class="headerlink" title="单向队列"></a>单向队列</h3><p>（原谅我想不出一个好名字了，只能用单向队列来和刚刚介绍的双向队列做区分了）。</p><p><code>queue.Queue</code> 类提供的是一个单向的队列，它与上面双向队列最大不同除了它是单向的之外，还有对于队列已经满了或空了的情况下，还要对队列进行添加或删除操作的结果不同：在满员（为空）时，如果还向 <code>Queue</code> 中插入（取出）元素的话，它不会扔掉旧的元素来腾出位置，反而是会锁住——直到另外的线程移除了某个位置，这一特性很适合用做生产者——消费者的模型，尤其是当生产者的生产时间与消费者的消费时间不匹配的情况，比如：生产者的生产时间快于消费者的消费时间，如果采用 <code>deque</code> 的话，就会丢失生产者最早时候生产的数据（反之就会造成消费者从空队列中取出数据的情况）。</p><pre><code class="python">from queue import Queuefrom threading import Threadimport loggingimport timelogging.basicConfig(level=logging.INFO,                    format=(&#39;%(asctime)s %(message)s&#39;))queue = Queue(1)def consumer():    time.sleep(.1)    queue.get()    logging.info(&#39;Consumer got 1&#39;)    queue.get()    logging.info(&#39;Consumer got 2&#39;)def producer():    queue.put(1)    logging.info(&#39;Producer put 1&#39;)    queue.put(2)    logging.info(&#39;Producer put 2&#39;)    thread.join()    logging.info(&#39;Producer done&#39;)thread = Thread(target=consumer)thread.start()producer()&gt;&gt;&gt;2018-08-07 19:56:42,234 Producer put 12018-08-07 19:56:42,335 Consumer got 12018-08-07 19:56:42,335 Producer put 22018-08-07 19:56:42,335 Consumer got 22018-08-07 19:56:42,335 Producer done</code></pre><p>消费者线程先等待了片刻是为了给生产线程留部分时间，使其在消费者从队列获取之前先将两个对象放入队列。然而，这里的缓冲区容量为 1，这就意味着生产线程在放入第一个数据后，会卡在第二个 <code>put</code> 方法那里，必须等待消费线程通过 <code>get</code> 方法把第一个数据消费之后，才能放入第二个对象。</p><h2 id="堆"><a href="posts/dbcdebb/#堆" class="headerlink" title="堆"></a>堆</h2><p>堆的性质是父节点（下标为 k）的值，总是小于（大于）等于其左（下标为 2k + 1）右（下标为 2k + 2）两个子节点的值。堆这种数据结构实际中多用于实现<strong>优先级队列</strong>（在 <code>queue</code> 模块中也有优先级队列的实现：<code>PriorityQueue</code> ）：在队列中，优先级较高的元素<strong>总</strong>排在前面。</p><p><code>heapq</code> 模块可以在标准的列表之中创建堆结构：</p><pre><code class="python">from heapq import heappush, heapify, heappopheap = []heappush(heap, 5)heappush(heap, 3)heappush(heap, 7)heappush(heap, 4)&gt;&gt;&gt; assert heap[0] == min(heap)&gt;&gt;&gt; heappush(heap, 2)&gt;&gt;&gt; heap[2, 3, 7, 5, 4]&gt;&gt;&gt; heappop(heap), heappop(heap), heappop(heap)(2, 3, 4)heap2 = [9, 8, 7, 6, 5, 4]heapify(heap2)&gt;&gt;&gt; heap2[4, 5, 7, 6, 8, 9]</code></pre><p><code>heappush</code> 和 <code>heappop</code> 方法总会保持堆的性质，将数据插入或弹出，<code>heappop</code> 总会将堆中优先级最高的元素弹出。其中 <code>heapify</code> 可在线性时间内将列表转化为堆。</p><h2 id="内存视图"><a href="posts/dbcdebb/#内存视图" class="headerlink" title="内存视图"></a>内存视图</h2><p>内存视图（memoryview）可以在不需要复制内容的前提下，在不同的数据结构之间共享内存。当你需要在内存中处理大量二进制数据时，或者需要反复修改内存中某块数据的内容，内存视图可能会对你有很大帮助：因为在 Python 中，对字符串（str）和字节数组（bytesarray）进行切片都是会造成内存的复制，尤其是当需要对较大的数据进行切片的时候，所耗费的代价将会非常昂贵。</p><pre><code class="python">from time import timedef mv_vs_bytes(factory, name):    for n in (100000, 200000, 300000, 400000):        data = b&#39;x&#39; * n        t0 = time()        b = factory(data)        while b:            b = b[1:]        print(name, n, time() - t0)mv_vs_bytes(lambda x: x, &#39;bytes&#39;)mv_vs_bytes(lambda x: memoryview(x), &#39;memoryview&#39;)&quot;&quot;&quot;output:bytes 100000 0.15474176406860352bytes 200000 0.6353733539581299bytes 300000 1.5503427982330322bytes 400000 2.8593809604644775memoryview 100000 0.008246183395385742memoryview 200000 0.017104148864746094memoryview 300000 0.025980710983276367memoryview 400000 0.03431963920593262&quot;&quot;&quot;</code></pre><p>可以看出，对 <code>bytes</code> 切片的时间复杂度是 O(n^2)，而对 <code>memoryview</code> 切片总能在线性时间内完成。</p><p>当然，由于 <code>bytes</code> 本身是不可变（immutable）的字节序列，如果想对 <code>memoriview</code> 中的数据进行修改的话，就需要用 <code>bytearray</code> 的方式构造 <code>memoryview</code> 对象：</p><pre><code class="python"># readonlyb = b&#39;Hello&#39;mv_b = memoryview(b)assert mv_b.readonly == True&gt;&gt;&gt; mv_b[0] = 73TypeError: cannot modify read-only memory# can writeba = bytearray(b)mv_ba = memoryview(ba)assert mv_ba.readonly == False&gt;&gt;&gt; mv_ba[0] = 73&gt;&gt;&gt; mv_ba.tobytes()b&#39;Iello&#39;</code></pre><p>由于 <code>memoryview</code> 使用了缓冲区协议（协议提供的是 C 语言级别的 API），导致 <code>memoryview</code> 只有在 CPython 中才能发挥它最大的作用。</p><p>本系列全部文章可访问「<a href="../../tags/知多少/">知多少</a>」标签查看。</p><p>参考：</p><ul><li><a href="https://www.oreilly.com/library/view/fluent-python/9781491946237/" target="_blank" rel="noopener">Fluent Python</a></li><li><a href="https://effectivepython.com/" target="_blank" rel="noopener">Effective Python</a></li><li><a href="https://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews" target="_blank" rel="noopener">Less copies in Python with the buffer protocol and memoryviews</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近来准备写几篇文章用于介绍 Python 较高级一些的特性，归为一个系列。本文是这个系列的第一篇文章，主要介绍一下内置的一些数据结构。&lt;/p&gt;
&lt;p&gt;对 Pythoner 而言，元组（tuple）、列表（list）、字典（dict）这三个应该最熟悉的数据结构了，恰当使用这三个数据结构的话的确可以应对大部分的使用场合了，但有时因为其它方面的问题（内存占用、插入效率、删除效率等），我们仍有必要学习其它不那么常见的数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="Python" scheme="https://blog.itswincer.com/tags/Python/"/>
    
      <category term="知多少" scheme="https://blog.itswincer.com/tags/%E7%9F%A5%E5%A4%9A%E5%B0%91/"/>
    
      <category term="数据结构" scheme="https://blog.itswincer.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="高级" scheme="https://blog.itswincer.com/tags/%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>基于 Socket 编写 HTTP 服务器</title>
    <link href="https://blog.itswincer.com/posts/89381f22/"/>
    <id>https://blog.itswincer.com/posts/89381f22/</id>
    <published>2018-08-03T12:06:13.000Z</published>
    <updated>2018-08-03T12:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>在大二上《计算机网络》这门课的时候，由于并不是很喜欢这门课的老师，导致我在上课的大部分时间都在摸鱼<del>（啊喂，学校教的哪门课你没在摸鱼啊？）</del>。最近看了《<a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">图解HTTP</a>》这本书，借这本书正好也复习了一下应用层和传输层协议，毕竟现在的 Web 应用几乎都是在应用层的 HTTP 协议运行的，而 HTTP 又是基于传输层的 TCP 协议来实现的。</p><a id="more"></a><p>我一直认为检验学习新知识是否牢靠最好的方法就是写一个小的实例，于是乎，借助于 Socket 模块（仅对 BSD Sockets API 进行封装），我也实现了一个静态的 HTTP 服务器，当然，比标准库提供的 SimpleHTTP 要强一点，因为我编写的支持并发。源码见<a href="https://github.com/WincerChan/Tiny-Http" target="_blank" rel="noopener">这里</a>。</p><h2 id="Socket-服务器"><a href="posts/89381f22/posts/89381f22/#Socket-服务器" class="headerlink" title="Socket 服务器"></a>Socket 服务器</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>HTTP 协议是基于 TCP 协议来实现的，也就是说要实现 HTTP 服务器首先就需要先创建一个 TCP 连接，而一个完整的 TCP 连接是同时需要客户端和服务端的，而客户端和服务端的创建，就需要借助 Socket（套接字）了。</p><p>通常创建一个 Socket 需要为其指定地址族（包括本机、IPV4、IPV6）、套接字类型（流式、数据报式，分别对应 TCP 和 UDP）</p><pre><code class="python">from socket import AF_INET, SOCK_STREAM, socket# create a tcp socketsock = socket(AF_INET,SOCK_STREAM)# equal tosock = socket()</code></pre><p>随后需要为该 <code>socket</code> 绑定一个 IP 地址和端口，并开始监听该地址（listen 可传入参数，表示排队连接的数量）：</p><pre><code class="python">sock.bind((&#39;0.0.0.0&#39;, 8888))sock.listen()</code></pre><p>随后，就可以等待客户端发起连接请求了：</p><pre><code class="python">conn, addr = socket.accept()</code></pre><p>随后该连接会阻塞，直到 accept 到客户端的连接之后（客户端可使用 <code>telnet 0.0.0.0 8888</code> 来连接），随后程序就会继续运行，这时就可以通过 socket 连接来传输数据了，在 telnet 输入任何字符，随后在客户端接收，再响应请求：</p><pre><code class="python"># accept 10 bytes dataconn.recv(10)# send responseconn.send(b&#39;hello world&#39;)</code></pre><h3 id="封装"><a href="posts/89381f22/#封装" class="headerlink" title="封装"></a>封装</h3><p>我们后续编写 HTTP 服务器仍是基于这一套流程，只是在客户端请求和服务端应答的内容不一样，故而封装成一个类，方便继承，以下为一个回显服务端，从客户端接收到的任何消息都会将其返回：</p><pre><code class="python">from socket import AF_INET, SOCK_STREAM, socketclass EchoServer:    def __init__(self, port=8888, addr=&#39;0.0.0.0&#39;, family=AF_INET,                 type_=SOCK_STREAM, backlog=0, init=True):        self.addr = addr        self.port = port        self.family = family        self.type_ = type_        self.backlog = backlog    def _echo(self, sock: socket):        while True:            try:                req_head = sock.recv(1)            except BrokenPipeError:                break            else:                if not req_head:                    break                sock.send(req_head)    def _run(self):        self.sock.listen(self.backlog)        while True:            sock, addr = self.sock.accept()            print(&#39;Connect by {} Port {}&#39;.format(*addr))            self._echo(sock)    def __call__(self):        self.sock = socket(self.family, self.type_)        self.sock.bind((self.addr, self.port))        print(&#39;Listen in %s port.&#39; % self.port)        self._run()</code></pre><h3 id="测试用例"><a href="posts/89381f22/#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><pre><code class="python">&gt;&gt;&gt; serve = EchoServer()&gt;&gt;&gt; serve()&quot;&quot;&quot;telnet 0.0.0.0 8888Trying 0.0.0.0...Connected to 0.0.0.0.Escape character is &#39;^]&#39;.HelloHelloI&#39;m Wincer.I&#39;m Wincer.&quot;&quot;&quot;Listen in 8888 port.Connect by 127.0.0.1 Port 45186...</code></pre><h2 id="HTTP-服务器"><a href="posts/89381f22/#HTTP-服务器" class="headerlink" title="HTTP 服务器"></a>HTTP 服务器</h2><h3 id="HTTP-报文"><a href="posts/89381f22/#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p>那么有了 TCP 连接，该怎么实现 HTTP 协议呢，其实很简单，HTTP 协议只是在传输的内容上做了规定：满足「报文首部」、「空行」、「报文主体」，这样通过服务器发出去就算是一个 HTTP 报文了，不信？试试就知道了。</p><p>将上面的 EchoServer 中的 <code>_echo</code> 方法修改一下，让其返回以下数据：</p><pre><code class="python">data = &quot;&quot;&quot;HTTP/1.1 200 OKContent-Length: 11Hello World&quot;&quot;&quot;class EchoServer:    def _echo(self, sock):        try:            req_head = sock.recv(1)        except BrokenPiperError:            return         else:            if not req_head:                return            # 注意这里必须要将字符串编码成 bytes 才能发送。        sock.send(data.encode(&#39;utf-8&#39;))        sock.close()&gt;&gt;&gt; serve = EchoServer(8888)&gt;&gt;&gt; serve()Listen in 8888 port.</code></pre><p>咳咳，准备好了吗，打开浏览器，输入 <code>http://0.0.0.0:8888</code>，如无意外，你就可以在屏幕上看见 <code>Hello World</code> 了。</p><p>这就算最「小」的 HTTP 服务器了，不管向它发送什么请求，不管请求的是什么，它都会返回 <code>Hello World</code>：</p><pre><code class="bash">curl http://0.0.0.0:8888Hello Worldcurl http://0.0.0.0:8889/\?testHello Worldcurl -X OPTIONS http://0.0.0.0:8889/\?testHello Worldcurl -X POST http://0.0.0.0:8889/\?test\&amp;param\=blockHello World</code></pre><p>这是因为我们还没有对请求报文首部进行分析，从而根据请求路径的不同或者请求方式的不同来返回相应的数据。</p><h3 id="响应请求"><a href="posts/89381f22/#响应请求" class="headerlink" title="响应请求"></a>响应请求</h3><p>既然要做一个静态的服务器，最少也应该分析 <code>GET</code> 请求，根据请求的 URL 作出响应，那么就需要增加额外的函数了：</p><pre><code class="python">class HttpServer(EchoServer):    def _echo(self, sock: socket):        try:            req_head = sock.recv(1024)        except BrokenPipeError:            return        else:            if not req_head:                return            head = self._get_head(req_head)            sock.send(head.encode(&#39;utf-8&#39;))            self._send_body(sock)            logging.info(&#39;HTTP/1.1 %s GET %s&#39; % (self.status, Signal.path))        sock.close()</code></pre><p>我这里（在 <code>_echo</code> 中）增加了两个函数：<code>_get_head</code> 和 <code>_send_body</code>。作用分别是根据客户端的请求报文的首部来生成相应的服务端响应报文首部和根据客户端的请求 URL 发送响应的报文主体内容，比如，请求首部：</p><pre><code class="http">GET /index.html HTTP/1.1HOST: 0.0.0.0:8888USER-AGENT: curl/7.61.0Accept: */*</code></pre><p>响应首部（可将请求的资源以 <code>rb</code> 模式打开，并读入内存，再作为响应报文主体发送）：</p><pre><code class="http">HTTP/1.1 200Content-Length: 11Content-Type: text/html; charset=utf-8Date: Thu, 02 Aug 2018 03:58:09 GMTServer: TinyHttpHello World</code></pre><p>有关这两个函数的具体实现，可以参考我这部分的<a href="https://github.com/WincerChan/Tiny-Http/blob/master/tinyhttp/http/server.py#L49-L70" target="_blank" rel="noopener">源码</a>。</p><h2 id="并发请求优化"><a href="posts/89381f22/#并发请求优化" class="headerlink" title="并发请求优化"></a>并发请求优化</h2><p>我们的服务器现在已经可以根据 GET 请求的 URL 来返回相应的报文了，很好，但现在的服务器不支持并发请求，也就是说必须先对前一个请求作出完整的响应，并将响应发送出去之后，才能处理下一个请求，造成这种后果最重要的一点原因就是：<code>socket.recv()</code> 和 <code>socket.send()</code> 都是阻塞型 I/O 函数，也就是说，CPU 会一直等待这两个函数执行完成才继续执行后面的代码。</p><p>虽然在本地局域网内，作出大部分响应的时间都很快（毫秒级别），但我们仍有必要对阻塞型 I/O 函数进行优化，优化方法有两种：</p><ol><li>在单独的线程中运行该阻塞型操作</li><li>把该阻塞调用转化为非阻塞的异步调用使用</li></ol><p>其中第一个方法很简单，借助 <code>threading</code> 模块即可实现，重写一下 <code>_run</code> 方法：</p><pre><code class="python">class ThreadHttpServer(HttpServer):    def _run(self):        self.sock.listen(self.backlog)        while True:            sock, addr = self.sock.accept()            Thread(target=self._echo, args=(sock,)).start()</code></pre><p>而第二个方法就需要借助 Asyncio 这个库了（由于借助了 Asyncio 这个库，要求 Python 版本为 3.5+），该库重写了标准库 socket 中的阻塞 I/O 函数，将其改为了非阻塞形式的异步调用，由于该方法改动的地方太大，就不贴完整的代码了，可移步至这部分的<a href="https://github.com/WincerChan/Tiny-Http/blob/master/tinyhttp/async/asyncserver.py" target="_blank" rel="noopener">源码</a>。</p><h2 id="薛定谔的-BUG"><a href="posts/89381f22/#薛定谔的-BUG" class="headerlink" title="薛定谔的 BUG"></a>薛定谔的 BUG</h2><p>同我在<a href="../8575e868/#%E5%AE%9E%E7%8E%B0">之前一篇博文</a>提到的类似，这次同样遇上了一些薛定谔的 BUG：</p><h3 id="大文件传输"><a href="posts/89381f22/#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h3><p>当以 <code>open</code> 函数打开某一个文件时，会把这个文件的内容读入到内存中，如果只是普通的文本或者图片倒是不会出现什么问题，但是一旦读入的文件过大（比如我就喜欢在电脑开启静态 HTTP 服务，然后在局域网内其它的设备打开共享的视频来播放），就会出现两个情况：</p><ol><li>占用的内存空间过大，程序 gg；</li><li>成功读入内存，但花了很多时间读入内存，服务端又花了很多时间发送，客户端又花了很多时间接收；</li></ol><p>于是乎，大名鼎鼎的「generator（生成器）」终于派上了用场。将 <code>_get_body</code> 函数（请求的文件内容）中的 <code>open</code> 函数作为一个生成器，每读取一行（<code>readline()</code>）就 yield 一次，在 <code>_send_body</code> 函数中不断对 <code>_get_body()</code> 返回的数据进行迭代发送，这样既不会一次性全部读入内存，造成内存空间不足、又不会花费过多的时间在 I/O 上，一举两得，当然，为此你需要加上一个 <code>Content-Lenght</code> 的首部，用以告诉客户端什么时候接收完毕。</p><h3 id="目录与文件"><a href="posts/89381f22/#目录与文件" class="headerlink" title="目录与文件"></a>目录与文件</h3><p>当请求的是目录时，URL 最尾端应当为 <code>/</code>，这时返回的应该是该目录下的 <code>index.html</code> 文件，如没有的话就返回该目录下的文件列表（同样的，列表中的目录应当以 <code>/</code> 在末尾标识），如果点击了该目录下的子目录，则应递归的显示子目录。</p><p>但当以 <code>os.listdir</code> 列出文件列表时，并不会显式的将目录以 <code>/</code> 标识，而仍需我们手动判断，当请求同名目录但末尾没有 <code>/</code> 时，应当将状态码设置为 301，并在响应头部加上 <code>Location: https://localhost:8888/xxx/</code> 用以显式的指向目录。</p><h2 id="结语"><a href="posts/89381f22/#结语" class="headerlink" title="结语"></a>结语</h2><p>其实这个服务器在结构上并不复杂，甚至可以说简单，就是依据 Socket 建立 TCP 连接，再分析请求首部得到的 URL，用 <code>rb</code> 模式加载并作为响应主体返回，但也确实让我学习到了不少：比如说「面向对象」范式的好处，即在构建以 <code>TCP-&gt;HTTP-&gt;ThreadHTTP、AsyncHTTP</code> 这样自顶向下的结构时，继承（<code>ThreadHTTP</code> 继承于 <code>HTTP</code>，而 <code>HTTP</code> 又继承于 <code>TCP</code>）可以大大的减少代码量和提高可重用性；再比如说生成器，即惰性求值的好处（节省内存），这好像还是我第一次正式在代码中用到生成器。</p><p>而这两点，想来只有自己在生产代码中遇到过，才能切实体会到好处。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在大二上《计算机网络》这门课的时候，由于并不是很喜欢这门课的老师，导致我在上课的大部分时间都在摸鱼&lt;del&gt;（啊喂，学校教的哪门课你没在摸鱼啊？）&lt;/del&gt;。最近看了《&lt;a href=&quot;https://book.douban.com/subject/25863515/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图解HTTP&lt;/a&gt;》这本书，借这本书正好也复习了一下应用层和传输层协议，毕竟现在的 Web 应用几乎都是在应用层的 HTTP 协议运行的，而 HTTP 又是基于传输层的 TCP 协议来实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="Socket" scheme="https://blog.itswincer.com/tags/Socket/"/>
    
      <category term="异步" scheme="https://blog.itswincer.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="HTTP" scheme="https://blog.itswincer.com/tags/HTTP/"/>
    
      <category term="服务器" scheme="https://blog.itswincer.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hitokoto（一言）API 2.0 正式上线</title>
    <link href="https://blog.itswincer.com/posts/a5c39267/"/>
    <id>https://blog.itswincer.com/posts/a5c39267/</id>
    <published>2018-07-16T11:48:15.000Z</published>
    <updated>2018-07-16T11:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年夏天的时候，用 Flask 开发了一个<a href="../f6e1eb2a/">简易版的一言</a>，算是最初的 beta 版，部署在了 Heroku 上面（那时我还没购买服务器），由于 Heroku 免费版有时间池的限制，在我购置了服务器后就重新用 Go 重写了一下<a href="../b3085a7/#搭建-API">部署在自己的服务器上</a>，算是 1.0 版，这两天又重新拾坑，开发出了 2.0 版本。</p><a id="more"></a><h2 id="前言"><a href="posts/a5c39267/#前言" class="headerlink" title="前言"></a>前言</h2><p>在 1.0 版本使用了较长的时间后，基于以下考量，我还是重构了部分代码：</p><ol><li>收录一言数太少：我没事的时候就喜欢刷新玩，经常发现眼熟的，毕竟也就不到一千条；</li><li>性能：由于使用的是 SQLite，在每秒请求数在 1000 的时候就 GG 了；</li><li>查询参数：返回不超过查询长度参数的一言，但翻了一大堆 API，都并没有提供这个功能；</li></ol><p>于是乎，本着「生命不死，折腾不止」的态度，2.0 版本诞生了。</p><blockquote><p>本 API 的<a href="https://github.com/WincerChan/Hitokoto" target="_blank" rel="noopener">源码</a>已开源至 GitHub，如有需要的可自行搭建。</p></blockquote><p>以下是 2.0 版本的更新日志：</p><h2 id="数量问题"><a href="posts/a5c39267/#数量问题" class="headerlink" title="数量问题"></a>数量问题</h2><p>爬取数据时采用了异步爬虫，解决了 1.0 版本爬取时效率低下的问题，同时选取了 xxhash 作为散列函数，将一言主体 hash 后，得到的 64bit 的无符号整数作为主键，这样如果爬取到了重复的一言也不会插入数据库中。</p><p>得益于异步爬虫的高效率，在很短的时间内，爬取到了足够的一言数。目前，数据库内共有 <code>15371</code> 条一言。以后数量还会不断地增加。<a href="https://github.com/WincerChan/Hitokoto-Spider" target="_blank" rel="noopener">爬虫程序</a>已托管至 GitHub。</p><h2 id="性能问题"><a href="posts/a5c39267/#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>数据库更换成了 MySQL，以承受高并发访问，以下为建表语句：</p><pre><code class="mysql">+----------+---------------------+------+-----+---------+-------+| Field    | Type                | Null | Key | Default | Extra |+----------+---------------------+------+-----+---------+-------+| id       | bigint(20) unsigned | NO   | PRI | NULL    |       || hitokoto | varchar(300)        | NO   |     | NULL    |       || source   | varchar(64)         | NO   |     | NULL    |       || origin   | varchar(12)         | NO   |     | NULL    |       |+----------+---------------------+------+-----+---------+-------+</code></pre><h2 id="参数问题"><a href="posts/a5c39267/#参数问题" class="headerlink" title="参数问题"></a>参数问题</h2><p>2.0 版本共包含以下请求参数：</p><h3 id="编码格式"><a href="posts/a5c39267/#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>格式为 <code>encode=</code>，包含以下四个参数值：</p><ul><li>js：JavaScript 脚本，将一言插入 HTML 中第一次出现 <code>class = &#39;hitokoto&#39;</code> 的标签中</li><li>json：JSON 格式的字符串，包含主体（hitokoto），出处（source）</li><li>text：一言句子的主体</li><li>默认为：<code>×××××——「×××」</code>，即主体 + 出处</li></ul><h3 id="字符集"><a href="posts/a5c39267/#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>格式为 <code>charset=</code>，包含以下两个参数值：</p><ul><li>utf-8：在 Header 中的 <code>content-type</code> 字段添加 <code>charset=utf-8</code></li><li>gbk：同上</li></ul><h3 id="长度"><a href="posts/a5c39267/#长度" class="headerlink" title="长度"></a>长度</h3><p>格式为 <code>length=</code>，会随机返回一条不超过这个查询长度的语句。</p><h3 id="回调"><a href="posts/a5c39267/#回调" class="headerlink" title="回调"></a>回调</h3><p>格式为 <code>callback=</code>，会根据回调参数的值返回对应的函数调用，其中函数的参数为一个字典，key 分别为 <code>hitokoto</code> 和 <code>source</code>。</p><blockquote><p><strong>注意：callback 参数会覆盖掉 encode 参数</strong></p></blockquote><h2 id="使用示例"><a href="posts/a5c39267/#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>调用地址：<code>https://api.itswincer.com/hitokoto/v2/</code></p><p>例如，我想请求一个长度不超过 10 的一言，并以 JSON 格式返回：</p><pre><code class="bash">curl &#39;https://api.itswincer.com/hitokoto/v2/?encode=json&amp;length=10&#39;{&quot;hitokoto&quot;:&quot;(눈_눈)&quot;,&quot;source&quot;:&quot;进击的巨人&quot;}</code></pre><p>如果想在自己的网页使用的话，可以采取以下两种方法：</p><h3 id="JS-方法"><a href="posts/a5c39267/#JS-方法" class="headerlink" title="JS 方法"></a>JS 方法</h3><p>只需要在想要展示的标签加上 <code>class=&#39;hitokoto&#39;</code> 属性，随后在任何地方加上：</p><pre><code class="html">&lt;script src=&quot;https://api.itswincer.com/hitokoto/v2/?encode=js&quot;&gt;&lt;/script&gt;</code></pre><p>插入页面的显示结果是：××××××× ——「×××」形式。</p><p>展示结果见侧栏。</p><h3 id="回调方法"><a href="posts/a5c39267/#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><p>如果对 <code>encode=js</code> 返回的格式不满意，可自行定义页面展示的格式：比如以下代码仅展示一言的主体部分：</p><p>定义标签和函数：</p><pre><code class="html">&lt;p class=&quot;hitokoto&quot;&gt;&lt;/p&gt;&lt;script&gt;    // 定义回调函数名 showHitokoto    function showHitokoto(data){        // 比如我只想展示一言主体部分        var hitokoto = data.hitokoto;        // 插入 class=hitokoto 的标签        var dom = document.querySelector(&#39;.hitokoto&#39;);        Array.isArray(dom)?dom[0].innerText=hitokoto:dom.innerText=hitokoto;    }&lt;/script&gt;</code></pre><p>随后将请求地址加上参数 <code>callback=showHitokoto</code>：</p><pre><code class="html">&lt;script src=&quot;https://api.itswincer.com/hitokoto/v2/?callback=showHitokoto&quot;&gt;&lt;/script&gt;</code></pre><p>以上示例将会在 HTML 标签首个包含 <code>class=&#39;hitokoto&#39;</code> 的标签内部插入仅包含一言主体的部分。</p><h2 id="尾巴"><a href="posts/a5c39267/#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>你看到某句熟悉的一言从屏幕上显示的时候，勾起了之前第一次看到这句话时或感动、或开心、或难过的回忆，而某个陌生人也会因此和你一样陷入属于他的短暂回忆——想到这些不是很快乐吗？而我想那个陌生人一定也正想着同样的事情。我一直这样觉得。</p><p>而这，应当就是文字赋予一言的最大作用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年夏天的时候，用 Flask 开发了一个&lt;a href=&quot;../f6e1eb2a/&quot;&gt;简易版的一言&lt;/a&gt;，算是最初的 beta 版，部署在了 Heroku 上面（那时我还没购买服务器），由于 Heroku 免费版有时间池的限制，在我购置了服务器后就重新用 Go 重写了一下&lt;a href=&quot;../b3085a7/#搭建-API&quot;&gt;部署在自己的服务器上&lt;/a&gt;，算是 1.0 版，这两天又重新拾坑，开发出了 2.0 版本。&lt;/p&gt;
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="一言" scheme="https://blog.itswincer.com/tags/%E4%B8%80%E8%A8%80/"/>
    
      <category term="API" scheme="https://blog.itswincer.com/tags/API/"/>
    
      <category term="Hitokoto" scheme="https://blog.itswincer.com/tags/Hitokoto/"/>
    
  </entry>
  
  <entry>
    <title>博客访问统计报告（2017.6.20-2018.7.4）</title>
    <link href="https://blog.itswincer.com/posts/790223d2/"/>
    <id>https://blog.itswincer.com/posts/790223d2/</id>
    <published>2018-07-05T10:52:34.000Z</published>
    <updated>2018-07-08T10:51:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客<a href="../4a17b156/">建站至今</a>也一年有余了，本想着在一周年（今年 5 月初）之际写一篇文章纪念一下，顺便公布一下本博客在这一年的访问情况，可当时发现统计记录还没有满一年（我是在 2017 年 6 月底才开始使用的 Google 分析），于是就想干脆等到 6 月底再写。而前段时间又忙于准备期末考试，直到昨天放假回家，似乎才有时间写这一篇文章。</p><a id="more"></a><h2 id="前言"><a href="posts/790223d2/#前言" class="headerlink" title="前言"></a>前言</h2><p>首先我并不确定 Google 分析的准确性有多高，因为当我查看 Cloudflare 自带的分析功能时，得到的数据与 Google 分析的有很大很大的差别。以近一周的数据做对比：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1sonpB8mWBuNkSndV763sApXaO.png" alt="左 Google，右 Cloudflare" title="左 Google，右 Cloudflare"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">左 Google，右 Cloudflare</figure></p><p>虽说 Cloudflare 统计了所有的 HTTP 请求，但<strong>我博客实则只有 html 页面才会走 Cloudflare 的线路</strong>，其它的静态资源我都放在 CDN 了。而 Cloudflare 对于近一周访问 html 页面给出的数据是占总请求数的 48%——约 3411 次，这应该是与 Google 的页面浏览量（540）作为对比（加上其余两个子网站的浏览量分别为 121、4），可以看到仍然有将近 7 倍的差距，用户数也有近 5 倍差距——我确实想不出一个合理的解释（根据 Cloudflare 给出的解释，可能是由于某些网络爬虫，故与基于 Javascript 的统计工具来说有较大出入）。</p><p>但 Cloudflare 无法给出像 Google 分析那样包括平均会话、每次会话浏览数、跳出率等等指标，故本篇博客还是选取 Google 分析的数据进行分析。</p><h2 id="受众群体"><a href="posts/790223d2/#受众群体" class="headerlink" title="受众群体"></a>受众群体</h2><p>在过去的一年零两周内，本博客的基本访问情况如下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1RzYAKeOSBuNjy0Fd762DnVXaB.png" alt="概览"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">概览</figure></p><p>这期间，本博客一共迎来了 5,446 位用户，他们一共产生了 10,508 次会话以及 19,989 次浏览。平均每天 14 位用户、28 次会话、53 次浏览。</p><p>图表中有一个较为凸出的高峰（5 月 29 日），原因是我在 V2EX 发了帖介绍自己写的一个<a href="https://www.v2ex.com/t/458433#reply23" target="_blank" rel="noopener">表情包生成工具</a>，这个工具中算是间接性的把用户引导至本博客了。</p><h2 id="流量获取"><a href="posts/790223d2/#流量获取" class="headerlink" title="流量获取"></a>流量获取</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1.vYJKXuWBuNjSszb763S7FXaU.png" alt="流量"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">流量</figure></p><p>其中流量获取的来源主要是三部分：Referral（引荐）、Organic Search（搜索引擎）、Direct（直连）。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1VOjDtpooBKNjSZPh7632CXXaY.png" alt="对比"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">对比</figure></p><p>其中 Google 的流量占了大多数：36.80%，其次是本博客自身的引荐；本博客并没有添加百度站长的信息，并且主动屏蔽了百度蜘蛛的爬取，故并没有来自百度的流量。</p><p>现在的 Google 分析为了保护用户隐私，已经无法显示用户查询的关键词了。</p><h2 id="地理位置"><a href="posts/790223d2/#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1BiGLB2iSBuNkSnhJ762DcpXak.png" alt="地理"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">地理</figure></p><p>毫无疑问，本博客的主要流量都来自于中国大陆，不过令我感到奇怪的是第二名是美国。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1jDv.Kh1YBuNjy1zc762NcXXaZ.png" alt="语言"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">语言</figure></p><p>在操作系统语言中：</p><p>简体中文（zh-CN + zh-cn）占了 72.27%，较地理为中国大陆的 68.93% 多出了 3.34 个百分点；</p><p>英语（en-US + en-us）占了 16.91%，较地理为美国的 11.06% 也多出了 5.85 个百分点；</p><p>也就是说，并非只有美国地区的人才会使用英文，也并非中国地区的人才会使用中文。</p><h2 id="设备信息"><a href="posts/790223d2/#设备信息" class="headerlink" title="设备信息"></a>设备信息</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1MG58jNtnkeRjSZSg760AuXXa4.png" alt="浏览器"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">浏览器</figure></p><p>首先看看浏览器的占用，由于本博客的类型更偏技术一些，故 Chrome、Safari、Firefox 的使用占据前三甲，其中 IE 的份额不足 0.4%，这意味着我并不需要照顾 IE 的用户，可以尽情使用各种新技术。</p><p>第四的 Android Webview 应该是指 App（QQ、微信） 内置的浏览器。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1koW2tOMnBKNjSZFC7600KFXaT.png" alt="操作系统"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">操作系统</figure></p><p>操作系统毫无疑问是以 Windows 独占鳌头，其次是 Linux，我一直使用 Manjaro Linux 作为日常开发，比 Windows 方便许多，也没有 Windows 那么多 Bug，由于娱乐方式的缺乏，在 Linux 下开发也会更加专注。</p><h2 id="浏览页面"><a href="posts/790223d2/#浏览页面" class="headerlink" title="浏览页面"></a>浏览页面</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1GsLSKk9WBuNjSspe761z5VXal.png" alt="页面浏览"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">页面浏览</figure></p><p>在本站可访问页面中（仅统计文章页面），浏览量的前六名分别是：</p><ol><li><a href="/posts/ad42f575/">Linux 与 Windows 10 用 GRUB 引导教程</a></li><li><a href="/posts/cfd78fa9/">解除百度云下载限速</a></li><li><a href="/posts/2aa541e6/">Spacemacs 生存指北</a></li><li><a href="/posts/bf0413ac/">Nextcloud 搭建私人云服务教程</a></li><li><a href="/posts/72171293/">QQ 音乐外链解析</a></li><li><a href="/posts/8575e868/">Sorry，会写代码真的能为所欲为</a></li></ol><p>（唉，最满意的几篇文章浏览量反倒是挺低的，心情复杂.jpg。）</p><h2 id="后记"><a href="posts/790223d2/#后记" class="headerlink" title="后记"></a>后记</h2><p>自本博客运营至今共发布了 53 篇文章，其中自 17 年 9 月以来，发文的频率明显降低：首 4 个月发了 33 篇文章，17 年 9 月至今却只发了 20 篇。一方面是刚建站的时候事比较多；另一方面是相较于博客数量来说，更开始注重博客质量了。</p><p>最初我选择运营独立博客，并非想从中得到什么实质性的好处，只是作为一种兴趣。而如今在快餐时代坚持写独立文章的人越来越少，这也无可厚非，毕竟短期内看不到结果的话，有些人就无法坚持了。我周围的人似乎对此（我写博客这件事）也表示不太理解，但我还是会一直做下去。我一直认为，只要能长期的投入一件事中，最终一定能从中获取到乐趣和满足感。</p><p>我就是如此。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的博客&lt;a href=&quot;../4a17b156/&quot;&gt;建站至今&lt;/a&gt;也一年有余了，本想着在一周年（今年 5 月初）之际写一篇文章纪念一下，顺便公布一下本博客在这一年的访问情况，可当时发现统计记录还没有满一年（我是在 2017 年 6 月底才开始使用的 Google 分析），于是就想干脆等到 6 月底再写。而前段时间又忙于准备期末考试，直到昨天放假回家，似乎才有时间写这一篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="博客栈" scheme="https://blog.itswincer.com/categories/%E5%8D%9A%E5%AE%A2%E6%A0%88/"/>
    
    
      <category term="博客" scheme="https://blog.itswincer.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Google-Analytics" scheme="https://blog.itswincer.com/tags/Google-Analytics/"/>
    
      <category term="访问统计" scheme="https://blog.itswincer.com/tags/%E8%AE%BF%E9%97%AE%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用持续集成（CI）开发项目</title>
    <link href="https://blog.itswincer.com/posts/f011ea9c/"/>
    <id>https://blog.itswincer.com/posts/f011ea9c/</id>
    <published>2018-06-09T10:22:34.000Z</published>
    <updated>2018-06-15T12:34:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>我的博客在建站后不久就使用了 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 自动部署服务，即我只需要将修改的源码推送至 GitHub，Travis CI 会自动将我提交的代码拉取，在 Travis CI 端生成静态文件后，同步至我的服务器，这样可以减少一些麻烦的步骤：可以直接在 GitHub 端修改代码；不用等待生成静态文件、压缩静态文件的时间。<a id="more"></a></p><h2 id="Circle-CI"><a href="posts/f011ea9c/#Circle-CI" class="headerlink" title="Circle CI"></a>Circle CI</h2><p>虽然使用 Travis CI 是能简化部分开发流程，但这货和 GitHub 是一对一的，只支持在 GitHub 托管的项目，并不支持 Bitbucket 和 GitLab，而 GitHub 免费版在私人仓库这一方面是比不上 Bitbucket 和 GitLab 的（虽然我是学生，可以使用 GitHub 私人仓库，可我也不一直是学生呀），同时支持 Bitbucket 的和 GitHub 私人仓库的 CI 工具（自建的除外）好像真的也就 <a href="https://circleci.com/" target="_blank" rel="noopener">CircleCI</a> 了，这里之所以没有考虑 GitLab 是因为 GitLab 自带有 CI/CD，而且这家公司给我的印象实在不太好（包括之前的删库事件，以及莫名奇妙的 Bug）。</p><p>在了解 CircleCI 后发现比 Travis CI 真是强不少（CircleCI 是基于 Docker 和 Workflows 设定模式的），不过在网上并没有很完善的中文教程<del>（虽然官方英文文档已经很完善了）</del>。所以如果你懒得翻官方文档的话，继续往下看我这篇文章就好了🤓。</p><h2 id="选择仓库"><a href="posts/f011ea9c/#选择仓库" class="headerlink" title="选择仓库"></a>选择仓库</h2><p>CircleCI 支持 GitHub 和 Bitbucket 帐号的登录，授权登录完成后，就可以添加 Projects 了，支持 GitHub 和 Bitbucket 的公有及私有仓库。这里以我的 <a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">Meme-generator</a> 仓库为例。</p><p>选完仓库后，就可以开始配置 CircleCI 了。</p><h2 id="准备工作"><a href="posts/f011ea9c/#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="添加-SSH-密钥"><a href="posts/f011ea9c/#添加-SSH-密钥" class="headerlink" title="添加 SSH 密钥"></a>添加 SSH 密钥</h3><p><a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">Meme-generator</a> 仓库用到 SSH 密钥的地方有两处：</p><ol><li>从 GitHub 克隆仓库</li><li>将编译后的静态文件推送至我的服务器</li></ol><p>如果你是用来推送至 GitHub 的话，可以直接用 GitHub 提供为该仓库提供的 Token 密钥，第一点也可以使用 HTTPS 方式克隆，就可以省去添加 SSH 密钥这个步骤。</p><p>点击 CircleCI 个人主页的 JOBS 菜单项，随后点击仓库名称右边的齿轮按钮 -&gt; 点击 <code>SSH Permissions</code> -&gt; 点击蓝色的 <code>Add SSH Key</code> 按钮，将<strong>私钥</strong>（看清楚了，是私钥）粘贴进去（超级良心有木有啊，比 Travis CI 将私钥加密上传这种土办法不知道高到哪里去了）。</p><h3 id="添加-IP-至-known-hosts"><a href="posts/f011ea9c/#添加-IP-至-known-hosts" class="headerlink" title="添加 IP 至 known_hosts"></a>添加 IP 至 known_hosts</h3><p>添加 SSH 密钥后，还需要将服务器的 IP 添加至 known_hosts 列表，否则每次部署的时候都会让你确认以下消息：</p><pre><code class="bash">The authenticity of host &#39;××.×××.×××.×××&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:7hkfahfla8VeiuyF/TLHKfhakgcJ0sHjaLxDyIKlfhak9fuaofoa.Are you sure you want to continue connecting (yes/no)?</code></pre><p>同 Travis CI 类似，CircleCI 在运行的过程中也是不接受命令行输入的（当然运行完成后就更不行了），所以我们需要提前将 IP 写入 known_hosts（在 CircleCI 中如何做？继续往后看）：</p><pre><code class="bash">ssh-keyscan $SSH_IP &gt;&gt; ~/.ssh/known_hosts</code></pre><p>在该仓库的管理页面中的 <code>Environment Variables</code> 选项卡中添加 SSH_IP 的环境变量。</p><h2 id="配置文件"><a href="posts/f011ea9c/#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="简单的例子"><a href="posts/f011ea9c/#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>由于我的配置文件太过长了，先以一个简化版为例：</p><pre><code class="yaml">version: 2jobs:  build:    docker:      - image: circleci/node:10.4.0    steps:      - checkout      - run:          name: Install Dependence          command: |            yarn install &amp;&amp; yarn build      - run:            name: Deploy            command: |              echo &quot;Denpendence installed.&quot;</code></pre><p>首先指明 CircleCI 的版本号——2.0（1.0 在 18 年 9 月之后就停止支持了）。</p><p>其次，为 Docker 指定 image（<a href="https://circleci.com/docs/2.0/circleci-images/" target="_blank" rel="noopener">这是</a>官方已经构建完成的镜像列表），可以指定多个 image。先前提到过，CircleCI 并不默认像 Travis CI 那样提供 Linux 虚拟机镜像，推荐使用的是 Docker（当然你也可以指定工作方式为 Machine），这是官方针对 Docker 和 Machine 的<a href="https://circleci.com/docs/2.0/executor-types/#overview" target="_blank" rel="noopener">对比报告</a>。</p><p>随后在 <code>steps</code> 里面是需要运行的指令：</p><ol><li><code>checkout</code> 是一个用于检查配置路径的源代码的特殊步骤，并可以通过 SSH 来 clone 远程仓库的代码（如果你已经添加了 SSH 私钥的话，不然就只好手动 clone 了），详解见<a href="https://circleci.com/docs/2.0/configuration-reference/#checkout" target="_blank" rel="noopener">官方文档</a></li><li><code>run:</code> 后面接的是 bash 命令，<code>name</code> 该任务的名称，<code>command</code> 为具体 bash 的指令</li></ol><h3 id="安装额外命令"><a href="posts/f011ea9c/#安装额外命令" class="headerlink" title="安装额外命令"></a>安装额外命令</h3><p>需要注意的是，如果你需要将生成的静态文件同步至服务器所用的 <code>rsync</code> 命令是没有被安装的，只有<a href="https://circleci.com/docs/2.0/circleci-images/#pre-installed-tools" target="_blank" rel="noopener">这些命令</a>是被安装在所有镜像中的。</p><p>docker 镜像预装的系统是 Ubuntu，可采取 <code>apt-get</code> 命令来安装需要的软件包：</p><pre><code class="yaml">run:   name: Update System  command: |    sudo apt-get update &amp;&amp; sudo apt-get install rsync</code></pre><h3 id="设置缓存"><a href="posts/f011ea9c/#设置缓存" class="headerlink" title="设置缓存"></a>设置缓存</h3><p>CircleCI 建议的 Workflows 中建议将整个工作流分割成不同的子作业，比如说以 Yarn 项目为例，可以分成 <code>build</code> 和 <code>deploy</code> 两个流程。其中 <code>build</code> 用以安装依赖和生成待部署的静态文件；<code>deploy</code> 用以将生成的静态文件部署至服务器。</p><p>可以看出，静态文件是横跨两个作业的，所以我们需要将包含静态文件的文件夹缓存下来（当然你也可以选择不使用 Workflows，这样就只需创建一个工作就好了），在 <code>build</code> 工作中缓存采取如下命令：</p><pre><code class="yaml">steps:  - restore_cache:    keys:      - build-v1-{{ checksum "package.json" }}    paths:      - &quot;build&quot;</code></pre><p>以上命令是将 <code>build</code> 文件夹以 <code>key-value</code> 形式缓存，其中 <code>key</code> 选择的是 <code>package.json</code> 的哈希值。这里的文件名最好选择仓库自带的文件。更多 <code>key</code> 的形式可以参考<a href="https://circleci.com/docs/2.0/caching/#using-keys-and-templates" target="_blank" rel="noopener">这里</a>。</p><p>在 <code>deploy</code> 工作中恢复缓存采取以下命令：</p><pre><code class="yaml">steps:  - checkout  - restore_cache:    keys:      - meme-v1-{{ checksum "package.json" }}</code></pre><p>注意在 <code>restore_cache</code> 之前一定要有 <code>checkout</code> 命令。</p><h3 id="完整的示例"><a href="posts/f011ea9c/#完整的示例" class="headerlink" title="完整的示例"></a>完整的示例</h3><p>直接贴 <a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">Meme-generator</a> 项目的配置代码了：<br><iframe style="height: 0;" frameborder="0" name="WincerChan" id="displayGist" width="100%" data-src="https://blog.itswincer.com/gist/v1/?user=WincerChan&gist=04b5e1ee8a1fbc8bc2e078d2c354bd7b"></iframe><button class="load_gist" onclick="let frame = document.querySelector('#displayGist');frame.src=''+frame.getAttribute('data-src')">Click me to load GIST</button></p><p>每次构建完成后，commits 列表的画风就变成这样了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858045/blog/ci_project/circleci_construction.png" alt="CircleCI 构建"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">CircleCI 构建</figure></p><p>点击 Details 就会显示每次构建的详细过程。</p><h2 id="后记"><a href="posts/f011ea9c/#后记" class="headerlink" title="后记"></a>后记</h2><p>虽然本文名为「使用持续集成（CI）开发项目」，但实际却好像只介绍了 CircleCI，当然我的意思不是钦定 CircleCI 作为最好的持续集成系统，我没有说 CircleCI 是最好的持续集成系统，没有任何这个意思。但你一定要问我为什么选 CircleCI，它现在对 Bitbucket 和 GitHub 的私人仓库支持最完善，我怎么能不支持它呢？</p><p>参考：</p><ul><li><a href="https://circleci.com/docs/2.0/" target="_blank" rel="noopener">2.0 Docs</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的博客在建站后不久就使用了 &lt;a href=&quot;https://travis-ci.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Travis CI&lt;/a&gt; 自动部署服务，即我只需要将修改的源码推送至 GitHub，Travis CI 会自动将我提交的代码拉取，在 Travis CI 端生成静态文件后，同步至我的服务器，这样可以减少一些麻烦的步骤：可以直接在 GitHub 端修改代码；不用等待生成静态文件、压缩静态文件的时间。
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="CI" scheme="https://blog.itswincer.com/tags/CI/"/>
    
      <category term="持续集成" scheme="https://blog.itswincer.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Sorry，会写代码真的能为所欲为</title>
    <link href="https://blog.itswincer.com/posts/8575e868/"/>
    <id>https://blog.itswincer.com/posts/8575e868/</id>
    <published>2018-05-27T10:34:21.000Z</published>
    <updated>2018-05-27T10:35:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一段时间「这个仇我先记下了」的表情包突然火了，导致我也萌生了自己写一个表情包生成工具的想法，毕竟我是重度表情包玩家😌。其实之前我就很喜欢做表情包，不过是用的 PS 等软件，有些麻烦，而且改 GIF 也不太方便。</p><p>于是乎，我决定也蹭一波热度，也写了一个，最初是只有「记仇」这个静态表情包的，现在加上了王境泽、为所欲为、打工是不可能打工的等等动图，模板后续还会添加，如果有好的素材可以私我。<a id="more"></a></p><h2 id="思路"><a href="posts/8575e868/#思路" class="headerlink" title="思路"></a>思路</h2><p>当然网上也有一些表情包生成器，比如「<a href="https://github.com/xtyxtyx/sorry" target="_blank" rel="noopener">sorry</a>」，但界面我不太喜欢，而且我觉得这类较为简单的处理没必要借助服务器端渲染合成，直接在浏览器端渲染就好了，<del>毕竟 JavaScript 算是一门「万能的语言」</del>。</p><p>核心思路是采用 omggif 对 GIF 进行解码，再用 Canvas 将文字绘制在每一帧上，最后再用 gif.js 将每一帧合成，再渲染后输出成 Blob 文件对象（<a href="https://caniuse.com/#search=blob" target="_blank" rel="noopener">现在不支持 Blob 的浏览器应该没有了吧？</a>），传递给 IMG 标签进行显示。</p><p>这是解码过程：</p><pre><code class="javascript">// 解码let gifReader = new omggif.GifReader(buffer);    // 获取帧let frameZero = girReader.frameInfo(0)            // 获取帧的宽高，绘制 Canvas 的时候会用到let [width, height] = [frameZero.width, frameZero.height]    let imageBuffer = new Uint8ClampedArray(width * height * 4)gifReader.decodeAndBlitFrameRGBA(frameNum, imageBuffer);// 生成图像数据，供 Canvas 使用let imageData = new window.ImageData(imageBuffer, width, height)</code></pre><p>这是绘制过程：</p><pre><code class="javascript">ctx.putImageData(imageData, 0, 0)// 这是字幕的白边ctx.strokeText(caption, width / 2, height - 5, width);// 这是字幕的主体ctx.fillText(caption, width / 2, height - 5, width)</code></pre><p>这是编码（渲染）过程：</p><pre><code class="javascript">let gif = new GIF({    workers: 3,    quality: 10,    width: imageWidth,    height: imageHeight,})// Canvas 的数据加入帧gif.addFrame(ctx, {    copy: true,    delay: frameInfo.delay,    dispose: -1})// 开始渲染gif.render()// 渲染完成gif.on(&#39;finished&#39;, Blob =&gt; {    gifUrl = window.URL.createObjectURL(Blob);    img.src = gifUrl;})</code></pre><p>以上是动图的设计思路，静态图就显得简单多了，采用 dom-to-img 绘制就行了，但是在 Edge 上似乎是无法使用的，作者提到似乎是因为添加了 foreignObject 标签，导致 toDataUrl() 在 Edge 上无法工作，所以 Edge 用户只能使用动图部分了。</p><p>其实核心思路很简单，gif.js 和 omggif 提供的 API 也不复杂，但我还是花了将近一周的时间，因为这是我首次使用 React 开发应用，所以有大半时间都花在了学习 React 上，然而写出来的结果还是偏「Pure JavaScript」一些。</p><p><a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">本项目</a>采用 <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> 构建，CSS 框架采用了 <a href="https://github.com/jgthms/bulma" target="_blank" rel="noopener">bulma</a>，部分动图模板来自 <a href="https://github.com/xtyxtyx/sorry" target="_blank" rel="noopener">sorry</a>。</p><h2 id="实现"><a href="posts/8575e868/#实现" class="headerlink" title="实现"></a>实现</h2><p>刚刚有提到，我在设计该工具的时候大部分时间都没有花在核心思路部分，而是花在了——我称为「薛定谔的 Bug」上，即：你在设计该工具的蓝图的时候，没有设想到会出现这些 Bug，而实际编程中，也不一定会遇到，只有你亲自编写了，才知道这 Bug 是否会出现。</p><p>我在这次编程中就遇到了四个「薛定谔的 Bug」：</p><h3 id="Blob-文件对象"><a href="posts/8575e868/#Blob-文件对象" class="headerlink" title="Blob 文件对象"></a>Blob 文件对象</h3><p>关于静态图部分，我设计了两个按钮：「戳我预览」和「戳我下载」，其实本应该只需要一个下载按钮就够了，因为我使用 contenteditable 属性以编辑 p 标签。和生成的预览图几乎没什么差别，那么为什么要设计两个呢？就是因为 Blob 对象（后续思考了一下，虽然可以先行判断浏览器是否支持 Blob 下载，但针对动态图还是需要预览修正的，故为了设计上的统一性，还是将预览按钮保留了）。</p><p>其实大部分人应该是没有听说过这个名词的（包括我），但它还真的不是一个新玩意，甚至都不是 HTML5 新增的 API，相比于 HTML5 在 2014 年才完成标准制定，在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">MDN</a> 上查到 Blob 对象在 2010 年就被主流浏览器支持了（Chrome 5、Firefox 4、Opera 11.1），但，如今大部分手机浏览器却仍不支持 Blob 文件下载协议。</p><p>所以只好提供一个预览按钮来供不支持 Blob 文件下载协议的浏览器长按进行保存。</p><h3 id="服务器问题"><a href="posts/8575e868/#服务器问题" class="headerlink" title="服务器问题"></a>服务器问题</h3><p>由于我的服务器是在国外，而且还套了一层 Cloudflare，故而在某些情况下，加载动图会非常慢，尤其是在晚上（大约花费 1min，而且居然还没断，我真是很佩服 Cloudflare 的稳定性）。</p><p>当然图片的加载问题还不算大，可以放在<a href="https://sm.ms" target="_blank" rel="noopener">支持跨域的图床</a>上，由 <code>fetch</code> 调用，问题最大的是 Web Worker（合成 GIF 的时候需要使用），但这个 Web Worker 的地址在 Chrome 下<strong>只允许</strong>同域名下的脚本，即使是公共 CDN 上允许跨域都不行。</p><p>这里采用还是借助 Blob 对象，巧妙的规避这一限制：</p><pre><code class="javascript">let tmpWorker = await fetch(url),    workerSrcBlob = new Blob([await tmpWorker.text()], { type: &#39;text/javascript&#39; }),    workerBlobURL = window.URL.createObjectURL(workerSrcBlob);</code></pre><h3 id="React-Router-404-错误"><a href="posts/8575e868/#React-Router-404-错误" class="headerlink" title="React Router 404 错误"></a>React Router 404 错误</h3><p>在将代码生成「production build」时，遇到了一个 Bug，有时访问二级路由会出现 404，多次复现后，终于确定了：</p><p>在访问二级路由时，如果是正常从一级页面点击跳转的，则会正常访问；</p><p>但如果是直接访问二级路由或者是在二级路由刷新页面，则会出现 404；</p><p>但是这个 Bug 在「development build」中是没有的，原因在于当你点击路由时，并不是直接向服务器发起请求，而是由 react-router 路由库给出路由网址，故而刷新二级路由页面或者直接访问二级路由页面服务器是无法正确响应的。</p><p>以下是解决办法，在 Nginx 中添加 <code>try_files</code> 语句：</p><pre><code class="nginx">server {    location / {        try_files $uri /index.html    }}</code></pre><h3 id="GIF-渲染"><a href="posts/8575e868/#GIF-渲染" class="headerlink" title="GIF 渲染"></a>GIF 渲染</h3><p>当我解决了以上问题的时候，我发给室友首先试用，看到了「戳我预览」这个按钮，他就以「单身十八年」的手速猛戳了四五下，随后标志着渲染进度条就「鬼畜」了起来。因为他猛戳的那几下相当于在后台启动了好几个渲染程序，不仅会让进度条「鬼畜」起来，如果你以更快的手速戳的话（单身八十年？）还会让 CPU 负担加重，甚至会卡死，当然我是没有试过。其实这 Bug 算是无伤大雅的，本不太需要修复，<del>因为不像其它生成器拿服务器做后端，可能会造成服务器宕机，我的纯前端写的</del>。但我本着人道主义情怀、不让我的 Bug 陪我过夜的心理，以及最重要的强迫症，还是决定修复这个 Bug。</p><p>其实很简单，设置一个全局变量 <code>finished</code>，在渲染的过程中，该变量为 <code>false</code>，渲染完毕后设置成 <code>true</code>，再将渲染过程放置在 <code>if(finished)</code> 内就解决了。</p><h2 id="教程"><a href="posts/8575e868/#教程" class="headerlink" title="教程"></a>教程</h2><p>见<a href="https://github.com/WincerChan/Meme-generator/wiki" target="_blank" rel="noopener">本项目的 Wiki</a>。</p><h2 id="结语"><a href="posts/8575e868/#结语" class="headerlink" title="结语"></a>结语</h2><p>本工具还有很多需要改进的地方，比如 React 的写法不够规范、没有完全实现静态动态资源分离、用户自定义添加模板等等，这些我在空闲时间里都会一点点的改进。</p><p>目前在实用的角度来说，该工具已经可以投入使用了，剩下的细节就需要慢慢雕琢了。:)</p><p>参考：</p><ul><li><a href="https://github.com/xtyxtyx/sorry" target="_blank" rel="noopener">xtyxtyx/sorry</a></li><li><a href="https://blog.csdn.net/xfgryujk/article/details/79889942" target="_blank" rel="noopener">纯 JS 实现在前端制作 GIF 表情包的网站</a></li><li><a href="https://react-guide.github.io/react-router-cn/docs/guides/basics/Histories.html" target="_blank" rel="noopener">Histories</a></li></ul>]]></content>
    
    <summary type="html">
    
      前一段时间「这个仇我先记下了」的表情包突然火了，我也萌生了自己写一个表情包生成工具的想法，而网上目前有的生成器大都是后端版，我就决定用 JavaScript 写一个。
    
    </summary>
    
      <category term="实验室" scheme="https://blog.itswincer.com/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="表情包" scheme="https://blog.itswincer.com/tags/%E8%A1%A8%E6%83%85%E5%8C%85/"/>
    
      <category term="JavaScript" scheme="https://blog.itswincer.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Python 字典的原理及高级用法</title>
    <link href="https://blog.itswincer.com/posts/4f2b4bfb/"/>
    <id>https://blog.itswincer.com/posts/4f2b4bfb/</id>
    <published>2018-05-12T09:23:02.000Z</published>
    <updated>2018-05-12T12:36:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>算算时间有段时间没写技术类的文章了，部分原因是最近过得确实比较忙。当然，也并没有忙到完全抽不出时间写博客，根本原因还是没有找到啥好的写作素材，随随便便糊弄一篇我又有点不好意思发上来，于是乎，就一直搁置到现在。</p><a id="more"></a><p>对于字典这一基础的数据结构来说，其对 Python 的程序重要性是无可替代的，在《代码之美》一书中，作者是这么描述的：</p><blockquote><p>字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到它。——A.M.Kuchling</p></blockquote><p>在 Python 程序里，无论是模块、函数、还是对象，均有自己的「命名空间」，而这命名空间即为一个字典（dict），key 就是变量名，value 就是变量值，除去「命名空间外」，对象的函数（方法）关键字也是存放在字典中，此时的 key 就是函数（方法）名，value 就是该函数（方法）的引用。可以采用 __builtins__.__dict__ 来查看这些函数（方法）。</p><h2 id="字典的原理"><a href="posts/4f2b4bfb/#字典的原理" class="headerlink" title="字典的原理"></a>字典的原理</h2><p>Python 的字典是依据<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">散列表</a>（也叫哈希表）来实现的，首先简单介绍一下散列表的原理。</p><p>散列表中的每一个单元称为表元。在 dict 的实现里，每个 key-value 均占用一个表元，其中 key 为<strong>键的引用</strong>（这里是键的引用，而不是键本身，因为 key 可以为任意可散列对象），value 为值的引用。因为是引用：表元大小均一致，所以可通过偏移量来读取某个表元。</p><p>在 Python 中，散列函数由 hash() 方法出任，当我们查询 my_dict[search_key] 时，Python 会调用 hash(search_key) 来计算 search_key 的散列值，并将这个值的低几位数字当作偏移量，在散列表中查找表元，具体是几位，需要根据散列表的大小来决定。若表元为空，则说明 search_key 不存在，抛出 KeyError 异常。若非空，则表元会有一对 found_key:found_value，这时若 search_key == found_key 为真，那么就返回 found_value。</p><p>如果 search_key 和 found_key 不相等，这种情况成为散列冲突，发生这种情况是因为散列表只把该元素映射到了只有几位数字上。为了解决散列冲突，算法会在散列值中另外取几位，用新得到的数字做偏移量再次寻找。</p><h2 id="创建字典"><a href="posts/4f2b4bfb/#创建字典" class="headerlink" title="创建字典"></a>创建字典</h2><p>创建一个字典有许多方式：</p><pre><code class="python">a = dict(one=1, two=2, three=3)b = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}c = dict(zip([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [1, 2, 3]))d = dict([(&#39;two&#39;, 2), (&#39;one&#39;, 1), (&#39;three&#39;, 3)])e = dict({&#39;three&#39;: 3, &#39;one&#39;: 1, &#39;two&#39;: 2})&gt;&gt;&gt; a == b == c == d == eTrue</code></pre><p>在刚刚的原理中说到，由于字典的索引是根据 hash() 函数来获得的，所以 dict 其实是无序的，这也解释了为什么上面代码中的等式会成立。</p><h2 id="字典推导"><a href="posts/4f2b4bfb/#字典推导" class="headerlink" title="字典推导"></a>字典推导</h2><p>没错，在 Python3+ 里，推导式不再是列表的特性了。</p><pre><code class="python">numbers = range(5)numbers_square = {number: number ** 2 for number in numbers}</code></pre><h2 id="键查询"><a href="posts/4f2b4bfb/#键查询" class="headerlink" title="键查询"></a>键查询</h2><p>最简单的方法是采用下标方式来查询。即：my_dict[key]，这也是推荐的方法，但这是 key 存在的情况，而现实中，一定会遇到 key 不存在的时候，这时就会 raise 一个 KeyError。以下有几种解决办法：</p><h3 id="用-get-来获取"><a href="posts/4f2b4bfb/#用-get-来获取" class="headerlink" title="用 get 来获取"></a>用 get 来获取</h3><pre><code class="python">my_id = {&#39;name&#39;: &#39;wincer&#39;}&gt;&gt;&gt; my_id.get(&#39;name&#39;)&#39;wincer&#39;&gt;&gt;&gt; my_id.get(&#39;age&#39;, &#39;default&#39;)&#39;default&#39;</code></pre><p>若 key 存在，则返回对应的 value，若 key 不存在，且传入第二个参数，那么返回该参数，若无第二个参数，则返回 None。</p><h3 id="用-defaultdict-预先设置缺省（推荐）"><a href="posts/4f2b4bfb/#用-defaultdict-预先设置缺省（推荐）" class="headerlink" title="用 defaultdict 预先设置缺省（推荐）"></a>用 defaultdict 预先设置缺省（推荐）</h3><pre><code class="python">from collections import defaultdictmy_id = defaultdict(list)my_id.update({&#39;name&#39;: &#39;wincer&#39;})&gt;&gt;&gt; mydict[&#39;name&#39;]&#39;wincer&#39;&gt;&gt;&gt; mydict[&#39;age&#39;][]</code></pre><p>defaultdict 需要指定一个 factory，当查询 key 不存在时，会创建一个空的 factory 返回。推荐使用这种方式来处理 key 不存在的情况，因为该方法不仅可用于读取 value 值，还可随时用 append 来更新 value。同时需注意：<strong>defaultdict 中的参数只会在 __getitem__ 中被调用。如 dd 是一个 defaultdict，k 是一个不存在的键，dd[k] 用 factory 来创造一个默认值，但 dd.get(k) 却仍会返回 None。</strong></p><h3 id="使用-missing-方法"><a href="posts/4f2b4bfb/#使用-missing-方法" class="headerlink" title="使用 __missing__ 方法"></a>使用 __missing__ 方法</h3><p>当我们调用 my_dict[key] 时，<strong>如果 key 是一个字符串</strong>，我们会需要用 my_dict[‘name’] 来获取，如果你觉得比较麻烦，想直接用 my_dict[name] 的话，可以采用如下方法：</p><pre><code class="python">from collections import UserDictclass StrKeyDict(UserDict):    def __missing__(self, key):        if isinstance(key, str):            raise KeyError(key)        return self[str(key)]    def __contains__(self, key):        return str(key) in self.data    def __setitem__(self, key, item):        self.data[str(key)] = itemd = StrKetDict([(&#39;1&#39;, &#39;one&#39;), (&#39;2&#39;, &#39;two&#39;)])&gt;&gt;&gt; d[2]&#39;two&#39;</code></pre><h3 id="使用-getattr-方法（不推荐）"><a href="posts/4f2b4bfb/#使用-getattr-方法（不推荐）" class="headerlink" title="使用 __getattr__ 方法（不推荐）"></a>使用 __getattr__ 方法（不推荐）</h3><p>有时我们可能更懒，想要用类属性类似的 my_dict.name 方法来获取 value，这时，可以使用 __getattr__ 方法：</p><pre><code class="python">from collections import UserDictclass AttrDict(UserDict):    def __getattr__(self, attr):        return self[attr]d = AttrDict([(&#39;name&#39;, &#39;wincer&#39;), (&#39;age&#39;, &#39;20&#39;)])&gt;&gt;&gt; d.name&#39;wincer&#39;</code></pre><p>并不推荐这样做，因为在 dict 实现中，并没有要求 key 一定为合法标识符，只需要是可散列对象即可，而上面的写法一旦 key 不为合法标识符，会 raise 一个 SyntaxError：</p><pre><code class="python">d.update({(0): &#39;zero&#39;})&gt;&gt;&gt; d[(0)]&#39;zero&#39;&gt;&gt;&gt; d.0SyntaxError: invalid syntax</code></pre><p>如果非常想使用 . 来获取 value 的话，建议使用 namedtuple</p><p>当然这也就意味着必须使用合法标识符了：</p><pre><code class="python">from collections import namedtupleID = namedtuple(&#39;ID&#39;, &#39;name age&#39;)me = ID(&#39;wincer&#39;, 20)&gt;&gt;&gt; me.name&#39;wincer&#39;ID = namedtuple(&#39;ID&#39;, &#39;(1, 0) age&#39;)ValueError: Type names and field names must be valid identifiers: &#39;(1&#39;</code></pre><h3 id="实现-switch-…-case-结构"><a href="posts/4f2b4bfb/#实现-switch-…-case-结构" class="headerlink" title="实现 switch … case 结构"></a>实现 switch … case 结构</h3><p>同样借助键查询，可以实现 Python 中没有的 switch … case 结构：</p><pre><code class="python">def foo(x):    data = {        0: &#39;zero&#39;,        1: &#39;one&#39;,        2: &#39;two&#39;,    }    return data.get(x, None)</code></pre><p>所以说 Python 不设计 switch … case 语句是有原因的，看上面的实现，比 switch … case 不知道高到哪里去了。</p><h2 id="dict-和它的小伙伴们"><a href="posts/4f2b4bfb/#dict-和它的小伙伴们" class="headerlink" title="dict 和它的小伙伴们"></a>dict 和它的小伙伴们</h2><h3 id="OrderedDict"><a href="posts/4f2b4bfb/#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>在添加键的时候会按顺序添加，同时 .popitem 是会删除并返回字典的最后一个元素而不是像 dict 里面一样可能会删除任意元素。</p><h3 id="Counter"><a href="posts/4f2b4bfb/#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>这个映射会给键一个计数器，每次更新键时都会增加这个计时器，所以这个类型可以用以给可迭代类型计数：</p><pre><code class="python">from collections import Counterct = Counter(&#39;hfkjahfkakhf&#39;)&gt;&gt;&gt; ctCounter({&#39;a&#39;: 2, &#39;f&#39;: 3, &#39;h&#39;: 3, &#39;j&#39;: 1, &#39;k&#39;: 3})ct.update(&#39;fdjlahkla&#39;)&gt;&gt;&gt; ctCounter({&#39;a&#39;: 4, &#39;d&#39;: 1, &#39;f&#39;: 4, &#39;h&#39;: 4, &#39;j&#39;: 2, &#39;k&#39;: 4, &#39;l&#39;: 2})&gt;&gt;&gt; ct.most_common(2)[(&#39;h&#39;, 4), (&#39;f&#39;, 4)]</code></pre><h3 id="UserDict"><a href="posts/4f2b4bfb/#UserDict" class="headerlink" title="UserDict"></a>UserDict</h3><p>用法见键查询。</p><h3 id="不可变映射"><a href="posts/4f2b4bfb/#不可变映射" class="headerlink" title="不可变映射"></a>不可变映射</h3><p>在 Python 3.3 后的版本，types 模块引入一个名为 MappingProxyType 的类。如果给这个类一个映射，它会返回一个只读的映射视图。但它是动态的，如果原映射改动，那么它也会相应改动。</p><pre><code class="python">&gt;&gt;&gt; int.__dict__mappingproxy({&#39;__abs__&#39;: &lt;slot wrapper &#39;__abs__&#39; of &#39;int&#39; objects&gt;,              &#39;__add__&#39;: &lt;slot wrapper &#39;__add__&#39; of &#39;int&#39; objects&gt;,              ...})from types import MappingProxyTyped = {1: &#39;A&#39;}d_proxy = MappingProxyType(d)&gt;&gt;&gt; d_proxy[2] = &#39;x&#39;TypeError: &#39;mappingproxy&#39; object does not support item assignmentd[2] = &#39;B&#39;&gt;&gt;&gt; d_proxy[2]&#39;B&#39;</code></pre>]]></content>
    
    <summary type="html">
    
      对于字典这一基础的数据结构来说，其对 Python 程序的重要性是无可替代的，在《代码之美》一书中，作者是这么描述的：字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到它。——A.M.Kuchling
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="Python" scheme="https://blog.itswincer.com/tags/Python/"/>
    
      <category term="字典" scheme="https://blog.itswincer.com/tags/%E5%AD%97%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>《代码整洁之道》读书笔记</title>
    <link href="https://blog.itswincer.com/posts/65e48179/"/>
    <id>https://blog.itswincer.com/posts/65e48179/</id>
    <published>2018-04-19T18:11:12.000Z</published>
    <updated>2018-04-19T20:34:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>相对于任何宏伟愿景，对细节的关注甚至是更为关键的专业性基础。首先，开发者通过小型实践获得可用于大型实践的技能和信用度。其次，宏大建筑中最细小的部分，比如关不紧的门、有点儿没铺平的地板，甚至是凌乱的桌面，都会将整个大局的魅力毁灭殆尽。这就是整洁代码之所系。</p></blockquote><a id="more"></a><p>本书「序」中的这段话完美的诠释了作者写本书的意义。（简评在最后）</p><h2 id="序"><a href="posts/65e48179/#序" class="headerlink" title="序"></a>序</h2><ol><li>神在细节之中。</li><li>5S 哲学包括以下概念：<ul><li>整理（Seiri）</li><li>整顿（Seiton）</li><li>清楚（Seiso）</li><li>清洁（Seiketsu）</li><li>身美（Shitsuke）</li></ul></li></ol><h2 id="整洁代码"><a href="posts/65e48179/#整洁代码" class="headerlink" title="整洁代码"></a>整洁代码</h2><ol><li><p>有人也许以为，关于代码的书有点落后于时代——代码不再是问题：我们应当关注模型和需求。……扯淡！我们永远抛不掉代码，因为代码呈现了需求的细节。在某些层面上，这些细节无法被忽略或抽象，必须明确之。将需求明确到机器可以执行的细节程度，就是编程要做的事。而这种规约正是<strong>代码</strong>。</p></li><li><p>勒布朗（LeBlanc）法则：<strong>稍后等于永不</strong>（Later equals never）。</p></li><li><p>多数人都知道一幅画是好还是坏。但能分辨优劣并不表示懂得绘画。能分辨整洁代码和肮脏代码，也不意味着会写整洁代码！</p></li><li><p><strong>Bjarne Stroustrup（C++ 语言发明者）</strong>：我喜欢优雅和高效的代码。代码逻辑应当直截了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省得引诱别人做没规矩的优化，高处一堆混乱来，整洁的代码只做好一件事。</p></li><li><p><strong>Grady Booch（《面向对象分析与设计》作者）</strong>：整洁的代码简单直接。整洁的代码如同优美的散文。整洁的代码从不隐藏设计者的意图，充满了干净利落的抽象和直截了当的控制语句。</p></li><li><p><strong>Ron Jeffries（《极限编程实施》作者）</strong>：简单代码，依其重要顺序：</p><ul><li>能通过所有测试；</li><li>没有重复代码；</li><li>体现系统中的全部设计理念；</li><li>包括尽量少的实体，比如类、方法、函数等。</li></ul></li><li><p><strong>Ward Cunningham（Wiki 发明者）</strong>：如果每个例程都让你感到深合己意，那就是整洁代码。如果代码让编程语言看起来像是专为解决那个问题而存在，就可以称之为漂亮的代码。</p></li><li><p>光把代码写好可不够。必须时时保持代码整洁。</p></li></ol><h2 id="有意义的命名"><a href="posts/65e48179/#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h2><ol><li><p><strong>名副其实</strong>：变量、函数或类的名称应该已经答复了所有的大问题。它该告诉你，它为什么会存在，它做什么事，应该怎么用。</p></li><li><p><strong>避免误导</strong>：应当避免使用与本意相悖的词。别用 accountList 来指称一组账号，除非它真的是 List 类型。用 accountGroup 或 bunchOfAccounts，甚至 accounts 都会好一些。</p></li><li><p><strong>做有意义的区分</strong>：以数字系列命名（a1、a2，……aN）是依义命名的对立面。这样的名称纯属误导——完全没有提供正确信息；没有提供导向作者意图的线索。</p><pre><code class="java">public static void copyChars(char a1[], char a2[]) {    for (int i = 0; i &lt; a1.length; i++) {        a2[i] = a1[i];    }}</code></pre><p>如果参数名改为 source 和 destination，这个函数就会像样许多。</p></li><li><p><strong>使用读得出来的名称</strong>：</p><pre><code class="java">private Date genymdhms; // 生成日期，年、月、日、时、分、秒private Date generationTimestamp;</code></pre></li><li><p><strong>使用可搜索的名称</strong>：窃以为单字母名称<strong>仅</strong>用于短方法中的本地变量。名称长短应于其作用域大小相对应。</p></li><li><p><strong>避免思维映射</strong>：不应当让读者在脑中把你的名称翻译为他们熟知的名称。</p></li><li><p><strong>类名</strong>：类名和对象名应该是名词或名词短语，如 Customer、WikiPage。避免使用 Manager、Data 这样的类名。</p></li><li><p><strong>方法名</strong>：方法名应当是动词或动词短语，如 postPayment、deletePage 或 save。</p></li><li><p><strong>每个概念对应一个词</strong>：给每个抽象概念选一个词，并且一以贯之。</p></li><li><p><strong>别用双关语</strong>：避免将同一单词用于不同目的。</p></li></ol><h2 id="函数"><a href="posts/65e48179/#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p>函数的第一规则是要短小。第二条规则是还要更短小。</p></li><li><p>函数应该做一件事。做好这件事。只做这一件事。</p></li><li><p>别害怕长名称。长而具有描述性的名称，要比短而令人费解的名称好。长而具有描述性的名称，要比描述性的长注释好。</p></li><li><p>最理想的参数数量是零（零参数函数），其次是一（单参数函数），再次是二（双参数函数），应尽量避免三（三参数函数）。如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了。</p></li><li><p>函数要么做什么事，要么回答什么事，但二者不可兼得。函数应该修改某对象的状态，或是返回该对象的有关信息。</p></li><li><p>重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。</p></li><li><p>我写函数时，一开始都冗长而复杂。有太多缩进和嵌套循环。然后我打磨这些代码，分解函数、修改名称、消除重复。我缩短和重新安置方法。有时我还拆散类。</p></li><li><p>大师级程序员把系统当作故事来讲，而不是当作程序来写。他们使用选定编程语言提供的工具构建一种更为丰富且更具表达力的语言，用来讲那个故事。</p></li></ol><h2 id="注释"><a href="posts/65e48179/#注释" class="headerlink" title="注释"></a>注释</h2><ol><li><strong>Brian W. Kernighan 与 P. J. Plaugher</strong>：别给糟糕的代码加注释——重新写吧。</li><li>注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。注意，我用了「失败」一词。我是说真的。注释总是一种失败。我为什么要极力遍地注释？因为注释会撒谎。</li><li><strong>好注释</strong>：<ol><li>法律信息</li><li>提供信息的注释</li><li>对意图的解释</li><li>阐释</li><li>警示</li><li>TODO</li></ol></li></ol><h2 id="格式"><a href="posts/65e48179/#格式" class="headerlink" title="格式"></a>格式</h2><ol><li>你今天编写的功能，极有可能在下一版本中被修改，但代码的可读性却会对以后可能发生的修改行为产生深远影响。</li><li><strong>垂直格式</strong>：<ol><li>关系密切的概念应该相互靠近。</li><li>变量声明应尽可能靠近其使用位置。</li><li>实体变量应该在类的顶部声明。</li><li>若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽肯能放在被调用者上面。</li></ol></li><li><strong>横向格式</strong>：<ol><li>应该尽量保持代码行短小。死守 80 个字符上限有点僵化，至多在 100 或 120 个字符。</li><li>赋值操作符周围加上空格字符，以此加上强调目的。</li><li>不在函数名和左圆括号之间加空格。</li><li>源文件是一种继承结构，而不是一种大纲结构。类中的方法相对该类缩进一个层级。方法的实现相对方法声明缩进一个层级。</li></ol></li></ol><h2 id="对象和数据结构"><a href="posts/65e48179/#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><ol><li><p>过程式代码便于在不该动既有数据结构的前提下添加新函数。面向对象代码便于在不改动既有函数的前提下添加新类。</p></li><li><p>得墨忒耳率认为，类 C 的方法 f 只应该调用以下对象的方法：</p><ul><li>C</li><li>由 f 创建的对象；</li><li>作为参数传递给 f 的对象；</li><li>由 C 的实体变量持有的对象。</li></ul><p>方法不应调用由任何函数返回的对象的方法。换言之，只跟朋友谈话，不与陌生人谈话。</p></li><li><p>对象曝露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。数据结构曝露数据，没有明显的行为。便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。</p></li></ol><h2 id="错误处理"><a href="posts/65e48179/#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol><li>错误处理很重要，<strong>但如果它搞乱了代码逻辑，就是错误的做法</strong>。</li><li>在某种意义上，try 代码块就像是事务。catch 代码块将程序维持在一种状态，无论 try 代码块中发生了什么均如此，所以，在编写可能抛出异常的代码时，最好先写出 try-catch-finally 语句。</li><li>你抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所。</li><li>对异常可以依据其来源分类：是来自组件还是其他地方？或依其类型分类：是设备错误、网络错误还是编程错误？不过，当我们在应用程序中定义异常类时，最重要的考虑应该是<strong>它们如何被捕获</strong>。</li><li>返回 null 值，基本上是在给自己增加工作量，也是在给调用者添乱。只要有一处没检查 null 值，应用程序就会失控。在方法中返回 null 值是糟糕的做法，但将 null 值传递给其他方法就更糟糕了。</li></ol><h2 id="边界"><a href="posts/65e48179/#边界" class="headerlink" title="边界"></a>边界</h2><ol><li><strong>学习性测试</strong>（learning tests）：不要在生产代码中试验新东西，而是编写测试来遍览和理解第三方代码</li><li>使用尚不存在的代码，将尚未开发完毕的 API 从中隔离出来。自己通过使用符合应用程序的接口，一旦 API 被定义出来，再将二者对接。</li><li>通过代码中少数几处引用第三方边界接口的位置来管理第三方边界。</li></ol><h2 id="单元测试"><a href="posts/65e48179/#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol><li>TDD 三定律：<ol><li>在编写不能通过的单元测试前，不可编写生产代码。</li><li>只可编写刚好无法通过的单元测试，不能编译也不算通过。</li><li>只可编写刚好足以通过当前失败测试的生产代码。</li></ol></li><li>脏测试等同于——如果不是坏于的话——没测试。</li><li>测试代码和生产代码一样重要。它可不是二等公民。它需要被思考、被设计和被照料。它该像生产代码一般保持整洁。</li><li>整洁的测试有什么要素？有三个要素：可读性、可读性和可读性。</li><li>整洁的测试遵循以下 5 条规则：<ol><li><strong>快速（Fast）</strong>：测试应该够快。</li><li><strong>独立（Independent）</strong>：测试应该相互独立。</li><li><strong>可重复（Repeatable）</strong>：测试应当可在任何环境中重复通过。</li><li><strong>自足验证（Self-Validating）</strong>：测试应该有布尔值输出。</li><li><strong>及时（Timely）</strong>：测试应及时编写。</li></ol></li></ol><h2 id="类"><a href="posts/65e48179/#类" class="headerlink" title="类"></a>类</h2><ol><li>类的第一条规则是类应该短小。第二条规则是还要更短小。</li><li>单一权责原则（SRP）认为，类或模块应有且只有一条加以修改的理由。</li><li>系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。</li><li>通常而言，方法操作的变量越多，就越黏聚到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。</li><li>开放-闭合原则（OCP）：类应当对扩展开放，对修改封闭。</li><li>依赖倒置原则（DIP）：类应当依赖于抽象而不是依赖于具体细节。</li></ol><h2 id="系统"><a href="posts/65e48179/#系统" class="headerlink" title="系统"></a>系统</h2><ol><li>软件系统应将启始过程和启始过程之后的运行时逻辑分离开，在启始过程中构建应用对象，也会存在相互缠结的以来关系。</li><li>可以使用抽象工厂模式让应用自行控制何时创建对象，但构造的细节却隔离于应用程序代码之外。</li><li>依赖注入（Dependency Injection）：对象不应负责实体化对自身的依赖。反之，它应当将这份权移交给其他「有权力」的机制，从而实现控制的反转。</li><li>我们应该只去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事。这就是迭代和增量敏捷的精髓所在。</li><li>面向方面编程（aspect-oriented）：被称为方面的模块构造指明了系统中哪些点的行为会以某种一致的方式被修改，从而支持某种特定的场景。</li></ol><h2 id="迭进"><a href="posts/65e48179/#迭进" class="headerlink" title="迭进"></a>迭进</h2><ol><li>简单设计规则 1：运行所有测试：遵循有关编写测试并持续运行测试的简单、明确的规则，系统就会更贴近 OO 低耦合度、高内聚度的目标。</li><li>简单设计规则 2：重构：在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称等。</li><li>不可重复：「小规模复用」可大量降低系统复杂性。</li><li>表达力：做到有表达力的最重要方式却是尝试。</li><li>尽可能少的类和方法。</li></ol><h2 id="并发编程"><a href="posts/65e48179/#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><table><thead><tr><th>名词</th><th>基础定义</th></tr></thead><tbody><tr><td>限定资源</td><td>并发环境中有着固定尺寸或数量的资源。例如数据库连接和固定尺寸读/写缓存等</td></tr><tr><td>互斥</td><td>每一时刻仅有一个线程能访问共享数据或共享资源</td></tr><tr><td>线程饥饿</td><td>一个或一组线程互相等待执行结束。</td></tr><tr><td>死锁</td><td>两个或多个线程互相等待执行结束。</td></tr><tr><td>活锁</td><td>执行次序一致的线程，每个都想要起步，但发现其他线程已经「在路上」。</td></tr></tbody></table><ol><li><p>对象是过程的抽象。线程是调度的抽象。</p></li><li><p>并发是一种解耦策略。它帮助我们把做什么（目的）和何时（时机）做分解开。</p></li><li><p>并发软件的中肯说法：</p><ul><li>并发会在性能和编写额外代码上增加一些开销；</li><li>正确的并发是复杂的，即便对于简单的问题也是如此；</li><li>并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待；</li><li>并发常常需要对设计策略的根本性修改。</li></ul></li><li><p>生产者-消费者模型：一个或多个生产者线程创建某些工作，并置于缓存或者队列中。一个或者多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。</p></li><li><p>读者-作者模型：当存在一个主要为读者线程提供信息源，但只是偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。协调读者线程不去读取正在更新的信息，而作者线程倾向于长期锁定读者线程。</p></li><li><p>宴席哲学家：许多企业级应用中会存在进程竞争资源的情形，如果没有用心设计，这种竞争会遭遇死锁，活锁，吞吐量和效率低等问题。</p></li></ol><p>本书后几章主要侧重于讲解 Java 代码的一些例子，对其它语言帮助不大，在这里就不做整理了。</p><hr><p>正如我在<a href="../a6c2a51d/">上一篇读书笔记</a>中所说的：每一本中都会充斥着许多作者的自己的观点、看法，而唯有价值观相符合或相接近的人才会觉得本书写得很不错，上一本《黑客与画家》是，这本《代码整洁之道》也是，你可能很难认为变量的命名需要有那么考究，函数的长短有那么重要，心里想着程序能运行就没事，甚至连 WARNING 都忽视掉，这类人想必并不是本书的目标群体。而本书的目标群体在开头已经注明了：你想成为一个更好的程序员。其实我觉得目标群体还可以加上一小撮人：有强迫症的程序员——比如我。</p><p>我曾经看自己四个月前的代码能羞愧得钻进地里，心想着怎么能写出这么烂的<a href="https://gist.github.com/WincerChan/362331456a6e0417c5aa1cf3ff7be2b7/revisions" target="_blank" rel="noopener">代码</a>。这四个月固然有我对该门语言较高层级的数据结构更加熟悉，能更熟练的操作它们，但更多的是编程观念的改变：需要用心来写代码，不要简单敷衍了事，不要认为程序只要能运行就算成功。程序毕竟还是写给人看的，就算不是为了别人，看着意义明确的变量，缩进优美的段落，结构分明的函数，想必自己心里也会很舒畅的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;相对于任何宏伟愿景，对细节的关注甚至是更为关键的专业性基础。首先，开发者通过小型实践获得可用于大型实践的技能和信用度。其次，宏大建筑中最细小的部分，比如关不紧的门、有点儿没铺平的地板，甚至是凌乱的桌面，都会将整个大局的魅力毁灭殆尽。这就是整洁代码之所系。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="文字阁" scheme="https://blog.itswincer.com/categories/%E6%96%87%E5%AD%97%E9%98%81/"/>
    
    
      <category term="笔记" scheme="https://blog.itswincer.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码" scheme="https://blog.itswincer.com/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Nextcloud 搭建私人云服务教程</title>
    <link href="https://blog.itswincer.com/posts/bf0413ac/"/>
    <id>https://blog.itswincer.com/posts/bf0413ac/</id>
    <published>2018-03-31T15:03:31.000Z</published>
    <updated>2018-04-01T19:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>我一直很不相信国内的那些云服务提供商（尤其是在李彦宏发表的讲话「中国用户对隐私问题没那么敏感，在个人隐私方面更加开放，一定程度上愿用隐私换方便和效率」后），因为怕隐私得不到保障，故而我的一些隐私数据都是存放在国外的云盘（如 Dropbox、Drive 等）上。<a id="more"></a></p><p>可这俩在国内都被墙了，而手机翻墙总是显得有些不够方便，与是我就琢磨着自己搭建一个云服务，随后就发现了 Nextcloud 这一开源云服务。而网上的教程都太过复杂了，对新手太过不友好，于是乎——一篇近乎傻瓜式的 Nextcloud 教程诞生了。</p><h2 id="安装"><a href="posts/bf0413ac/#安装" class="headerlink" title="安装"></a>安装</h2><p>这里采用 Docker 容器方式来安装 Nextcloud，这样就不用担心各种环境依赖了（Nextcloud 的依赖简直多得吓人，而 Dockerfile 会帮你把依赖都配置好）</p><h3 id="安装-Docker"><a href="posts/bf0413ac/#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><blockquote><p>注：Docker 仅支持 64-bit 的系统</p></blockquote><p>Docker 现已被各大发行版的仓库收入，采用正常安装命令即可：</p><pre><code class="bash">yum -y install docker</code></pre><p>随后，启动 Docker 守护进程：</p><pre><code class="bash"># systemctlsystemctl start docker# Serviceservice docker start</code></pre><h3 id="安装-NextCloud"><a href="posts/bf0413ac/#安装-NextCloud" class="headerlink" title="安装 NextCloud"></a>安装 NextCloud</h3><h4 id="自动安装"><a href="posts/bf0413ac/#自动安装" class="headerlink" title="自动安装"></a>自动安装</h4><p>有了 Docker 后，就可以几行代码安装 Nextcloud 了：</p><pre><code class="bash"># clone nextcloud 的 docker 容器git clone https://github.com/nextcloud/docker.git# 耐心等待安装docker run -d -p 8080:80 nextcloud </code></pre><p>安装完成后先别忙着启动，<code>docker ps -a -q</code> 查看一下容器的 id，是一串 12 位的字符串，为了便于记忆，重命名一下：</p><pre><code class="bash">docker rename ××× nextcloud     # ××× 即为容器 id</code></pre><p>随后就可以采用如下命令启动了：</p><pre><code class="bash">docker start nextcloud# 测试curl http://localhost:8080</code></pre><p>这样，就完成了 Nextcloud 的安装工作。</p><h4 id="手动安装"><a href="posts/bf0413ac/#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>方法一只能安装最新版的 Nextcloud，而最新版缺少部分功能，如：无法添加 Drive 和 Dropbox 的外置存储。如果你对外置存储不是很 care 的话，那就按照方法一安装就可以了。</p><pre><code class="bash">git clone https://github.com/nextcloud/docker.gitcd docker/12.0/apache</code></pre><p>这里采用官方编写的 Dockerfile 手动构建，所以时间会花得比较久。</p><pre><code class="bash">docker build -t nextcloud .</code></pre><p>这时候用 <code>docker images</code> 应该可以看到刚刚创建的镜像了，随后创建容器：</p><pre><code class="bash">docker create -v /var/www/html/apps/:/var/www/html/apps -v /var/www/html/config/:/var/www/html/config -v /var/www/html/data/:/var/www/html/data -p 127.0.0.1:8080:80/tcp --name nextcloud nextcloud</code></pre><p>稍稍解释一下参数：</p><ul><li>-v 后面是地址，前半部分是 VPS 的地址，后半部分是容器内的地址</li><li>-p 后面是端口号</li><li>–name 后面是容器名称</li><li>最后的 nextcloud 是镜像名称</li></ul><h2 id="配置"><a href="posts/bf0413ac/#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Nginx-配置"><a href="posts/bf0413ac/#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h3><p>由于 NextCloud 已经占用了 8080 端口，这里采用 Nginx 做反向代理，将域名直接解析至 8080 端口。</p><pre><code class="nginx">server {  listen 80;  server_name cloud.example.com;  location / {    proxy_pass http://localhost:8080;  }}</code></pre><p>重启 Nginx 服务后，就可以通过 cloud.example.com 来访问云服务了。</p><h3 id="NextCloud-配置"><a href="posts/bf0413ac/#NextCloud-配置" class="headerlink" title="NextCloud 配置"></a>NextCloud 配置</h3><pre><code class="bash"># 进入容器内的 bashdocker exec -i -t nextcloud bash</code></pre><h4 id="重定向-overwritehost"><a href="posts/bf0413ac/#重定向-overwritehost" class="headerlink" title="重定向 overwritehost"></a>重定向 overwritehost</h4><p>有时候 NextCloud 会自己定向至本地的 8080 端口，所以需要手动重写正确的地址：如果提示不能定位软件包，先执行 <code>apt-get update</code>。</p><pre><code class="bash">vim config/config.php# 加上下面这行&#39;overwritehost&#39; =&gt; &#39;cloud.example.com&#39;,</code></pre><p>重启，让配置生效：</p><pre><code class="bash">docker restart nextcloud</code></pre><h3 id="MySQL-配置"><a href="posts/bf0413ac/#MySQL-配置" class="headerlink" title="MySQL 配置"></a>MySQL 配置</h3><p><del>由于我 VPS 的内存比较小，所以并没有启用 MySQL/MariaDB 数据库（怕爆内存），而是采用了 SQLite，反正也是我一个人用，问题不大。</del></p><p>开启了 MySQL 后发现内存也就多了 20M（但性能的提升可不是一点半点），遂还是改成 MySQL 了：</p><ol><li><p>安装 MySQL（这里采用 MariaDB 分支）</p><pre><code class="bash">yum -y install mariadb-server mariadb-client# 设置一下 root 密码等mysql_secure_installation</code></pre></li><li><p>开启 daemon 服务</p><pre><code class="bash">systemctl start mariadbsystemctl enable mariadb</code></pre></li><li><p><code>mysql -uroot -p</code> 登录 MySQL</p><pre><code class="mysql"># 创建 nextcloud 数据库CREATE DATABASE nextcloud CHARACTER SET = utf8 COLLATE = utf8_general_ci;# 创建 nextcloud 的用户CREATE USER nextcloud IDENTIFIED BY &#39;admin123&#39;;# 赋予对数据库所有的权限GRANT ALL ON nextcloud.* TO nextcloud;</code></pre></li></ol><h3 id="初始设置"><a href="posts/bf0413ac/#初始设置" class="headerlink" title="初始设置"></a>初始设置</h3><ol><li><p>打开 <a href="https://cloud.example.com" target="_blank" rel="noopener">https://cloud.example.com</a></p></li><li><p>创建管理员帐号和密码</p></li><li><p>数据库就选择 MySQL/MariaDB，其它参考下表：</p></li></ol><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center">用户名</td><td style="text-align:center">nextcloud</td></tr><tr><td style="text-align:center">密码</td><td style="text-align:center">admin123</td></tr><tr><td style="text-align:center">数据库名</td><td style="text-align:center">nextcloud</td></tr><tr><td style="text-align:center">地址</td><td style="text-align:center">172.17.0.1</td></tr></tbody></table><p><strong>注意：这里的地址千万不要填写成了 localhost 或者 172.0.0.1，因为这里的地址需要容器内与外部通信。</strong></p><p>点击完成后，等待几秒就可以使用了。</p><h2 id="挂载外部云盘"><a href="posts/bf0413ac/#挂载外部云盘" class="headerlink" title="挂载外部云盘"></a>挂载外部云盘</h2><p>由于我 VPS 的容量只有 10g，故而放不了过多的视频，就考虑采用外部存储的方法，将 Drive、Dropbox 挂载至 Nextcloud 外部存储或者 VPS。</p><blockquote><p>注：Nextcloud 13 已经取消对 Drive、Dropbox 外部存储的支持（这时候你也可以选择把 Drive 直接挂载至 VPS 本地目录，再通过外部存储链接至挂载目录来完成）。</p></blockquote><h3 id="启用外部存储插件"><a href="posts/bf0413ac/#启用外部存储插件" class="headerlink" title="启用外部存储插件"></a>启用外部存储插件</h3><p>在应用页面，启用 <code>External storage support</code> 插件：如果提示：「没有安装 “smbclient”无法挂载 “SMB / CIFS”, “SMB / CIFS 使用 OC 登录信息”. 请联系您的系统管理员安装」</p><p>解决办法：</p><h3 id="安装-smbclient"><a href="posts/bf0413ac/#安装-smbclient" class="headerlink" title="安装 smbclient"></a>安装 smbclient</h3><pre><code class="bash"># 进入容器的内的 consoledocker exec -i -t nextcloud bashapt-get install libsmbclient-dev</code></pre><p>这里简单说一下，不管你的 VPS 原本的系统是 CentOS、RedHat、Debian，统一都用 apt-get 安装，因为现在处于的是 docker 容器内的系统，与 VPS 的系统是分离的。</p><p>接着再安装 smbclient：</p><pre><code class="bash">pecl install smbclient</code></pre><p>同时会提示：「You should add “extension=smbclient.so” to php.ini」，这里又被小坑一把，网上大部分教程所说的 <code>/etc/php.d/php.ini</code> 并不存在，在 docker 容器内部该文件是在：</p><pre><code class="bash">vim /usr/local/etc/php/conf.d/docker-php-ext-intl.ini# 加上下面这行extension=smbclient.so</code></pre><p>随后重启 Nextcloud 服务就应该就 OK 了。</p><p>随后如果你安装的 Nextcloud 是 13 版本及以上的话，就只有考虑用 <a href="https://www.box.com/" target="_blank" rel="noopener">box</a> 提供的 <a href="https://community.box.com/t5/Upload-and-Download-Files-and/WebDav-with-Box/ta-p/310" target="_blank" rel="noopener">WebDAV</a> 来作为外置存储了，不过只有 10G 的容量，且最大文件限制是 250MB。如果是用的 12 版本及以下的话，就可以考虑采取 Drive 作为外置存储了：</p><h3 id="获取-API"><a href="posts/bf0413ac/#获取-API" class="headerlink" title="获取 API"></a>获取 API</h3><ol><li><p>访问 <a href="https://www.orgleaf.com/go.php?url=https://console.developers.google.com" target="_blank" rel="noopener">Google 开发者平台</a>：</p></li><li><p>点击「启用 API 和服务」</p></li><li><p>点击「Google Drive API」</p></li><li><p>点击「启用」</p></li><li><p>点击左侧的凭据 -&gt; OAuth 同意屏幕：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1F7e1KkKWBuNjy1zj763OypXaf.png" alt="oauth 示例"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">oauth 示例</figure></p><p>按照以上格式填写，点击保存</p></li><li><p>随后创建凭据：</p><p>应用类型选择<strong>网页应用</strong>，其它的参考以下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1mgtydi6guuRjy0Fm7610DXXan.png" alt="url 配置"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">url 配置</figure></p><p>点击创建后，会弹出悬浮框告诉你 ID 和 Key。</p></li></ol><h3 id="配置-Nextcloud"><a href="posts/bf0413ac/#配置-Nextcloud" class="headerlink" title="配置 Nextcloud"></a>配置 Nextcloud</h3><p>登录 Nextcloud，转至管理页面，点击「外部存储」，选择 Google Drive，填入 API 和 Key，点击授权，若授权时出现 400 错误，那么是重定向的 URI 出问题了，再添加如下一条：</p><pre><code>https://cloud.example.com/index.php/settings/admin/externalstorages</code></pre><p>如果提示「此应用未经过验证」，点击高级 -&gt; 转至 example.com，忽略掉就行。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1OjWeKXmWBuNjSspd762ugXXaE.png" alt="外置存储"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">外置存储</figure></p><p>当出现了绿色按钮，就表示配置成功了。</p><p>参考：</p><ul><li><a href="https://github.com/nextcloud/docker#how-to-use-this-image" target="_blank" rel="noopener">Docker image of Nextcloud</a></li><li><a href="https://oing9179.github.io/blog/2017/03/Setup-Nextcloud-using-Docker-and-Nginx/" target="_blank" rel="noopener">用 Docker 和 Nginx 搭建自己的云服务器（Nextcloud）</a></li><li><a href="https://www.orgleaf.com/903.html" target="_blank" rel="noopener">连接 Google Drive 教程</a></li><li><a href="https://www.brilliantcode.net/486/freenas-10-nextcloud-use-smb-as-external-storage/" target="_blank" rel="noopener">FreeNAS 10 NextCloud 開啟外部儲存媒體的 SMB 功能</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我一直很不相信国内的那些云服务提供商（尤其是在李彦宏发表的讲话「中国用户对隐私问题没那么敏感，在个人隐私方面更加开放，一定程度上愿用隐私换方便和效率」后），因为怕隐私得不到保障，故而我的一些隐私数据都是存放在国外的云盘（如 Dropbox、Drive 等）上。
    
    </summary>
    
      <category term="分享境" scheme="https://blog.itswincer.com/categories/%E5%88%86%E4%BA%AB%E5%A2%83/"/>
    
    
      <category term="VPS" scheme="https://blog.itswincer.com/tags/VPS/"/>
    
      <category term="云服务" scheme="https://blog.itswincer.com/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="NextCloud" scheme="https://blog.itswincer.com/tags/NextCloud/"/>
    
  </entry>
  
</feed>
