<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记一次反向代理的搭建</title>
      <link href="/posts/1352252a/"/>
      <url>/posts/1352252a/</url>
      
        <content type="html"><![CDATA[<p>最近和朋友聊天时，他说发现了一个云计算服务商：「<a href="https://zeit.co" target="_blank" rel="noopener">ZEIT</a>」，可以为程序免费提供托管，想问问我有没有什么好的想法。我查看了一下发现这货在全球提供的线路还真不少（亚洲大部分地区都有），用作代理软件想必体验会比较不错。</p><p>于是我首先想到搭建 ShadowSocks、V2Ray 这类代理软件，不过很可惜 ZEIT 在部署上有限制：不支持 WebSocket（当然更不支持 SOCKS5 了），且虽然线路的延迟比较低，但在带宽上却有限制，于是我暂时放弃了正向代理，把注意打到了反向代理的头上。</p><a id="more"></a><p>反向代理相比正向代理的限制不少，最大限制的在于一次只能代理一个网站。想了想还是决定代理一个搜索引擎——<a href="https://www.startpage.com/" target="_blank" rel="noopener">Startpage</a>，用于手机等不那么方便翻墙的设备搜索。至于为什么选择它嘛，有两点原因：</p><ol><li>它是一个非常「干净」的搜索引擎，隐私性做得非常好，甚至没有登录功能，用户偏好也只是用 Cookie 实现；</li><li>它匿名地向 Google 提交查询，再将结果返回给用户（某种意义上来说，它也算 Google 的反向代理），所以搜索质量约等于 Google。</li></ol><p>至于为什么不选择 Google，答案也很简单，Google 会检测计算机的异常流量，一旦检测到异常，则必须通过「reCAPTCHA」检测才能继续使用。尤其是在使用反代的时候，出现检测的机率非常高，这对想迅速得到搜索引擎反馈的用户来说，无疑是一种灾难。</p><h2 id="思路"><a href="posts/1352252a/#思路" class="headerlink" title="思路"></a>思路</h2><p>反向代理的核心思路或者说原理其实很简单：中转服务器把来自客户端的请求发送给服务端，再将服务端的应答返还给客户端。单纯地实现这一功能也非常简单，使用 Golang，你甚至不需要借助第三方库便可搭建一个很简单的反向代理。</p><pre><code class="go">func Proxy(w http.ResponseWriter, r *http.Request) {    reverseURL, err := url.Parse(protocal + host)    proxy := httputil.NewSingleHostReverseProxy(reverseURL)    r.Host = host    proxy.ServeHTTP(w, r)}</code></pre><p>这几行代码就足以搞定 Google 的反向代理了，也能让你愉快地使用 DuckDuckGo 了，然而却无法使用 Startpage。</p><p>是的，可能因为「Startpage」本身就相当于对 Google 的反代，所以它对反向代理极其不友好，具体见下。</p><h2 id="薛定谔的-Bug-们"><a href="posts/1352252a/#薛定谔的-Bug-们" class="headerlink" title="薛定谔的 Bug 们"></a>薛定谔的 Bug 们</h2><h3 id="绝对路径"><a href="posts/1352252a/#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>当我运行刚刚的程序，打开浏览器并输入地址满心欢喜地看着 Startpage 的首页一点点出现时，我几乎以为已经成功了，可是当我输入关键字搜索时，打开 Firefox 的调试工具却发现它的请求资源都是从「Startpage」域名返回的。</p><p>是的，Startpage 很「聪明地」将静态文件的引用使用了绝对路径，而不是大多数网站都使用的相对路径，这意味着我还需要修改 Response Body，将原域名都替换成自己的域名，这一点倒是没什么难度（当时我是这么想的），正好 Golang 也提供了 ModifyResponse 用于 Response 的修改。</p><p>可当我代码写好了然后发现运行结果仍和原来一样时，我开始觉得有点难办了。</p><h3 id="传输编码"><a href="posts/1352252a/#传输编码" class="headerlink" title="传输编码"></a>传输编码</h3><p>造成这个问题的原因其实很明显，但我却花了半天的时间才找到：Startpage 在网页传输时启用了 GZIP 的压缩编码，因此直接替换 <code>www.startpage.com</code> 是行不通的，需要将 Response Body 解码之后再替换。</p><p>完成解码替换之后，终于如愿看到请求资源都是从本域名返回的，我又一次以为自己要成功了。可是当我点击搜索结果的下一页时，网页却久久处于加载之中，我开始觉得或许不应该选择代理「Startpage」了。</p><h3 id="域名改变"><a href="posts/1352252a/#域名改变" class="headerlink" title="域名改变"></a>域名改变</h3><p>打开 Firefox 的调试工具之后，发现它居然把第二页的域名给换成了与首页完全不同的二级域名——「www」会变成类似「s2-us8」、「s3-us6」这的前缀，而具体变成什么样是由首次搜索的时候随机返回的。</p><p>这个问题其实应该是无解的——除非你把所有出现的二级域名都进行代理（类似 YouTube 其实也是把每个视频的源文件放在不同域名的服务器上），不过很可惜，Startpage 只是单纯把域名换了，实测之后直接输入域名前缀也是可以正常使用的，因此只需要把代理的 URL 从 <code>www.startpage.com</code> 换成 <code>s3-us6.startpage.com</code> 就可以加载后几页的内容了。</p><h3 id="处理-Header"><a href="posts/1352252a/#处理-Header" class="headerlink" title="处理 Header"></a>处理 Header</h3><p>在修复了以上三个 Bug 之后，搜索功能已经很完善了，不过还有一个小问题，就是用户的偏好设置无法保存，比如自定义背景、偏好语言等，点击保存按钮会 301 重定向至 <code>www.startpage.com</code> 页面，是的，这又是「Startpage」为反向代理设置的一道关卡。（没办法，自己选的路，哭着也要走完 : ）</p><p>在修改完 301 的重定向地址后，点击保存发现虽然不会跳转到「Startpage」域名了，但是设置依然没有保存下来，一番 Debug 后发现是 Cookie 的问题，Cookie 设置的 Domain 不是同样使用的是绝对路径，「Startpage」为了不让别人反代真是煞费苦心呐！</p><p>在直接把 Cookie 的 Domian 字段干掉之后，使用起来终于和原网站无异了。</p><h2 id="总结"><a href="posts/1352252a/#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然一开始只想着反代一个搜索引擎，但中途想着还是把普适性做得更广一些，让它能代理任意的网站，因此考虑的方面也比较多，但最终的成就感还是挺爽的，自己也对 HTTP 各字段的理解更深刻了。</p><p>目前这个反向代理工具支持文本替换、重定向替换、Cookie 替换等，源码<a href="https://github.com/WincerChan/mirror" target="_blank" rel="noopener">已开源</a>在 GitHub，部署在 ZEIT 上，如果你想部署在自己的服务器上，建议使用 master 分支。</p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/13130341/reading-gzipped-http-response-in-go" target="_blank" rel="noopener">Reading gzipped HTTP response in Go</a></li><li><a href="https://spectrum.chat/zeit/now/golang-example-multi-route-multi-lambda-with-dependencies~fb35e1e2-9f29-47b2-87a2-0977775fc45c" target="_blank" rel="noopener">Golang Example: multi-route, multi-lambda with dependencies</a></li><li><a href="https://stackoverflow.com/questions/41313949/how-to-dump-a-response-of-an-http-get-request-and-write-it-in-http-responsewrite" target="_blank" rel="noopener">How to dump a response of an HTTP GET request and write it in http.ResponseWriter</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反向代理 </tag>
            
            <tag> Startpage </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的学生时代（高中篇）</title>
      <link href="/posts/5fdce618/"/>
      <url>/posts/5fdce618/</url>
      
        <content type="html"><![CDATA[<p>在临毕业的这段时间，生活似乎短暂地失去了目标，并不是丧，我也没有认为这是一件坏事——至少我可以有更多的时间思考并记录我的想法，当然更多时间我在好好地、不带任何负担地放松自己。</p><p>直到前几天 <a href="https://wakatime.com/" target="_blank" rel="noopener">WakaTime</a> 发邮件过来说已经两周时间没收到我的 Code Activity 了，问是不是插件出了什么问题：「Please <a href="https://wakatime.com/plugins" target="_blank" rel="noopener">reinstall the plugin</a> to continue using the WakaTime dashboard」。其实并不是插件出了什么问题，而是我真的两周没有编程了（笑。</p><a id="more"></a><p>休养够了，也终于意识到应该做或写点什么了：于是我开始了本文的创作。本文决定聊聊我的高中以及大学生活（其实我一直都有些畏惧谈论这个话题，原因之后会提到）。</p><h2 id="错愕"><a href="posts/5fdce618/#错愕" class="headerlink" title="错愕"></a>错愕</h2><p>从进初中开始，快班里的我们便只有一个目标——进入省重点高中，为学校赚来更好的名誉（当然也为自己的前途）。中考结束，很遗憾，我离省重点的分数线还有几分的差距，当时班上有几个和我分数差不多的人选择了市重点：学杂费全免，直接去最好的班，还有奖学金。当时的我，对于省重点和市重点没有什么明确的概念，所以还是听从家人的想法：交「择校费」，进入了省重点。</p><p>我仍然记得从初中班主任（我和他关系很不错，他曾不止一次地鼓励我，甚至在我说因为回家太晚而不想上晚自习时，提出可以每天晚上开车送我回家；在中考前，让我不用做数学卷子，把心用在其它学科上）手里接过录取通知书时，他脸上那种复杂的表情——惋惜与错愕。前者在于我最终还是没能过省重点的分数线，后者在于我居然还是上了这所学校。</p><h2 id="堕落"><a href="posts/5fdce618/#堕落" class="headerlink" title="堕落"></a>堕落</h2><p>高一上学期，还未分班，想学文的和想学理的混在一起上课，我所在的班级不巧在以后会成为文科班，一想到反正以后也会转班，那就转班后再好好学习吧！恰巧在朋友的安利下，又接触了网络小说（玄幻啊，都市啊<del>，言情啊</del>），于是一发不可收拾彻底沉迷于小说，而「转班后再好好学习」也成为了我心安理得的借口。</p><p>当时的化学老师非常照顾我（因为我第一次摸底考试化学考了并列第一名，当然是吃初中的老本），他也是最早发现我堕落的老师，因此找我谈过几次话，虽然我并没有因谈话而上进，但我仍然感激他在我陷入黑暗的时候愿意拉我一把。</p><p>在未分班时，考试排名差我也有理由搪塞：文科我不会。可到了高一下学期，便进行了预分班，我被分到了一个新的班级，预想中的「重新做人」并没有出现在我身上，反而是更加的堕落——因为我同桌也看小说。与此同时，「文科我不会」的谎言也不攻自破（虽然是预分班，但学校会针对文理科的学生单独出一份文理科目的排名）。家人以为是我沉迷手机（说实话当时也确实沉迷手机，毕竟是智能机刚兴起的时代，但不是沉迷于网络，而是沉迷于折腾手机 ROOT 之类的），于是把我的手机没收。仅留下一个 MP4，但 MP4 仍然可以看小说，于是我仍沉迷于小说。</p><p>最终，堕落的高一以我期末考试 1062 的名次（年级不到一千两百人）结尾，而我也没有和家人扯什么「其它人中考分比我高，我学不过他们」这种诛心的理由。</p><p>高二上学期，上课看小说的情况似乎并没有得到改观，反而是我在与老师斗志斗勇的过程中成长了——「发明」了一种能上课看小说而不被抓到的方法：用书在课桌的前面和右侧各摆一摞，形成一个角落，一有风吹草动就把「作案工具」塞到书下面专门预留的缝隙里。得益此「发明」，我上课看小说没有被老师抓到过一次。可惜之后效仿的同学越来越多，班主任就禁止桌面上的书摆放成这种形状了（话说我这也算是迫使别人改变规则的人了 233333）。</p><h2 id="奋起"><a href="posts/5fdce618/#奋起" class="headerlink" title="奋起"></a>奋起</h2><p>似乎很难想起当初选择从堕落的深渊里爬出来的理由（或许不是想不起，而是我自己也不知道），但终究还是选择往上爬了——我开始严格控制看小说的频率，并开始学习了。</p><p>没过多久，正巧班主任把我调换了座位，我的同桌变成了班长，前桌坐的是班上第一名，我们三人「一见如故」：感兴趣的课（数理化）会一起认真听讲，一起听数学老师讲人生道理；在另外的某些课上则会小范围地互相逗乐、互相扯淡，那段时间不仅是我高二过得最快乐的时光，也是进步最大的时候，我很感谢他俩，也开始明白为什么家人一定要送我来这所学校了。</p><p>除了他们，我还想说说老师们，尤其是数学老师。在他的课上，我学会了数学这种严禁的思考方式，以及他那近乎到自恋的自信（名言：答案和我不一样就是答案错了），兴趣来了，成绩也就水到渠成了。高二下，我数学考了全班第一——145 分，数学老师似乎开始注意到我这个默默无闻的学生了，从那之后，我像是想证明什么似的，每次数学都很尽力地考，可却再也没考上过 130，可也没低于过 110。</p><p>语文课，永远都是睡觉的课——语文老师是学佛的，也非常佛系：发现你睡觉时，便会很温柔地抚摸你的背让你不要睡觉，大部分人在被叫醒后仍然继续倒头就睡，他也不恼，继续上他的课。英语老师也非常有趣：经常在课上和我们这些成绩不太好的学生「互动」，还经常放电影给我们看，得益于她，我拾起了对英语的兴趣。</p><p>好景不长，高二下学期过了才两个月，我们三人组的欢乐时光被班主任强行结束（原因是某人告密说我们三人上课讲话影响课堂纪律），也因此，高二的我对班主任怨念颇深。</p><h2 id="荒诞"><a href="posts/5fdce618/#荒诞" class="headerlink" title="荒诞"></a>荒诞</h2><p>上了高三，学校开始要求学生要上两节晚自习（七点到八点半以及八点四十到十点），我们的班主任又要求早上六点五十就要到校，而且我还要搭公交往返，这样一来的话一天根本无法保证八个小时睡眠，于是我就让父亲和老师说我不上第二节晚自习，好在当时我的成绩稳定下来了，也有了底气提出这个要求。</p><p>虽然每天晚上比同学早一个多小时回家，但我早上仍旧无法那么早起床（尤其是冬天），迟到成为了我的家常便饭，基本高三大部分的早自习我都是被罚站在教室后面背书，最多的一次罚站了近二十人，这也算我们班独特的风景线了。</p><p>在临近高考的几个月里，我过得比之前更放松了：会在老师要求我们自习时和坐最后一排的朋友一起靠在墙上看《奔跑吧兄弟》，却又不敢笑出声；会在早自习下课的五分钟时间内和同学跑去食堂吃碗面条，然后理所应当地迟到十几分钟才进教室，并打赌班主任不会守在门口……多么美好的时光啊，美好而短暂。</p><p>高考前夕，我玩得特别好的一朋友（他成绩比我好，高三的摸底考试基本都比预估的一本分数线高四十分，而我一般高十分左右）问我：</p><p>「你要是没过一本线，会不会复读？」</p><p>「不会」，我不假思索地回答到。</p><p>「我也不会」，他透过黑框眼镜，深沉地看着我说：「除非我二本都没考上」。那是我们第一次比较正经地谈论我们的未来。</p><p>那年是湖北省高考自主命题的最后一年，出卷老师似乎拼了命想让这届高考的学生记住他一样，数学卷异常地难。导致湖北当年的一本分数线是十几年来最低，而我，也倒在了我最擅长的数学上（没考到 80 分，我现在还觉得有些对不起数学老师）。</p><p>去学校领分数条的那天，阴霾天空，我遇到了那朋友：</p><p>「考多少分啊？」，他问我。</p><p>「不好意思说」，我摇了摇头，眼睛望向地面。</p><p>「我不信你还能有我低，我四百五都没到」，我猛地抬起了头望向他，却只看到他嘴角的苦涩。那是我们第二次，无比正经地谈论我们的未来。</p><p>高中啊，以「我没过一本线，他没过二本线」这样荒诞地结束了。</p><hr><p>高中部分已完，由于大学部分需要写的东西比较多，我会另起一篇文章，敬请期待。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感想 </tag>
            
            <tag> 学生时代 </tag>
            
            <tag> 高中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奇安信（原 360 企业安全）服务端开发面经</title>
      <link href="/posts/d42e79bb/"/>
      <url>/posts/d42e79bb/</url>
      
        <content type="html"><![CDATA[<p>现在说起来我自己都不信，之前我居然一直以为秋招是为当年毕业的学生准备的，直到我们班有人签了百度，我才知道秋招原来是为次年的应届生准备的😅，不过当时已经十月，秋招已经基本结束，于是只好准备来年的春招了。</p><a id="more"></a><p>话说回来，本次春招我准备的也不算特别充分，很大一部分原因是毕业设计选题选了一个自己陌生的领域，并且还准备评优秀毕业论文，所以年后一直在准备毕设，空闲时间才会找公司投递。我对公司还是挺挑的（钱多事少离家近，起码要满足两点吧），而且还要招 Python 岗，可供选择的公司就更少了，找来找去也只投递了一家公司——奇安信（原 360 企业安全），所幸最后也拿到了 Offer。</p><p>本文是对这次招聘流程的一个总结。</p><h2 id="笔试"><a href="posts/d42e79bb/#笔试" class="headerlink" title="笔试"></a>笔试</h2><p>我是三月底投递的简历，四月中旬发来的笔试通知。有两道编程题，一道非递减数列（AC 67%，这题 Python3 的输入格式有问题），一道实现哈希表（AC 91%，同上，Python3 输入仍然有问题），这两题难度均介于 Leetcode 的 Easy 和 Medium 之间。</p><p>由于两道编程题都没 100% AC，我以为凉了，结果在 4 月 23 日晚上十一点发来面试通知，通知我 25 号下午面试，当时就有点慌，面试时间太近，只有一天时间准备（24 号上午还要去看复联 4 首映，本来想不去了，后来想想首映一辈子就这一次😅），于是看完电影赶紧把数据库和操作系统还有计算机网络复习了一下。</p><h2 id="一面（30-分钟）"><a href="posts/d42e79bb/#一面（30-分钟）" class="headerlink" title="一面（30 分钟）"></a>一面（30 分钟）</h2><p>等了小半个钟，面试官才姗姗来迟（可能是因为面试的太多了），面试官是一个中年微胖的大叔：</p><ol><li>先做个自我介绍吧</li><li>元组和字典的区别（我当时以为我听错了，心想这俩完全没一点相似的啊）</li><li>Node.js 的特性，与 Python 的区别（这一点应该是看我简历上有写）</li><li>Python2 和 Python3 的区别</li><li>Python2 和 Python3 在多线程有什么区别（我当时想了一下，觉得好像没区别，就说 Python2 多线程不太了解）</li><li>说说多线程的锁</li><li>多进程有什么用</li><li>说说函数式编程的特性</li><li>框架了解吗，说说 Django 和 Flask</li><li>Django 的一次请求流程</li><li>Django 里用了哪些标准库（好奇怪的问题😳）</li><li>写一个 Python 的注解（我以为他问的是 Type Hints，后来意识到可能说的是装饰器，就把装饰器的概念说了一遍，问他具体是哪一个，结果他也说不清楚，说自己好久没接触 Python 了，于是这个问题就过了）</li><li>Numpy 了解吗？Numpy 里新增了什么类型？为什么 Numpy 效率高？</li><li>Elasticsearch 用过吗，说说分片（我当时已经很久没用 ES 了，有些基础概念忘掉了，就说我只知道分桶，不清楚分片）</li><li>算法了解吗？说说堆排序和快排（不知道堆排序，就说了一下快排）</li><li>手撕代码——单链表赋值（还比较简单）</li><li>Python 和 C 的区别</li><li>有什么想问我的（这里我作了一个小死，问了一下面试官觉得我怎么样？回答是思维比较发散、活跃，也比较喜欢钻研新东西，但对某些东西背后的原理挖掘不够深入，总体来说算挺不错了😉）</li></ol><p>与我想象中的面试还是有很大的区别，计算机网络一点没问，操作系统一点没问，数据库一点没问（让我一天的复习付诸流水😅），总体来说都是按照简历来发问，很 Nice 的体验。</p><p>几分钟后收到二面的短信。</p><h2 id="二面（18-分钟）"><a href="posts/d42e79bb/#二面（18-分钟）" class="headerlink" title="二面（18 分钟）"></a>二面（18 分钟）</h2><p>也等了小半个钟，二面面试官应该是小组或者部门的 Leader 了，特别温和，居然用了「您」来称呼我：</p><ol><li>自我介绍</li><li>说说你印象最深的一个项目（我说去年的实习可以吗？他说可以），我说了七八分钟，他偶尔会打断并针对我的叙述提问</li><li>你觉得这段实习你在其中学到了什么，阐述了三个方面，又说了五分钟</li><li>听说你想去武汉啊？（对，离家比较近）来北京吧，武汉可能没有这个岗位了，北京钱多，又是核心部门，我目前的组就是服务端开发的 blabla…</li><li>然后就没问我问题了，说会在技术方面给我评分，一会 HR 会有三面，问一些其它的事情</li></ol><p>原本我以为一面没问数据库、网络，二面怎么也该问了吧，可是还是没有（看来是真的不按套路出牌啊😅），面试官超级 Nice。</p><p>几分钟后收到三面的短信。</p><h2 id="三面（28-分钟）"><a href="posts/d42e79bb/#三面（28-分钟）" class="headerlink" title="三面（28 分钟）"></a>三面（28 分钟）</h2><p>这一面 HR 问的问题实在是太多，跟查户口一样，又没有录音，只能回忆起一部分了：</p><ol><li>你是哪人</li><li>Docker 为什么最近火了起来</li><li>Docker 和虚拟机有啥区别</li><li>实习的时候具体做什么，大概多久适应团队</li><li>为什么读计算机专业（开始讲故事）</li><li>高考失常了吗（开始讲故事 × 2）</li><li>为什么不复读（开始讲故事 × 3）</li><li>想过考研吗，为什么不考研？</li><li>有其它公司的面试吗（惭愧，没有）</li><li>你觉得前两位面试官怎么样</li><li>你觉得笔试题难度怎么样</li><li>你对自己的评价怎么样</li><li>对自己的职业规划是怎么样</li><li>公司如果要求转岗你怎么办</li><li>工作地点想选择哪个城市</li><li>对我们公司了解吗</li><li>有什么想问我的<ol><li>有调休吗😅（HR 还有点蒙，转头问了一下其它人）</li><li>薪资待遇怎么样（HR 说最近在集中面试，等面试结束后会逐一评定薪资）</li></ol></li></ol><p>我这俩提问都是比较迫切的，问的并不算好，不过和 HR 聊天还是比较愉快的。</p><h2 id="后记"><a href="posts/d42e79bb/#后记" class="headerlink" title="后记"></a>后记</h2><p>等待 Offer 的过程不可谓不煎熬，5 月 16 号在群里看到有人说接到 Offer Call 了，当时心里就凉了半截，17 号晚上九点看到有人已经收到 Offer 了，一看我的邮箱，心另半截也凉了。结果十点一看发现我也收到了😅，当天激动得一晚上没睡好。</p><p>祝各位都能拿到心仪的 Offer~</p>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 奇安信 </tag>
            
            <tag> 服务端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高校生使用教育网的一点姿势</title>
      <link href="/posts/36b4c1ab/"/>
      <url>/posts/36b4c1ab/</url>
      
        <content type="html"><![CDATA[<p>最近一直忙于毕业的相关事项，所以也没有新文章产出——并非是找不到写作素材，实在是没写作时间。虽然这几天依旧很忙，但总算也抽出了一点时间完成了本文，希望能给广大高校生在办理宽带时带来一些帮助。</p><a id="more"></a><h2 id="前言"><a href="posts/36b4c1ab/#前言" class="headerlink" title="前言"></a>前言</h2><p>目前大部分高校的校园宽带应该都对使用者作出了诸多限制，比如：一号一机，禁止使用路由器（破解后才可以共享）；与校方合作垄断，导致价钱比家用宽带贵一大截等。在校生也只能被迫接受——毕竟，你总不能真的不用电脑上网吧？</p><p>好在目前越来越多的高校里校园网已经开始支持 IPv6 了，而一般校园网只针对 IPv4 的流量计费，对 IPv6 产生的流量是不计费的，至于原因，我猜测有两方面原因：一是 IPv6 相关技术还不是特别完善，IPv4 计费系统可能需要修改；二是目前国内 99% 的网站都不支持 IPv6，而纯 IPv6 环境下是无法访问 IPv4 网站的，所以干脆就没做这一限制。</p><blockquote><p>连接上校园网后，不要认证，戳<a href="https://ipv6-test.com/" target="_blank" rel="noopener">这里</a>来测试是否支持 IPv6，当然也可以直接打开 Google，目前 Google 可以通过 IPv6 直连。</p></blockquote><p>但，谁让我是学计算机的呢，这并不能难倒我。既然无法通过 IPv6 直接连接 IPv4 的网站，那利用一个同时支持 IPv4 和 IPv6 的 VPS 做一层代理不就可以绕过这一限制了吗？原理见下拓扑图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1Q5w0S9zqK1RjSZFp761kSXXaO.png" alt="原理"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">原理</figure></p><p>这就意味着，只要你具备 IPv6 网络，<strong>便可以通过此方法绕过诸多限制，从而免费上网</strong>。</p><h2 id="获取-IPv6"><a href="posts/36b4c1ab/#获取-IPv6" class="headerlink" title="获取 IPv6"></a>获取 IPv6</h2><p>目前比较出名的 VPS 服务商除搬瓦工外，大部分都原生支持 IPv6 连接，包括：Vultr、Linode、DigitalOcean。而搬瓦工的 VPS 中 OpenVZ 架构自带 IPv6，KVM 架构则需要利用 Tunnel Broker 技术来提供 IPv6 隧道给只支持 IPv4 的用户（我的搬瓦工 CN2 主机便是通过 Tunnel Broker 来获取 IPv6 支持的，这也是搬瓦工的客服推荐的方案），它定义在 <a href="https://tools.ietf.org/html/rfc3053" target="_blank" rel="noopener">RFC 3053</a>。</p><p><strong>如果你的 VPS 原生支持 IPv6 连接的话，便可以跳过这一步。</strong></p><h3 id="获取-Tunnel"><a href="posts/36b4c1ab/#获取-Tunnel" class="headerlink" title="获取 Tunnel"></a>获取 Tunnel</h3><p>目前 Hurricane Electric 免费提供 Tunnel Broker 服务（我 TM 吹爆！），该公司运营了世界上以对等数目计算的最大 IPv6 网络，所以服务方面是不用担心的。戳<a href="https://www.tunnelbroker.net/register.php" target="_blank" rel="noopener">这里</a>注册。</p><p>随后点击左侧的 <code>Create Regular Tunnel</code>，再在框内输入 VPS 的 IP 地址，再选择一个地区服务器来作为隧道的一端，这里建议根据服务器的地区来就近选择，我这里选择的是 Los Angeles。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1556005626/ovm2o8n4mjlp7wsqrp3g.png" alt="Tunnel 面板"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">Tunnel 面板</figure></p><h3 id="配置-IPv6"><a href="posts/36b4c1ab/#配置-IPv6" class="headerlink" title="配置 IPv6"></a>配置 IPv6</h3><p>创建成功后，在以下页面选择你的系统，如果是 Debian 系就选择 Debian/Ubuntu，其余就选择 Linux-net-tools。</p><p>框中会出现几行命令，登陆 VPS，依次运行这几行命令就行了。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1p5F6SxnaK1RjSZFB763W7VXaM.png" alt="IPv6 配置命令"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">IPv6 配置命令</figure></p><p><strong>第四行被我抹去的地址便是公网 IPv6 的地址。</strong></p><blockquote><p>如果对  Tunnel 的速度需要更换的话，可以删除该 Tunnel 后在 VPS 运行  <code>modprobe -r sit</code> 命令或者直接重启，再重新创建一个 Tunnel。</p></blockquote><h3 id="测试"><a href="posts/36b4c1ab/#测试" class="headerlink" title="测试"></a>测试</h3><p>不出意外，这时 VPS 已经可以使用 IPv6 连接了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1QJtRSxjaK1RjSZFA762dLFXaT.png" alt="测试 IPv6 连接"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">测试 IPv6 连接</figure></p><p>需要注意的是，如果选择非北美地区的服务器，会绕道美国，所以这里的 PING 值会略高。</p><h2 id="配置代理"><a href="posts/36b4c1ab/#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p>代理可以选择 Shadowsocks，但本次要介绍的不是它，而是另一款代理软件：V2Ray。该代理软件比 Shadowsocks 多了许多种伪装流量的方法，且占用内存更低（毕竟是 Go 写的），这对于小内存的 VPS 来说，非常重要。只不过其配置文件比 Shadowsocks 要劝退小白一些。</p><h3 id="服务端安装"><a href="posts/36b4c1ab/#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h3><p>输入以下一行代码进行安装，系统需支持 Systemd：</p><pre><code class="bash">bash &lt;(curl -L -s https://install.direct/go.sh)</code></pre><p>有关更详细的安装教程见<a href="https://www.v2ray.com/chapter_00/install.html#linuxscript" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="服务端配置"><a href="posts/36b4c1ab/#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><p>如果是通过以上命令安装的话，配置文件在 <code>/etc/v2ray/config.json</code> 目录，以下是我的配置文件，没有流量伪装等进阶配置：</p><pre><code class="json">{  &quot;log&quot;: {    &quot;loglevel&quot;: &quot;warning&quot;,    &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,    &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;  },  &quot;inbounds&quot;: [{    &quot;port&quot;: 10086,    &quot;protocol&quot;: &quot;vmess&quot;,    &quot;settings&quot;: {      &quot;clients&quot;: [        {           &quot;id&quot;: &quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;,          &quot;alterId&quot;: 4        }      ]    }  }],  &quot;outbounds&quot;: [{    &quot;protocol&quot;: &quot;freedom&quot;,    &quot;settings&quot;: {}  }]}</code></pre><p><code>inbounds</code>：入站配置，是一个<strong>数组</strong>。</p><p>注意协议这里填的是：<code>VMess</code> ，由 V2Ray 原创的一份加密传输协议。</p><p><code>clients</code> 是一个 Object 数组，每一个元素里的 id 必须满足 UUID 格式，且服务端客户端需保持一直，作用类似于 Shaowsocks 中的密码。</p><p><code>outbounds</code>：出站配置，也是一个<strong>数组</strong>。</p><h3 id="客户端安装"><a href="posts/36b4c1ab/#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h3><p>Linux 客户端的安装与服务端一致。</p><p>Windows 建议使用 <a href="https://github.com/2dust/v2rayN/releases" target="_blank" rel="noopener">V2RayN</a>，带有图形化界面，下载 <code>V2RayN-Core.zip</code> 解压，下载 <code>V2RayN.zip</code> 解压出的 .exe 文件放入刚刚的目录下。</p><p>目录应该与以下类似：</p><pre><code>.├── config.json├── geoip.dat├── geosite.dat├── guiLogs│   ├── 20190421.txt│   ├── 20190422.txt│   └── 20190423.txt├── guiNConfig.json├── pac.txt├── readme.md├── user-wininet.json├── v2ctl.exe├── v2ctl.exe.sig├── v2ray.exe├── v2ray.exe.sig├── v2rayN.exe├── wv2ray.exe└── wv2ray.exe.sig</code></pre><h3 id="客户端配置"><a href="posts/36b4c1ab/#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><h4 id="Linux"><a href="posts/36b4c1ab/#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>格式与服务端一致，你需要修改的仅有 address 和 id 部分：address 填写服务端的 IPv6 地址；id 需与服务端一致。 </p><pre><code class="json">{  &quot;log&quot;: {    &quot;loglevel&quot;: &quot;warning&quot;,    &quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,    &quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;  },  &quot;inbounds&quot;: [{    &quot;port&quot;: 1081,    &quot;listen&quot;: &quot;127.0.0.1&quot;,    &quot;protocol&quot;: &quot;socks&quot;,    &quot;settings&quot;: {      &quot;netword&quot;: &quot;udp&quot;    }  }],  &quot;outbounds&quot;: [{    &quot;protocol&quot;: &quot;vmess&quot;,    &quot;settings&quot;: {      &quot;vnext&quot;: [{        &quot;address&quot;: &quot;xxxx:xxxx:xxxx::xxxx&quot;,        &quot;port&quot;: 10086,        &quot;users&quot;: [          {            &quot;id&quot;: &quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;,            &quot;alterId&quot;: 4          }        ]      }]    }  },{    &quot;protocol&quot;: &quot;freedom&quot;,    &quot;tag&quot;: &quot;direct&quot;,    &quot;settings&quot;: {}  }]}</code></pre><p>这时，打开网络代理，填入：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1ewfaXvc3T1VjSZLe762ZsVXa0.png" alt></p><p>注意，<strong>这里一定要选择手动代理模式</strong>，不能使用 PAC/自动模式，因为我们的目的是要本地的所有流量都走代理。而 PAC 仅会当遇到被墙的 IP 时才会走代理。</p><h4 id="Windows"><a href="posts/36b4c1ab/#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>双击 V2RayN.exe 后，点击右上角的<code>添加 VMess 服务器</code>：</p><p>填入地址，端口，id 即可：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1gzJSSrrpK1RjSZTE763WAVXaO.png" alt="Windows 配置"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">Windows 配置</figure></p><p>再将右下角的系统代理模式改为全局模式，道理同 Linux 类似：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1YdVUSq6qK1RjSZFm7600PFXac.png" alt></p><p>这样，不出意外的话，就已经成功了，你的仅支持 IPv6 的电脑已经该可以通过代理来访问非 IPv6 的网站了。</p><h2 id="连接测试"><a href="posts/36b4c1ab/#连接测试" class="headerlink" title="连接测试"></a>连接测试</h2><h3 id="网速测试"><a href="posts/36b4c1ab/#网速测试" class="headerlink" title="网速测试"></a>网速测试</h3><p>正好手头最近入了一个原生支持 IPv6 的 VPS，贴一下与搬瓦工的对比，以下均在同一时段做的测试：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1Q14Ege3tHKVjSZSg7604QFXac.png" alt="原生 IPv6"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">原生 IPv6</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1xkAOS7voK1RjSZFw763iCFXay.png" alt="搬瓦工 + Tunnel Broker"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">搬瓦工 + Tunnel Broker</figure></p><p>原生支持 IPv6 的机器可以直接观看 2K 视频并且不会出现卡顿现象（可以看到已经缓冲了一分钟了），而使用 Tunnel Broker 的就没这么好了，不仅连接速度只有三分之一，而且无法较为流畅的观看 2K 视频，时不时会出现卡顿。考虑到 YouTube 的线路优化已经很强了，国内的视频或者直播应当只能观看 720p（码率最好不要超过 3000）甚至更低了，而前者直播时蓝光 8M 无压力。</p><h3 id="延迟与丢包测试"><a href="posts/36b4c1ab/#延迟与丢包测试" class="headerlink" title="延迟与丢包测试"></a>延迟与丢包测试</h3><p>首先是搬瓦工的，经过了 15 个节点，教育网的入口和出口丢包率很高：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1X9ZNS3HqK1RjSZFE763GMXXa0.png" alt="搬瓦工 + Tunnel Broker"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">搬瓦工 + Tunnel Broker</figure></p><p>这是原生 IPv6 的，经过了 19 个节点，同样教育网的入口和出口丢包率较高（但还不是最高的）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB17MsKS3HqK1RjSZFg7617JXXaj.png" alt="原声 IPv6"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">原声 IPv6</figure></p><p>可以看到其原生自带 IPv6 的主机其实也用的是 HE 的 IPv6 网络（前 13 个节点都一样），那么看来是返程的时候出问题了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1tAUOS9zqK1RjSZFj762lCFXaU.png" alt="原生的 IPv6 返程"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">原生的 IPv6 返程</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1GPs0S7voK1RjSZFw763iCFXan.png" alt="搬瓦工的返程"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">搬瓦工的返程</figure></p><p>果然，问题出在返程上面，原生的 IPv6 并没有走 HE 的线路，丢包率为 0。而相比于浏览网页，在看视频时返程的网络状况会直接影响观看体验，这一点也确实在之前的网速测试中体现了。</p><p>所以，购买建议是：</p><p>如果你还没有购买 VPS 的话，建议购买原生自带 IPv6 连接的 VPS，使用体验会好很多，不过由于电脑是全局的代理，所以要注意 VPS 流量的使用哦~</p><p>最后附赠一个国内的 IPv6 电视网站：<a href="https://iptv.tsinghua.edu.cn/v2/list/channel/%E9%AB%98%E6%B8%85%E9%A2%91%E9%81%93" target="_blank" rel="noopener">清华大学 IPTV</a>。</p><p>参考：</p><ol><li><a href="https://www.bandwagonhost.net/2144.html" target="_blank" rel="noopener">给搬瓦工 KVM 版 VPS 配置 IPv6 支持（基于 Linux CentOS 7）</a></li><li><a href="https://www.v2ray.com/chapter_00/start.html" target="_blank" rel="noopener">Project V 官方网站</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPv6 </tag>
            
            <tag> 教育网 </tag>
            
            <tag> 破解校园网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 与 Android 同步剪贴板的通用方案</title>
      <link href="/posts/d691e748/"/>
      <url>/posts/d691e748/</url>
      
        <content type="html"><![CDATA[<p>按照惯例，还是在每篇文章的开头扯几句不相关的：元旦前就从学校回家了，在家的十几天过得很是舒坦：闲的时候，上午玩两小时游戏或者看看直播，下午就看会 Coursera，晚上有时间就看部电影，没整段的空余时间就找朋友聊聊天、刷刷 V2EX；当然在不闲的时候也是做了一些事的，就比如本文将要说到的——让移动平台和桌面平台同步剪贴板的方案。</p><a id="more"></a><p>我为什么想到做这个呢：两周前，我把用了一年半的 Manjaro 格式化了（忍受不了 KDE 巨多的 Bug，还有硬盘都被我用完了），装上了 Ubuntu，桌面环境选择了 Budgie——一个新出的 DE。比 GNOME 漂亮，比 KDE 稳定，稍加配置即可满足我这个强迫症的审美需求：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB15xNmaOzxK1RjSspj763S.pXaS.png" alt="桌面截图"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">桌面截图</figure></p><p>从 KDE 转成 Budgie 之后，最让我不习惯的就是手机和电脑再也不能愉快地共享剪贴板和文件了，当然我也在网上找了一些现成的解决方案，但体验都不佳，于是我便考虑自己造一个轮子。</p><h2 id="设计思路"><a href="posts/d691e748/#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>由于移动端（客户端）、桌面端（服务端）二者需要进行数据的双向传输，HTTP 协议肯定是无法做到了：于是选用了 WebSocket 作为底层的传输协议。同时，为了让适用性更广，桌面端开发选择了 Golang；移动端则使用 React Native 开发。但这两门高级的语言（Golang、JavaScript）都无法为剪贴板添加监听事件，于是我只好自己用轮询的方式对比当前剪贴板的内容与上一次内容的差异，再考虑是否发送数据。</p><h2 id="桌面端"><a href="posts/d691e748/#桌面端" class="headerlink" title="桌面端"></a>桌面端</h2><p>桌面端的开发语言选择 Golang 其实我是有些不情愿的：</p><ol><li>太过高级：无法提供系统底层的 API（比如监控剪贴板）；</li><li>语法太过丑陋：我想把 log 信息封装一下，结果用 struct 封装了半天，代码反而看起来更「💩」了，还不如用 Switch，可 Switch 导致暴露出的接口又不够简洁 . . .</li></ol><p>其它语言我也找了个遍：Python 虽可监听剪贴板的变化（通过 gi 这个库），但这个库并没有办法跨平台，且我 Windows 没有安装编程环境，我也不想安装。</p><p>总之，能监听剪贴板的无法跨平台，能跨平台的无法监听剪贴板。</p><p>So . . . 哪怕 Go 有万般不是，但在跨平台这一点的易用性上也足以让我抛弃其它的所有（纯静态链接库 + 交叉编译）。</p><p>于是乎，</p><p>「真香」。</p><h2 id="移动端"><a href="posts/d691e748/#移动端" class="headerlink" title="移动端"></a>移动端</h2><p>其实我本想用 Flutter 来开发的，但遇到了一些问题：</p><ol><li>在我电脑上无法热加载，这在修改样式的时候可太难受了；</li><li>Dart 似乎无法在已有的 WebSocket 连接上绑定一个新的连接，即使原来的连接已经失效了（不知是 Bug 还是咋样）。</li></ol><p>于是我选择了 React Native。有了 React 的基础，上手确实很快，并且 JavaScript 写起来感觉还是挺爽的。</p><p>之所以会有刚刚提到的（重新绑定 WebSocket 的）需求，是因为在不同的网络环境中，电脑的 IP 可能有所改变，而我暂时想不到一个方法让手机自动识别同一网络的哪一台电脑使用了共享剪贴板的工具（逐一扫描 IP？那也太丑陋了）。</p><p>所以在初始化连接时需要手动输入一次电脑的 IP 地址，随后地址信息会被保存，之后就不用再输入了。</p><h2 id="使用"><a href="posts/d691e748/#使用" class="headerlink" title="使用"></a>使用</h2><p>只需保持这两个软件在后台，会自动监控剪贴板的内容并发送。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1nepnaIfrK1RkSnb4760HRFXaf.png" alt="桌面端"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">桌面端</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1dj0maN_rK1RkHFqDq6yJAFXam.jpg" alt="移动端"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">移动端</figure></p><h2 id="下载"><a href="posts/d691e748/#下载" class="headerlink" title="下载"></a>下载</h2><p>由于代码写的有点不满意，功能也不太完善，等以后有空重构之后加上文件共享功能，会开源的。这里先放出各平台的可执行程序：<a href="https://bit.ly/clipboard_shared" target="_blank" rel="noopener">戳我👈</a>。</p><hr><p>愿能有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clipboard </tag>
            
            <tag> 剪贴板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的 2018 轨迹</title>
      <link href="/posts/e4e1357d/"/>
      <url>/posts/e4e1357d/</url>
      
        <content type="html"><![CDATA[<div id="aplayer" musicid="498134"></div><script src="https://api.itswincer.com/music/v1/" async></script><p>实习回到学校十几天后，便开始思考年终总结怎么写，之所以这么早就开始构思，或许是我笃定在这 2018 最后的半个月内也不会发生什么值得记录的大事。当然我也期待着能发生什么事来冲击一下现有的生活——在校的时光实在是太安逸了，想来是应当正处于心理空窗期了。</p><a id="more"></a><p>本次总结将会就学习、生活、工作（实习）三个方面来描绘一下今年的生活轨迹。</p><h2 id="学习"><a href="posts/e4e1357d/#学习" class="headerlink" title="学习"></a>学习</h2><p>我应该算是「兴趣驱动学习」的典范了：每当我抱着很强的目的性或功利性去学习的时候，总是坚持不了多久。Princeton 的算法课从两年前就开始学，学到现在也才把排序看完。</p><p>不过今年在学习方面还是有不少收获的：借助 Coursera 这一平台，观看了 Node.js 的开发，Golang 的入门等网课。我在学习一门新语言的时候总会选择看视频，如果从一开始就看书的话，我会觉得有些乏味和枯燥，尤其是动辄上千页的技术类书籍，看厚度就有一种劝退感。而在入门后，想要深入了解一门的语言的底层，我才会选择翻阅一些书籍。</p><p>除了学习新东西之外，对 Functional Programing（函数式编程，以下简称 FP）也有了更深刻地理解。比如，为什么 FP 中多以递归来代替 Imperative programming（命令式编程）中的循环语句。原因在于数学家和逻辑学家们验证递归的正确性比验证循环的正确性要容易得多。</p><p>一个很简单的例子，分别用 Java 和 Haskell 实现快速排序：</p><p>Java：</p><pre><code class="java">public class Sorter {    public static &lt;T extends Comparable&lt;? super T&gt;&gt; void quicksort(T[] list) {        quicksort(list, 0, list.length - 1);    }    private static &lt;T extends Comparable&lt;? super T&gt;&gt; void quicksort(T[] list, int low, int high) {        if (low &gt;= high)            return;        int i = low - 1, j = high + 1;        T pivot = list[low];        for (;;) {            do {                ++i;            } while (list[i].compareTo(pivot) &lt; 0);            do {                --j;            } while (list[j].compareTo(pivot) &gt; 0);            if (i &gt;= j)                break;            T tmp = list[i];            list[i] = list[j];            list[j] = tmp;        }        quicksort(list, low, j);        quicksort(list, j + 1, high);    }}</code></pre><p>Haskell：</p><pre><code class="haskell">quicksort :: (Ord a) =&gt; [a] -&gt; [a]quicksort[] = []quicksort(pivot : rest) =     quicksort[x| x &lt;- rest, x &lt; pivot]    ++ [pivot]    ++ quicksort[x| x &lt;- rest, x &gt;= pivot]</code></pre><p>以上两段代码，哪一段的正确性更容易验证？答案不言自明。</p><p>对于前者，指定了计算的详细过程，而后者，仅指定了计算的规则（原则）。这也是 FP 的特点之一：不关心如何计算，更关心计算的结果（的正确性）。</p><p>「正确」是 FP 设计的重中之重。究其根本在于 FP 的鼻祖 Lisp 与 λ 演算那密不可分的联系。</p><h2 id="生活"><a href="posts/e4e1357d/#生活" class="headerlink" title="生活"></a>生活</h2><p>生活方面似乎并没有什么改变，相比去年——好吧，并不是。我的体重告诉我比去年重了 ×× 斤。去杭实习不仅没瘦，反而重了。而且似乎睡得还更晚了，不过似乎「互联网依赖症」减轻了不少，比如本文初稿就是纯手写的。</p><p>在读书方面，算是有了一些进步，今年在豆瓣读书上为 15 本书贴上了「已读」的标签（不过仍未达到两周一本的目标）。文学类和技术类都有，技术类对我影响最大的毫无疑问就是《流畅的 Python》这本书了，断断续续地看了近三个月，做了万余字的笔记。</p><p>至于文学类嘛，《哲学家们都干了些什么》是让我眼前一亮：枯燥的哲学似乎在作者笔下都「皮」了起来。但印象最深地却是伊坂幸太郎的《金色梦乡》，等下，《白夜行》好像印象也很深刻，《解忧杂货店》构思也很巧妙（这么说来我果然很喜欢日系推理），钱锺书的《围城》也不错…好吧，文无第一，今年看的文学类书籍都非常不错。</p><p>接下来就该到电影方面了：今年在豆瓣电影为 72 部电影（包括剧集）贴上了「已看」标签。比较喜欢的剧集似乎都是日剧（非自然死亡，胜者即是正义）；电影的话，《我不是药神》一枝独秀，在电影院里哭得还朝旁边的妹子借纸；动漫也看了不少：来自深渊（新番），怪化猫（旧番）都不错，属于能给灵魂带来冲击的番。</p><p>谈话类节目仍然强推《圆桌派》，可惜第三季之后窦文涛似乎就跑路了。纪录片这块则必须让陈晓卿的《风味人间》安排上，对于一个吃货来说，本节目的美食引起了强烈不适。不过还是作为吃货，即使吃不着，退而求其次，能过过眼瘾也是一种享受。此外，本节目还会介绍与美食相关的风土，人情，文化，品味等，美食之所以被冠以「美」字，绝不仅仅在于它的味道，更在于人们赋予它的某种意义，或者说是其背后所蕴含着的丰富内涵，这才是其绵延不绝的生命力所在。</p><h2 id="工作"><a href="posts/e4e1357d/#工作" class="headerlink" title="工作"></a>工作</h2><p>如果说搭建这个博客是去年我做的最有意义的事，那么实习应该就是今年我所做的最有意义的事了。</p><p>九月份时我并没有走校招，原因有两方面：一方面我并没有发现有什么企业校招 Python 岗（大部分都是前端和 Java）；另一方面是估计实习时间也不会太久，本学期期末学校肯定一大堆事，于是也没怎么考虑公司，面了一家，就进去了。</p><p>我面的是 Python 岗，本以为进来之后也是写 Python。谁知阴差阳错上了 Node.js 的贼船，当然这有一部分的原因在于我：Leader 问我能不能用 Node.js，我说之前接触过一些，然后他就给了我几天时间让我熟悉一下。不过好在是从零开始写的，不用「接盘」前人的代码，倒是省了不少事。在公司待的两个半月时间内，也帮同事解决了不少 Python 问题，不过多是业务方面的逻辑。除此之外，收获最大的就是 Elasticsearch（以下简称 Elastic）的相关组件（我编写的 API 是直接与 Elastic 交互的）的部署和维护了，因为个人的项目很难直接接触到 Elastic 这一庞大的生态系统。</p><p>不过我是有些认为面试的时候公司没有把我的水平面出来（颇有些怀才不遇的感觉），简历上写的大部分细节都没问。只是问了问笔试题，感觉有点憋屈。能力未充分得到挖掘带来的问题就是资源的浪费。一方面是职员能力的浪费（能力得不到体现），一方面是公司资源的浪费（项目进度跟不上，业绩无法按时达标），于是就会导致某些人上班只需要花费很少的时间即可完成公司的任务，剩下一堆可自由支配的时间，而另一些人不仅上班时间不够用，还需要加班才能勉强完成。在这个公司时，我应当时属于前者，虽然有些不好意思，但我在公司的空余时间还是会学些自己的东西。</p><p>同时我也感觉写业务写久了，脑子里也只剩下业务了。对技术反而没什么提升，而对于当下的我来说，技术仍远比业务重要。正在这时候，学校要求我们回去准备毕设的事。于是，我辞职了，开始享受这为数不多的大学时光。</p><p>如果说之前的我还对未来的道路存疑的话，那么这两个半月的实习生活让我开始明确了未来的道路——Python 开发相关。同时也明白：校园的时光虽然让人十分享受，但也总有毕业的那一天。如果说大学的象牙塔是我最后的天堂，那就让我从天堂里一步一步地走出来。</p><hr><p>似乎该结尾了，我不想再像去年一样为我的 2019 立什么 Flag 了（去年的 Flag 一大半都没实现），不过我想毕业的年份应当过得比较有趣吧？</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 2018 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 集群备份指南</title>
      <link href="/posts/92d76830/"/>
      <url>/posts/92d76830/</url>
      
        <content type="html"><![CDATA[<p>Elasticsearch 官方对其的定义是一种搜索引擎，但我更喜欢把它当作一种非关系型数据库来看待，而作为数据库来看待的话，保障其中数据的安全性和可靠性自然是重中之重了。</p><p>首先声明，本文对 Elasticsearch 数据的备份是基于<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html" target="_blank" rel="noopener">官方提供的 API</a>，其它的诸如 <a href="https://github.com/taskrabbit/elasticsearch-dump" target="_blank" rel="noopener">elasticsearch-dump</a> 等第三方工具暂且不谈。官方的提供的备份方式是一种 Snapshot，其中备份路径可以选择云端或本地，本文想就备份集群数据到本地写一份指南，并对遇到的问题做一些解答。 </p><a id="more"></a><h2 id="搭建集群文件系统"><a href="posts/92d76830/#搭建集群文件系统" class="headerlink" title="搭建集群文件系统"></a>搭建集群文件系统</h2><p>为了创建一个 Elasticsearch 集群的 Snapshot，首先必须先搭建一个集群文件系统，用以确保集群的所有节点对同一个目录具有操作权限——这里推荐使用 NFS（Network File System）。</p><p>NAS 需要指定集群的某一个节点的文件夹作为服务器来提供硬盘存储，也是 NAS 存储文件的实际位置，集群的其他节点作为客户端挂载服务端的共享文件夹。</p><h3 id="安装"><a href="posts/92d76830/#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="shell">sudo apt install nfs-kernel-server # 服务端sudo apt install nfs-common # 客户端</code></pre><h3 id="创建共享文件夹"><a href="posts/92d76830/#创建共享文件夹" class="headerlink" title="创建共享文件夹"></a>创建共享文件夹</h3><p>这里是我踩的第一个坑。<strong>服务端的共享文件夹所有者必须也是运行 Elasticsearch 程序的用户</strong>，不然 Elasticsearch 是无法将数据备份到该文件夹的，比如运行 Elasticsearch 的用户是 els 的话，可以用如下命令来创建共享文件夹：</p><pre><code class="shell">sudo -u els mkdir /path/to/backups -p</code></pre><h3 id="修改配置文件"><a href="posts/92d76830/#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>在服务端的 <code>/etc/exports</code> 中添加以下内容：</p><pre><code class="conf">/path/to/backups 192.168.1.1(insecure,rw,sync,no_subtree_check,no_root_squash,no_acl)</code></pre><p>其中 <code>192.168.1.1</code> 就是服务器本机的 IP。括号内的是配置参数，稍稍解释一下：</p><ul><li><code>insecure</code>：允许客户端从大于 1024 的端口号连接。</li><li><code>rw</code>：所有连接者都具有读写权限。</li><li><code>sync</code>：将更改都提交到稳定存储之后再回复请求。</li><li><code>no_subtree_check</code>：禁用子树检查。</li><li><code>no_root_squash</code>：关闭 root 压缩。</li><li><code>no_acl</code>：不要向客户端显示 ACLs。</li></ul><p>更多的参数可以参考<a href="https://linux.die.net/man/5/exports" target="_blank" rel="noopener">这里</a>。</p><h3 id="生效配置"><a href="posts/92d76830/#生效配置" class="headerlink" title="生效配置"></a>生效配置</h3><pre><code class="shell">exportfs -r</code></pre><p>这时你可以使用 <code>showmount -e localhost</code> 来查看本机的挂载情况：</p><pre><code class="shell">/path/to/backups 192.168.1.1</code></pre><h3 id="客户端"><a href="posts/92d76830/#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>注意，客户端也一定要使用运行 Elasticsearch 的用户的权限来创建相同的文件夹，这一点非常重要。然后把服务端的文件夹挂在到各个节点：</p><pre><code class="shell">mount -t nfs 192.168.1.1:/path/to/backups /path/to/backups</code></pre><p>没有报错的话，就挂载成功了。</p><h2 id="Elasticsearch-配置"><a href="posts/92d76830/#Elasticsearch-配置" class="headerlink" title="Elasticsearch 配置"></a>Elasticsearch 配置</h2><p>需在每一个节点的 <code>elasticsearch.yml</code> 中加上一行：</p><pre><code class="yaml">path.repo: [&quot;/path/to/backups&quot;]</code></pre><p>然后重启 Elasticsearch。</p><p>这时就可以尝试创建一个 Snapshot 的仓库了：</p><pre><code class="json">PUT /_snapshot/my_backup{    &quot;type&quot;: &quot;fs&quot;,    &quot;setting&quot;: {        &quot;location&quot;: &quot;/path/to/backups&quot;    }}</code></pre><p>如果没有报了权限错误的话，就 OK 了。</p><p>如果报了权限错误，请检查 Elasticsearch 对该文件夹是否具有写权限。如果确认具有写权限，那么就需要把集群各节点运行 Elasticsearch 的用户的 UID 和 GID 统一起来，具体做法见附录。这里是我踩的第二个坑。</p><h2 id="创建一个备份"><a href="posts/92d76830/#创建一个备份" class="headerlink" title="创建一个备份"></a>创建一个备份</h2><p>你可以以如下命令来创建一个备份：</p><pre><code class="json">PUT /_snapshot/my_backup/snap1?wait_for_completion=true{    &quot;indices&quot;: &quot;index_1,index_2&quot;}</code></pre><p>其中 <code>wait_for_completion</code> 参数并不会马上返回结果，而是等备份完成之后再返回结果，如果备份的索引很多的话，可能会花费很多时间才返回，所以并不建议加上这个参数。可以为 <code>PUT</code> 加上请求体，指定索引，如上指定 <code>index_1</code>、<code>index_2</code> 两个索引备份，如果不加请求体的话会默认备份全部索引。</p><p>当 Snapshot 正在生成中的时候，可以使用如下命令来获取备份的进度：</p><pre><code class="json">GET /_snapshot/my_backup/snap1</code></pre><p>其返回的 <code>state</code> 项的值即是备份进度条。</p><p>Elasticsearch 是采取增量备份的形式，但需注意，Snapshot 不可重复创建，也就是说 Snapshot 的名字不能相同。</p><h2 id="从备份中恢复"><a href="posts/92d76830/#从备份中恢复" class="headerlink" title="从备份中恢复"></a>从备份中恢复</h2><p>可采取如下命令从 Snapshot 中恢复：</p><pre><code class="json">POST /_snapshot/my_backup/snap1/_restore</code></pre><p>默认所有的索引都会恢复，当然你也可以指定索引：</p><pre><code class="json">POST /_snapshot/my_backup/snap1._restore{    &quot;indices&quot;: &quot;index_1,index_2&quot;}</code></pre><p>而有关恢复的进度，Elasticsearch 并不提供查询像备份进度那样的 API，所以只能使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-recovery.html" target="_blank" rel="noopener">indices recovery</a> 和 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-recovery.html" target="_blank" rel="noopener">cat recovery</a> 来查询恢复进度。</p><p>与备份和恢复更详细的讲解请参照<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-snapshots.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="附：更改-UID-和-GID-的方法"><a href="posts/92d76830/#附：更改-UID-和-GID-的方法" class="headerlink" title="附：更改 UID 和 GID 的方法"></a>附：更改 UID 和 GID 的方法</h2><p>首先假设各节点运行 Elasticsearch 的用户名为 <code>els</code>。先假设：他的旧 UID 为 1005，旧 GID 为 2000，要把他改成 UID 为 2005，GID 为 3000 的新用户。</p><p>首先为 <code>els</code> 更改新的 UID 和 GID：</p><pre><code class="shell">sudo usermod -u 2005 elssudo groupmod -g 3000 els</code></pre><p>这就算完成了，可以用 <code>id els</code> 命令来查看用户的 UID 和 GID 是否被成功更改。</p><p>当然，这只是把用户名的 UID 和 GID 做了简单的更改，还需要把原用户的所有文件、目录的所有者都改成新的，不然是无法成功运行 Elasticsearch 的，会报权限错误。</p><p>以下命令来更改：</p><pre><code class="shell">sudo find / -group 2000 -exec chgrp -h els {} \;sudo find / -user 1005 -exec chown -h els {} \;</code></pre><p>其中 <code>-exec</code> 参数对每个文件执行 <code>chgrp</code> 和 <code>chown</code> 命令。<code>-h</code> 参数是对符号链接起作用，而不是应用文件。</p><p>参考：</p><ul><li><a href="https://stackoverflow.com/questions/44955219/snapshot-api-not-working" target="_blank" rel="noopener">Snapshot API not working</a></li><li><a href="http://smallasa.com/2017/03/09/elasticsearch-backup-and-restore/" target="_blank" rel="noopener">elasticsearch backup and restore</a></li><li><a href="https://www.cyberciti.biz/faq/linux-change-user-group-uid-gid-for-all-owned-files/" target="_blank" rel="noopener">How to Change a USER and GROUP ID on Linux For All Owned Files</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
            <tag> 备份 </tag>
            
            <tag> 恢复 </tag>
            
            <tag> backup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 知多少（二）——继承</title>
      <link href="/posts/58dd3c61/"/>
      <url>/posts/58dd3c61/</url>
      
        <content type="html"><![CDATA[<p>好像又有一段日子没写技术类博文，翻了翻归档，发现最近一篇技术类文章已经是俩月多之前的事了，吓得我赶紧<del>水</del>写一篇的技术文章不然怕是要被人当成生活博主了。思来想去写些什么好，还是继续上次开的新坑，来聊聊 Python 中的继承。</p><a id="more"></a><p> Python 作为一种具备多种编程范式的语言，面向对象自然也是它所具备的范式之一；而继承，作为面向对象程序设计的三大特性之一，其重要性也是不容忽视的。尤其这一特性在支持面向对象范式的语言里还有着不同的规则，如：C++ 同时支持普通继承和虚继承；Java 则是将其它语言中的 class 细分为 class 和 interface；还有 Python，「无痛地」支持多重继承。 </p><h2 id="多重继承"><a href="posts/58dd3c61/#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>当一个语言支持多重继承时，至少需要解决这两个问题，以下图为例逐个分析 C++、Java、Python 对多重继承的支持情况：</p><pre><code class="markdown">            A          /   \         B     C          \   /            D</code></pre><ol><li>怎么处理共同的父类（基类、超类）</li><li>多个父类方法名重复的问题</li></ol><h3 id="C"><a href="posts/58dd3c61/#C" class="headerlink" title="C++"></a>C++</h3><p>首先看看 C++ 是怎么解决第一个问题的：C++ 在遇到这种情况时，最顶层的基类（A）会被创建两次，虽然可以通过将 A 设置为 B、C 的虚基类来解决，但这种虚继承是有副作用的：不只是在获取成员会更慢、占用内存更多，在和虚函数一起出现时会更难以理解：当 A、B、C、D 中都有一个虚函数 f 时， <code>D::f</code> 内部调用了 <code>B::f</code> 和 <code>C::f</code>；<code>B::f</code>和<code>C::f</code>内部都调用了<code>A::f</code>，于是 <code>A::f</code>就被调用了两次。当然也不是没有办法解决，<a href="https://books.google.com/books?id=PSUNAAAAQBAJ&amp;lpg=PA767&amp;ots=DrtrIigY4J&amp;dq=27.4.%20Template%20Parameters%20as%20Base%20Classes&amp;hl=zh-CN&amp;pg=PA767#v=onepage&amp;q&amp;f=false" target="_blank" rel="noopener">Template Parameters as Base Classes</a> 就是 C++ 之父专门用于解决这个问题所开发的技术。</p><p>第二个问题：如果这里的 B 和 C 同时实现了 <code>hello</code> 方法，同时 D 中没有实现 <code>hello</code> 方法，那么在调用 <code>d.hello()</code>（d 为 D 的 instance） 的时候会调用哪一个？编译器对于这种 Ambiguous base classes 的情况会直接报错，解决方法也简单粗暴，你必须显式指定 <code>d.B::hello()</code> 来调用 B 中的 <code>hello</code>。虽然以上两个问题在 C++ 中都解决的并不好，但也总归是解决了。下面来说说 Java。</p><h3 id="Java"><a href="posts/58dd3c61/#Java" class="headerlink" title="Java"></a>Java</h3><p>Java 之父觉得 C++ 太难用了，于是他决定创造一门语言来取代 C++，这门语言需要保留 C++ 的优点，但又需要把 C++ 中较为混乱、复杂、危险的部分剔除（其中就包括了多重继承），于是，Java 就在这样的理念里诞生了。在 Java 诞生之初，对多重继承的支持少的可怜：一个 class 仅可继承（实现）多个 interface。本来是挺好的，但是在 Java 8 中为 interface 中的方法引入了 default 关键字，这就让 interface 里定义的方法可以有方法体了。</p><p>那么 inteface 有了方法体之后，对这解决这两个问题有什么影响呢？将上例中的 A、B、C、D 换成四个 interface：</p><p>第一个问题：Java 遇到了和 C++ 中的虚函数一样的问题，即 D 中如果想同时调用 B 和 C 中的某方法，且 B、C 中也调用了 A 的方法，那么 A 的该方法会重复运行两次。并且 Java 无法像 C++ 中使用模板技术来解决这个问题。</p><p>第二个问题：Java 8 之前一个 class 可以实现多个 interface，即使 interface 有同名方法也没关系，毕竟 inteface 里定义的方法没有方法体，所以不会导致二义性。但有了 default method 之后，Java 反而无法处理这个问题了：D 不允许同时继承两个实现了 default 方法的接口（一个实现了，另一个没有实现也不行）。</p><p>C++ 解决的不好，Java 压根就没解决。所以我认为 Java 在多重继承这一方面比 C++ 处理的更加不好。</p><h3 id="Python"><a href="posts/58dd3c61/#Python" class="headerlink" title="Python"></a>Python</h3><p>终于到 Python 了，那么先来看看 Python 是如何解决第一个问题的：如果 D 中需要同时调用 B 和 C 中的 <code>hello</code> 方法，且 B、C 中也需要调用 A 的 <code>hello</code> 方法，那么仅需在 B、C、D 的该方法中写下 <code>super().hello()</code> 即可。因为继承图的缘故，Python 中的 <code>super()</code> 会沿着继承图顺序依次找寻 D 的所有超类。</p><p>第二个问题：还是得益于继承图，当 D 中没有实现 <code>hello</code> 方法时，Python 会依据继承图顺序来寻找 D 的所有超类中是否有该方法，直到找到为止，而这个顺序也就是方法解析顺序。</p><p>Python 完美的解决了这两个问题，这也是为什么我说 Python「无痛地」支持多重继承。</p><p>既然这两个问题都是靠方法解析顺序解决的，那么它到底是个什么东西？看官先别急，下面会着重阐述。</p><h2 id="方法解析顺序"><a href="posts/58dd3c61/#方法解析顺序" class="headerlink" title="方法解析顺序"></a>方法解析顺序</h2><p>方法解析顺序（Method Resolution Order，简写为 MRO），是描述该类自继承顶层超类的一种顺序，它在类中以 <code>__mro__</code> 属性存放，值是一个元组（<code>.mro()</code> 返回的则是一个列表，然而这列表并不可变），上例中的 D 的 MRO 为：</p><pre><code class="python">&gt;&gt;&gt; D.mro()[__main__.D, __main__.B, __main__.C, __main__.A, object]</code></pre><p>这里的意思是：D 的最顶层超类为 <code>object</code>（新式类中所有类都继承自 <code>object</code>），其次是 A、C、B。</p><p>下面来具体看看 Python 的代码是如何解决上文提到的第一个问题的：</p><pre><code class="python">class A:    def hello(self):        print(&quot;Hello from A&quot;)class B(A):    def hello(self):        print(&quot;Hello from B&quot;)        super().hello()class C(A):    def hello(self):        print(&quot;Hello from C&quot;)        super().hello()class D(B, C):    def hello(self):        print(&quot;Hello from D&quot;)        super().hello()&gt;&gt;&gt; d = D()&gt;&gt;&gt; d.hello()Hello from DHello from BHello from CHello from A</code></pre><p>在 D 中遇到的 <code>super()</code> 会沿着 D 的 MRO 依次向上寻找超类中的 <code>hello</code> 方法并执行，即依次执行 D -&gt; B -&gt; C -&gt; A 这个顺序。</p><p>那么为什么 Java 或 C++ 无法通过这种写法解决呢，原因在于 Java 的 <code>super</code> 在多重继承中必须指定父类是哪一个，因为编译器是无法获知你想要运行的是哪一个父类的方法。而一旦指定了父类（B），那么与这个父类同时继承的另一个父类（C）你也必须要指定，而这两个父类又具有相同的更高层次的父类（A），所以就导致了最顶层的父类（A）中的方法被调用了两次。</p><p>下面来具体说说 Python 中的 <code>super</code> 类。</p><h2 id="super-的作用"><a href="posts/58dd3c61/#super-的作用" class="headerlink" title="super 的作用"></a>super 的作用</h2><p>在 Python 中某 class 使用了 <code>super()</code> 后，<code>super</code> 即会沿着最初调用 <code>super()</code> 的那个 class 的 MRO 向上寻找超类：</p><pre><code class="python">&gt;&gt;&gt; B.mro()[__main__.B, __main__.A, object]&gt;&gt;&gt; C.mro()[__main__.C, __main__.A, object]</code></pre><p>也就是说：在 B 中调用的 <code>super</code> 不会顺着 B 的 MRO 来向上寻找，而是从最初调用的 D 的 MRO 来向上寻找。那么 <code>super</code> 是怎么知道最初的 class 是哪一个呢？</p><p>嘿嘿，你可能已经猜到了，没错，就是通过 <code>self</code> 这个参数来指定的：当我们调用 <code>d.hello()</code>时 ，实际上调用的是：<code>D.hello(d)</code>，而我们调用的 <code>super()</code> 也只是 Python 3 对 <code>super(a_class, a_instance)</code> （其实这里的 <code>instance</code> 也可以换成 <code>class</code>）的简写，所以其实 B、C、D 中的 <code>super()</code> 中的 <code>a_instance</code> 其实都是 d。 </p><p>当我们以 <code>super(a_class, a_instance)</code> 调用时，这里的 MRO 即为 <code>a_instance.__class__</code> 的 MRO，而 <code>a_class</code> 必须为该 MRO 中的某一项，也就是说 <code>isinstance(a_instance, a_class) == True</code>。</p><p><strong>简单来说</strong>，<code>super()</code> 做的事就是：你提供给它一个 class 以及一个 instance，它返回从该 instance 的 MRO 中排在 class 之后的类里，查找方法的对象。</p><p>说了这么多，那么这个 MRO 到底是怎么产生的？</p><h2 id="C3-算法"><a href="posts/58dd3c61/#C3-算法" class="headerlink" title="C3 算法"></a>C3 算法</h2><p>在 Python 2.3 之后，MRO 是由 C3 算法来计算得出的，而在 2.3 之前是按照如下规则计算：新式类是广度优先，经典类是深度优先。这里仅讨论 Python 2.3 版本之后的 MRO 计算方法，也就是 C3 算法：</p><p>为表述方便，先做出如下规定：<br></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>head([C_1,C_2,…,C_N]) = C_1<br></div><p></p><p></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>tail([C_1,C_2,…,C_N]) = [C_2, C_3,…,C_N]<br></div><p></p><p></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>L[C(C_1,…,C_N)]=[C]+merge(L[C_1],…L[C_N],[C_1,…,C_N])<br></div><p></p><p>则用 C3 算法计算这个列表的线性化可以用公式 (4) 表示，其中的 C 是继承自 C1，C2，… CN 的类。</p><p>对其中的 merge 操作可以解释为：</p><ol><li>选取等号右边 merge 列表的第一项 L[C1] 为 K；</li><li>如果 head(K) 没有在 merge 中的任何列表的 tail 中出现（这时称 head(K) 为 <code>good head</code>），则把 head(K) 加入 C 的线性化列表中，并将 head(K) 从 merge 的所有列表中删除，重复 2；</li><li>否则，设置 merge 中的下一项 L[C2] 为 K，如果 head(K) 为 <code>good head</code>，重复 2；</li><li>重复以上操作直到所有的 class 都被移除或者已经找不到 <code>good head</code> 为止；如果找不到 <code>good head</code> 那么就抛出异常，否则创建成功。</li></ol><p>来看个例子吧：</p><pre><code class="python">A = objectclass B(A): ...class C(A): ...class D(C, B): ...class E(C, D): ...</code></pre><p>首先 L[A] = [A]，然后：<br></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>L[B]=[B]+merge(L[A],[A])=[B, A]<br></div><p></p><p></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>L[C]=[C]+merge(L[A],[A])=[C,A]<br></div><p></p><p>这两个等式很简单，没什么好说的，来看个稍微复杂一点的：<br></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>\begin{aligned}<br>L[D]&amp;=[D]+merge(L[C],L[B],[C,B])\\<br>&amp;=[D]+merge([C,A],[B,A],[C, B])\\<br>&amp;=[D,C]+merge([A],[B,A],[B])\\<br>&amp;=[D,C,B]+merge([A], [A])\\<br>&amp;= [D,C,B]<br>\end{aligned}<br></div><p><br>稍微解释一下：</p><p>第二行，设置 K 为 [C, A]，其中 C，也就是 head(K) 是一个 <code>good head</code>，那么就把 C 加入 D 的列表，并把 C 删去；</p><p>第三行，这时设置 K 为 [A]，A 此时并不是一个 <code>good head</code>，因为他在 tail([B, A]) 中出现了，所以要设置下一项 [B, A] 为 K，此时 B 是一个 <code>good head</code>，那么就把 B 加入列表，并删除 B；</p><p>第四行，这时 K 为 [A]，A 此时是一个 <code>good head</code>，加入列表，并删除 A，此时所有 class 都已经被移除，算法结束。</p><p>来个错误的例子：<br></p><div class="mathrender" style="overflow-x: scroll;padding: .75rem 1rem .2rem 1rem;border: 1px solid #eaecee;border-radius: 3px;"><br>\begin{aligned}<br>L[E]&amp;=E+merge(L[C],L[D],[C,D])\\<br>&amp;=E+merge([C,A],[D,C,B,A],[C,D])<br>\end{aligned}<br></div><p><br>这时算法好像没有办法继续往下走了：因为设置 K 为 [C, A]，head(K) 并不是一个 <code>good head</code>，那么就把 K 设置为 [D, C, B, A]，这时还是不行，因为 D 也在后面列表中的 tail 出现了。</p><p>所以是无法选择 (C, D) 为基类来创建 E 的，如果你在解释器中执行一下代码，你就会发现，它报错了：</p><pre><code class="python">Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: Cannot create a consistent method resolutionorder (MRO) for bases C, D</code></pre><hr><p>以上，</p><p>愿对你有所帮助。</p><p>参考：</p><ul><li><a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">The Python 2.3 Method Resolution Order</a></li><li><a href="https://harttle.land/2015/09/07/effective-cpp-40.html" target="_blank" rel="noopener">Item 40：明智地使用多继承</a></li><li><a href="https://mozillazg.com/2016/12/python-super-is-not-as-simple-as-you-thought.html" target="_blank" rel="noopener">Python: super 没那么简单 - Huang Huang 的博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 继承 </tag>
            
            <tag> super </tag>
            
            <tag> 知多少 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杭州见闻</title>
      <link href="/posts/2848ddef/"/>
      <url>/posts/2848ddef/</url>
      
        <content type="html"><![CDATA[<p>似乎很难说出为什么我对杭州这座城市如此「情有独钟」，以至于暑假就和同学计划着来杭州实习，虽然还是拖到了开学。出发之前也没有准备许多东西，只是简单收拾了一下衣服。所幸到达杭州后遇到的问题（比如租房、工作等）都比较顺利的解决了：遇到了很棒的宾馆老板、主动给我指路的老奶奶、很 Nice 的面试官（随后顺利入职）……这一切都让我对杭州这座城市更有好感，也让如今的我庆幸没有来错杭州。</p><a id="more"></a><h2 id="面试"><a href="posts/2848ddef/#面试" class="headerlink" title="面试"></a>面试</h2><p>来杭州前，我和同学都约了面试，不同的是，他约了 5 场，我只约了 1 场。 在学校临走前的几天他都挺慌的，说 5 场万一都不合适怎么办，非要约 10 场差不多心里才有底，我就安慰他说没事，我才 1 场，我都不慌，你慌什么。他反而对我说，对啊，我要是你估计都慌得不敢去了，不知道你怎么这么有信心。</p><p>当时的我也不知道为什么这么有信心，似乎根本没有想过万一在杭州找不到工作怎么办。就这样，我抱着三分紧张，两分忐忑，五分兴奋的心情，进行了我人生中第一次面试。</p><p>面试中技术问题主要针对的是之前做的笔试题，而笔试题中大部分都是算法的，所幸虽然我虽好久没接触算法了，但也没有完全忘记。不过让我感到奇怪的是我简历中的项目反而问的不是很仔细，似乎公司更看重的是学习能力和思考方式，而说到学习能力我自然是不会虚谁了，毕竟现在掌握的技能大部分都是自学来的 :）</p><p>技术问题过后就是较为老套的提问流程了，比如你为什么要来杭州啊，你对我们公司想要了解什么啊，你对自己未来的职业规划是怎么样的啊等等。与面试官的沟通交流较为顺畅，面试官也说我是来面试中很优秀的了，两天后，顺利的拿到了 Offer。公司名字就不透露了，在和瑞科技园。</p><h2 id="蟹黄汤包"><a href="posts/2848ddef/#蟹黄汤包" class="headerlink" title="蟹黄汤包"></a>蟹黄汤包</h2><p>随后在等面试结果的一天里，让朋友领着逛了逛杭州。</p><p>那天早上朋友说带我去吃蟹黄汤包（青芝坞那家），当时已经早上十点了，朋友准备早午饭一起在那里吃，而我当时已经吃过早饭了，就准备到美院的食堂去吃午饭（我十分庆幸没有去美院的食堂吃，走了一圈愣是没找到食堂在哪），但禁不住朋友一直说这里的蟹黄汤包多么好吃多么好吃，于是我也点了一份。</p><p>等了差不多十几分钟，它才姗姗来迟。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1TBOGXiHrK1Rjy0Flq6AsaFXaE.jpg" alt="蟹黄汤包"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">蟹黄汤包</figure></p><p>外表乍一看和普通的汤包没什么区别，细看还是可以看出馅儿是偏黄一些的。我马上夹起一个就塞到了嘴里，差点没烫哭出来。朋友笑了，然后告诉我说汤包要先从褶子里把汤吸掉，要不然会很烫的。</p><p>想我以前在学校的时候，哪吃过现蒸的汤包啊，食堂大妈早就蒸好了，然后拿布盖着保温，虽然算不上冷，但也绝对算不上烫。</p><p>味道嘛，还算好吃。</p><h2 id="中国美院"><a href="posts/2848ddef/#中国美院" class="headerlink" title="中国美院"></a>中国美院</h2><p>话说其实一开始我不是很想去美院的（但没办法，谁让相机在我朋友手上呢），因为我觉得学校嘛，再好看还能比旅游景点好看？直到我见到美院的大门那一刻我才知道我错了。</p><p>前方多图预警（这个预警并没有什么卵用，因为当你点进这个页面的时候图片已经加载完毕了 :）</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1kSeGXcnrK1RjSspkq6yuvXXab.jpg" alt="通向「幸福」的阶梯"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">通向「幸福」的阶梯</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB186SIchnaK1RjSZFtq6zC2VXa1.jpg" alt="这好像是自习室"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">这好像是自习室</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1mruHXojrK1RkHFNRq6ySvpXak.jpg" alt="可能是幸存的「变形金刚」"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">可能是幸存的「变形金刚」</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1r7yGXcnrK1RjSspkq6yuvXXaJ.jpg" alt="博物馆的侧面"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">博物馆的侧面</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1T0uHXh2rK1RkSnhJq6ykdpXaR.jpg" alt="我忘记这建筑是哪了"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">我忘记这建筑是哪了</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1VtaHXdzvK1RkSnfoq6zMwVXaO.jpg" alt="另一个博物馆的外层围墙"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">另一个博物馆的外层围墙</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1Wa9HXojrK1RkHFNRq6ySvpXas.jpg" alt="喵喵"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">喵喵</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1ztKHXh2rK1RkSnhJq6ykdpXaT.jpg" alt="山上的「宫殿」"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">山上的「宫殿」</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1t_iGXc_vK1RkSmRyq6xwupXao.jpg" alt="轮胎制椅子"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">轮胎制椅子</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1LNWGXjzuK1RjSspeq6ziHVXa6.jpg" alt="某建筑内部"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">某建筑内部</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1Pd9HXovrK1RjSszfq6xJNVXax.jpg" alt="超大的榕树"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">超大的榕树</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1XW5HXffsK1RjSszbq6AqBXXaw.jpg" alt="竹制的避雨场所"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">竹制的避雨场所</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1W7KGXoLrK1Rjy1zbq6AenFXaK.jpg" alt="奇奇怪怪的东西"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">奇奇怪怪的东西</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1xeGGXjzuK1Rjy0Fpq6yEpFXaw.jpg" alt="一个伪装成火车头的咖啡店"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">一个伪装成火车头的咖啡店</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB17xCGXirxK1RkHFCcq6AQCVXaV.jpg" alt="同上，不过换了一个滤镜"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">同上，不过换了一个滤镜</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1almGXozrK1RjSspmq6AOdFXaT.jpg" alt="校园的边界"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">校园的边界</figure></p><p>（不知是因为杭州的美女多还是因为学艺术的女生都比较有气质，真的不愧是<del>中国美女学院</del>中国美术学院。）</p><p>这次好像只逛了一半的校园，因为校园里面的建筑真的和迷宫一样，从一个建筑进去绕了一圈就不知道原先从哪出来的了，导致进校园和出校园都在同一侧，下次有机会还要去逛逛。</p><h2 id="工作"><a href="posts/2848ddef/#工作" class="headerlink" title="工作"></a>工作</h2><p>我目前所在的公司是早上九点上班，下午六点下班，中午午休一小时，一周五天。除了中午休息时间有一点短之外，几乎完美了，而我除了第一、第二天在下午会稍稍犯困之外，后面几天都挺精神的（当然，代价是晚上十点半就要睡觉，这对我反而是好事，正好能调整到健康的作息时间 :)</p><p>公司的同事都很年轻，办公氛围也比较轻松，不会像部分其它的公司那么压抑。那个 Nice 的面试官也成为了我目前所在项目组的 Leader。</p><p>我现在的日常生活就是每天早上睡到八点起，洗漱一下，买个早饭走十几分钟去公司，中午和同事一起去食堂吃午饭，晚上回来之后就写写博客或者看部电影。呐，惬意的生活啊。</p><p>今天也是第一周的最后一天班，早上去公司的时候发现桌上摆着一盒「蛋黄酥」，应该是中秋的礼物了。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1iCmHXorrK1RkSne1q6ArVVXaK.jpg" alt="蛋黄酥，还挺好吃"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">蛋黄酥，还挺好吃</figure></p><p>说到中秋，这应该是我第一个不在家过的中秋了吧，有些伤感。</p><p>最后，还是祝大家中秋节快乐。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杭州 </tag>
            
            <tag> 生活 </tag>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写给 21 岁的自己</title>
      <link href="/posts/d9253d8c/"/>
      <url>/posts/d9253d8c/</url>
      
        <content type="html"><![CDATA[<div id="aplayer" musicid="31861287"></div><script src="https://api.itswincer.com/music/v1/" async></script><p>人类似乎总是对自己无法掌控的事物有些畏惧，比如时间。我就有些害怕时间的流逝，总觉得去年那篇<a href="https://blog.itswincer.com/posts/11ab0263/">写给 20 岁的自己</a>的文章还历历在目，如今又到了该写这系列文章的时候了。我很早就开始构思这篇文章该写什么，却直到最近才了有些明确的思路。</p><p>去年，我曾对自己说，希望可以「不在意别人的眼光，不为了生存而活，为了自己的热爱」那样真实的活着。所幸我应当是在大部分时候都做到了，因此这一年过得很自在。但怎么说呢，近来关于这个问题我却有些困惑了。</p><a id="more"></a><p>前几天一朋友在群里说他辞职了。</p><p>问：为啥啊？这工作不好吗？</p><p>答：工作挺好的，划水都能拿 12k。</p><p>更奇怪了，又问：划水都能拿这么高，还有啥不满意的？</p><p>答：感觉生活没有目的，突然想辞职冷静一下。</p><p>当时还不太能理解他的想法，因为在我看来这简直是梦寐以求的工作啊：划水意味着我就有更多的时间投入到我所喜爱的事情上，但我没有说出口，只是默默听着。他继续说辞职亲戚朋友都反对，但他还是辞了——「迷茫了，每天这么混，不知道该干什么」，他说。听他说完这句话时我就有点理解了，是啊，<strong>没有以自我认可为目的的生活，又有什么可以阻止它慢慢滑向悬崖的另一侧呢</strong>。</p><hr><p>说来有些不好意思，我的自我认可很大一部分来自两部电影——《搏击俱乐部》和《三傻大闹宝莱坞》：做自己想做的事，不要做自己应该做的事情。具体解释就是我不想也没有必要活成别人眼中的自己。像别人一样告诉自己先买车、后买房、再结婚？这都是自己作，一辈子忙忙碌碌都不知道为什么而活，生命只有一次，为什么就不能为自己而活呢？做自己想做的事，不是很开心吗？</p><p>而现在我的想法好像有了些许的改变：在社会福利好的发达国家，也许公民是真的可以做到我梦想的这样：看起来不求上进，赚到钱就花，遇到热爱的事情就去做，一辈子都过得很开心、很舒服。但是在中国不行。</p><p>想成为自己、为自己而活当然没错。这也是电影想告诉我们的，但电影没有告诉我们的是，今天的自己是自己，明天的也是。十年后，三五十年后的都是自己。对于「自己」来说目前所有的选择都是自由的，可以选择自己所热爱的事，也可以按部就班地选择自己应该做的事。仅需记住目前做出的选择所造成的千差万别也是未来的自己所必须接受的。在中国如果按照我之前的那种想法去选择，可能并不会让三十年后的自己开心。当然，这种选择不能说是错的，更不应该被批判，只是说我们在自己没想清楚的时候可能会选择了以后的自己不想要的未来。</p><p>写到这忽然有点明白卢梭的那句「人生而自由，却又无往不在枷锁之中」中的意味了。</p><hr><p>关于我 21 岁的谈人生<del>瞎扯淡</del>就在这里告一段落了。确实，我没有像去年那样在全文中都很明确的表达出一个观点并以此作为我接下来一年生活的座右铭。反而是给了一个模棱两可的答案。但我想，相比去年，这个答案确实更好了——因为得出这个答案我思考得更全面了。或许我需要像阿甘一样，连续奔跑三年才知道自己为什么要奔跑。谁知道呢，也许我明天就想明白了，Life was like a box of chocolates. You never know what you’re gonna get（译文：人呐，就都不知道（命运），自己就不可以预料）。</p><p>用杨绛答复别人回信作为结尾吧：</p><blockquote><p>你们这些年轻人啊！ too young too simple, sometimes naive！你们啊，还是要提高自己的知识水平。</p></blockquote><p>啊不好意思，皮了一下，是下面这句：</p><blockquote><p>「你的问题主要在于读书不多而想得太多」——杨绛。</p></blockquote><p>最后，二十一岁快乐。</p><p>送给自己。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 感想 </tag>
            
            <tag> 21 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客折腾小记</title>
      <link href="/posts/50658b02/"/>
      <url>/posts/50658b02/</url>
      
        <content type="html"><![CDATA[<p>八个月前，我把建站之初就使用的 NexT 主题换成了 Material 主题，依稀还记得当时告诉自己：以后就好好写文章，绝对不再耗费时间在这没啥价值的事情上（让你立 Flag！后悔了吧？）。时隔半年多，如今发现对我来说好像不折腾比折腾还要难一些，原因嘛，自然是新鲜感与强迫症在作祟，这次折腾的起因就在于新鲜感——我看上了一个主题。</p><a id="more"></a><h2 id="优点与缺点"><a href="posts/50658b02/#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h2><p>这次更换的主题是 <a href="https://github.com/elmorec/hexo-theme-inside" target="_blank" rel="noopener">inside</a>，该主题相较于其它 hexo 主题的特殊之处就在于它的本质是采用 Angular 编写的 SPA（single page web application，单页应用程序）。优点就在于每次点击不同的链接只产生一个 HTTP 请求，返回的是一个 <code>.json</code> 文件，包含该页面的内容（内容已在 <code>hexo g</code> 时已经转成 HTML 格式了），而一旦接收到 <code>.json</code> 文件后，就会将文件的内容通过 <code>innerHTML</code> 属性嵌入页面。</p><p>而缺点在于相较于普通的页面，可能对 SEO 不那么友好。因为阻止页面呈现的 JavaScript 可能会对用户体验造成不好的影响，而我为此在额外方面做了补足：添加了 27 个 <code>&lt;meta&gt;</code> 标签，用 Google Chrome 测试 SEO 那一项拿了 89 分，应该还算不错了（拿不到满分是因为部分字体小于 16px）。</p><h2 id="URL-后缀"><a href="posts/50658b02/#URL-后缀" class="headerlink" title="URL 后缀"></a>URL 后缀</h2><p>采用 Angular 编写的 SPA 有一个 <del>Bug</del>Feature，即在路由时会自动去掉 URL 结尾的斜线（slash），这就很尴尬了，因为我的博客 URL 是默认在结尾都有一个斜线的，比如：<code>posts/xxxxxx/</code>，我对此的解决办法是：</p><ol><li><del>为每一个页面都添加一个 <code>canonical</code> 标记，其中标记的链接末尾都加上一个斜线；</del></li><li><del>但这样并不能解决 Google Analytics 的链接地址的问题，因为 Google Analytics 分析发送的 URL 是获取 HTTP 首部信息里的 referrer，为此我修改了发送 Google Analytics 的那部分代码：将每一个 URL 的尾部都加上了斜线；</del></li></ol><p>我在 Stack Overflow 上找到了更好的<a href="https://stackoverflow.com/questions/48425111/angular-5-allow-trailing-slash-in-routes" target="_blank" rel="noopener">解决方法</a>，原理是根据请求 URL 的每一个路由地址在末尾都加上斜线。</p><p>但若想完美的解决这个问题，还需同时为每个匹配的路由路径在末尾都补足一个斜线（否则带斜线的 URL 一刷新就会出现路由无法匹配的情况）。</p><pre><code class="typescript">...{ path: &#39;page/:page&#39;, component: VPostListComponent. resolve: { postList: PostListResolver }, data: { id: &#39;posts&#39; } },// =&gt;{ path: &#39;page/:page/&#39;, component: VPostListComponent. resolve: { postList: PostListResolver }, data: { id: &#39;posts&#39; } },...</code></pre><p>这样一来的话，斜线的问题算是解决了。（这部分也是我折腾耗时最多的部分。）</p><h2 id="用户体验"><a href="posts/50658b02/#用户体验" class="headerlink" title="用户体验"></a>用户体验</h2><p>我针对用户体验方面做了如下改进：</p><ul><li><p>字体</p><p>原主题的默认字体大小是 14px，我将正文修改成了 16px，代码字体修改为了 15px，这应该会比原主题看起来舒服一点。并且我移除了主题额外加载的字体文件，而纯粹改用 <code>font-family</code> 来呈现。参考了 <a href="https://zenozeng.github.io/fonts.css/" target="_blank" rel="noopener">fonts.css</a>。<del>我能吞下玻璃而不伤身体。The quick brown fox jumps over the lazy dog.</del></p></li><li><p>Service Worker</p><p>原主题不带 Service Worker 功能，但我还是为我的博客注册了 Service Worker 功能。</p></li><li><p>启用<a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">盘古之白</a></p><p>主要是为了解决中英文混排时的问题。因为研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。<del>终于找到了我之前过得如此不得意的原因了，看来从此之后我可以走上人生巅峰了。</del></p></li><li><p>Disqus</p><p>原主题对 Disqus 的 identifier 和 url 识别有误，自己新增的页面会在在首部添加 <code>posts/</code> 字段，比如我的 <code>life/</code> 页面会变成 <code>posts/life/</code>，这并不是我希望的。我针对当前 URL 简单的做了一个判断，根据 URL 的不同来生成指定的 identifier。</p></li><li><p>API</p><p>我将原主题的 API 请求前缀改了一下，不从源站请求。因为我的网站是使用 Cloudflare 来<del>减</del>加速访问，但国内的速度却不佳，而我博客大部分用户还是国内的。将 API 请求源放在了国内的 CDN 后，会更大的提升页面的访问速度——访问页面几乎感觉不到页面的加载时间。</p></li></ul><h2 id="个人喜好"><a href="posts/50658b02/#个人喜好" class="headerlink" title="个人喜好"></a>个人喜好</h2><p>相较之前的 material 主题，我去除了 <code>localStorage</code> 功能，因为现在的博客内容需要用 JavaScript 来呈现，而放入 <code>localStorage</code> 的资源取出的速度是不如直接从 Service Worker 请求的速度来的快。</p><p>同时我也移除了 lazyload-image 的功能，因为之前朋友告诉我说她从 RSS 阅读器阅读文章的时候图片没有显示，想了想应该是 lazyload 的 JS 没有加载所导致的，于是乎干脆去掉了，等以后有空的时候再试试 Angular 的 lazyload 是否也有这个问题。</p><p>由于该主题文章的内容是以 <code>innerHTML</code> 呈现的，故 <code>&lt;script&gt;</code> 标签里的内容是不会运行的，导致我的音乐插件 Aplayer 无法加载，于是我另写了一个页面专门呈现单独的音乐插件，再以 <code>iframe</code> 嵌入当前页面，算是比较完美的一个解决方案了。</p><h2 id="尾巴"><a href="posts/50658b02/#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>这篇文章一发布，预示着我博客栈的目录收录的文章也已到达两位数（10 篇）[^1]，强迫症终于满足了。</p><p>最后我想说：</p><ul><li>我真的再也不！想！写！前！端！了！</li><li>这绝对是我最后一次折腾博客！</li><li><del>真香！</del></li></ul><p>[^1]: 最近我将写得不是很满意的文章隐藏了起来（原本想删除的，后来想了想实在有些舍不得），有二十余篇，我的博客现在不提供这些文章的入口，你仍然可以通过我的 <a href="https://github.com/WincerChan/MyBlog" target="_blank" rel="noopener">MyBlog</a> 仓库查看这些文章。</p>]]></content>
      
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主题 </tag>
            
            <tag> 博客 </tag>
            
            <tag> 字体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 知多少（一）——不常见的数据结构</title>
      <link href="/posts/dbcdebb/"/>
      <url>/posts/dbcdebb/</url>
      
        <content type="html"><![CDATA[<p>近来准备写几篇文章用于介绍 Python 较高级一些的特性，归为一个系列。本文是这个系列的第一篇文章，主要介绍一下内置的一些数据结构。</p><p>对 Pythoner 而言，元组（tuple）、列表（list）、字典（dict）这三个应该最熟悉的数据结构了，恰当使用这三个数据结构的话的确可以应对大部分的使用场合了，但有时因为其它方面的问题（内存占用、插入效率、删除效率等），我们仍有必要学习其它不那么常见的数据结构。</p><a id="more"></a><h2 id="数组"><a href="posts/dbcdebb/#数组" class="headerlink" title="数组"></a>数组</h2><p>初学者可能会认为在 Python 里，列表（list） 就是数组（array），其实不然。数组应当是一系列类型相同的变量的集合，而 Python 中的列表却可以存放任何不同类型的数据。Python 里也是有数组这个概念的，与列表有所不同的是数组里数据的存放方式（类型）并不是 Python 的基础类型（int、float、char）等，而是数字的机器标识（说白了就是和在 C 语言中存储方式一样），也因此，在将数据存入和读取文件时效率会更高一些。</p><p><code>array.array</code> 支持的数据类型包括整数、浮点数、字符三种，其中创建每个数组需要一个类型码（Type code），用以标识在 C 语言中存放怎样的数据类型，比如 <code>array(&#39;l&#39;)</code> 这样创建的就是存放四个字节大小的整数，范围从 - 2^31 到 2^31 - 1（更多的类型码使用 help(array) 查看）。</p><pre><code class="python">from array import arrayfrom reprlib import reprints = array(&#39;l&#39;, (i for i in range(10**7)))&gt;&gt;&gt; repr(ints)&quot;array(&#39;l&#39;, [0, 1, 2, 3, 4, ...])&quot;# write to filewith open(&#39;ints.bin&#39;, &#39;wb&#39;) as fp:    ints.tofile(fp)ints2 = array(&#39;l&#39;)# read from filewith open(&#39;ints.bin&#39;, &#39;wb&#39;) as fp:    ints2.fromfile(fp, 10**7)</code></pre><p>数组支持列表的大部分操作（准确地说是支持所有和可变序列的有关的操作），包括 <code>pop()</code>、<code>insert()</code>、<code>extend()</code> 等。</p><pre><code class="python">&gt;&gt;&gt; len(ints)10000000&gt;&gt;&gt; ints[-1]9999999&gt;&gt;&gt; ints.pop()9999999</code></pre><p>在排序这里与列表有一点小区别，列表支持 <code>list.sort()</code> 这种就地排序的方法，但数组不支持，所以想对数组进行排序的话，得用 <code>sorted</code> 新建一个数组：</p><pre><code class="python">tmp = array(ints.typecode, sorted(ints))</code></pre><h2 id="队列"><a href="posts/dbcdebb/#队列" class="headerlink" title="队列"></a>队列</h2><p>队列的特性是先进先出，虽然我们可以把列表当作队列来使用：<code>append()</code> 来模拟进队列，<code>pop(0)</code> 来模拟出队列：</p><pre><code class="python">class Queue:    def __init__(self, queue):        self.queue = list(queue)    def pop(self):        return self.queue.pop(0)    def push(self, num):        self.queue.append(num)    def __repr__(self):        return &#39;Queue&lt;%s&gt;&#39; % self.queueq = Queue(range(5))&gt;&gt;&gt; qQueue&lt;[0, 1, 2, 3, 4]&gt;&gt;&gt;&gt; q.push(5)&gt;&gt;&gt; qQueue&lt;[1, 2, 3, 4, 5]&gt;&gt;&gt;&gt; q.pop()1</code></pre><p>似乎看上去很完美，但是这种方法的弹出操作是很耗时的，因为删除列表的第一个元素会牵扯到移动列表里的所有元素。</p><p>这里介绍标准库中两种不同的队列：</p><h3 id="双向队列"><a href="posts/dbcdebb/#双向队列" class="headerlink" title="双向队列"></a>双向队列</h3><p><code>collections.deque</code> 类提供了一个双向队列，也就是说 <code>deque</code> 也完全可以栈来使用。它的 <code>append()</code>、<code>appendleft()</code> 和 <code>pop()</code>、<code>popleft()</code> 都是原子操作，这也意味这 <code>deque</code> 是线程安全的。<code>deque</code> 同样实现了所有和可变序列相关的操作。<code>deque</code> 可以接受一个可选参数（<code>maxlen</code>）表示队列可容纳元素的数量：</p><pre><code class="python">from collections import dequedq = deque(range(5), maxlen=5)&gt;&gt;&gt; dqdeque([0, 1, 2, 3, 4])&gt;&gt;&gt; dq.append(5)&gt;&gt;&gt; dqdeque([1, 2, 3, 4, 5])&gt;&gt;&gt; dq.popleft()1&gt;&gt;&gt; dqdeque([2, 3, 4, 5])&gt;&gt;&gt; dq.appendleft(1)deque([1, 2, 3, 4, 5])</code></pre><p>需注意，一旦添加了 <code>maxlen</code> 属性，这个属性就无法修改了。当对一个已满的队列进行添加操作时（第 5 行），另一头的元素会被挤掉。</p><h3 id="单向队列"><a href="posts/dbcdebb/#单向队列" class="headerlink" title="单向队列"></a>单向队列</h3><p>（原谅我想不出一个好名字了，只能用单向队列来和刚刚介绍的双向队列做区分了）。</p><p><code>queue.Queue</code> 类提供的是一个单向的队列，它与上面双向队列最大不同除了它是单向的之外，还有对于队列已经满了或空了的情况下，还要对队列进行添加或删除操作的结果不同：在满员（为空）时，如果还向 <code>Queue</code> 中插入（取出）元素的话，它不会扔掉旧的元素来腾出位置，反而是会锁住——直到另外的线程移除了某个位置，这一特性很适合用做生产者——消费者的模型，尤其是当生产者的生产时间与消费者的消费时间不匹配的情况，比如：生产者的生产时间快于消费者的消费时间，如果采用 <code>deque</code> 的话，就会丢失生产者最早时候生产的数据（反之就会造成消费者从空队列中取出数据的情况）。</p><pre><code class="python">from queue import Queuefrom threading import Threadimport loggingimport timelogging.basicConfig(level=logging.INFO,                    format=(&#39;%(asctime)s %(message)s&#39;))queue = Queue(1)def consumer():    time.sleep(.1)    queue.get()    logging.info(&#39;Consumer got 1&#39;)    queue.get()    logging.info(&#39;Consumer got 2&#39;)def producer():    queue.put(1)    logging.info(&#39;Producer put 1&#39;)    queue.put(2)    logging.info(&#39;Producer put 2&#39;)    thread.join()    logging.info(&#39;Producer done&#39;)thread = Thread(target=consumer)thread.start()producer()&gt;&gt;&gt;2018-08-07 19:56:42,234 Producer put 12018-08-07 19:56:42,335 Consumer got 12018-08-07 19:56:42,335 Producer put 22018-08-07 19:56:42,335 Consumer got 22018-08-07 19:56:42,335 Producer done</code></pre><p>消费者线程先等待了片刻是为了给生产线程留部分时间，使其在消费者从队列获取之前先将两个对象放入队列。然而，这里的缓冲区容量为 1，这就意味着生产线程在放入第一个数据后，会卡在第二个 <code>put</code> 方法那里，必须等待消费线程通过 <code>get</code> 方法把第一个数据消费之后，才能放入第二个对象。</p><h2 id="堆"><a href="posts/dbcdebb/#堆" class="headerlink" title="堆"></a>堆</h2><p>堆的性质是父节点（下标为 k）的值，总是小于（大于）等于其左（下标为 2k + 1）右（下标为 2k + 2）两个子节点的值。堆这种数据结构实际中多用于实现<strong>优先级队列</strong>（在 <code>queue</code> 模块中也有优先级队列的实现：<code>PriorityQueue</code> ）：在队列中，优先级较高的元素<strong>总</strong>排在前面。</p><p><code>heapq</code> 模块可以在标准的列表之中创建堆结构：</p><pre><code class="python">from heapq import heappush, heapify, heappopheap = []heappush(heap, 5)heappush(heap, 3)heappush(heap, 7)heappush(heap, 4)&gt;&gt;&gt; assert heap[0] == min(heap)&gt;&gt;&gt; heappush(heap, 2)&gt;&gt;&gt; heap[2, 3, 7, 5, 4]&gt;&gt;&gt; heappop(heap), heappop(heap), heappop(heap)(2, 3, 4)heap2 = [9, 8, 7, 6, 5, 4]heapify(heap2)&gt;&gt;&gt; heap2[4, 5, 7, 6, 8, 9]</code></pre><p><code>heappush</code> 和 <code>heappop</code> 方法总会保持堆的性质，将数据插入或弹出，<code>heappop</code> 总会将堆中优先级最高的元素弹出。其中 <code>heapify</code> 可在线性时间内将列表转化为堆。</p><h2 id="内存视图"><a href="posts/dbcdebb/#内存视图" class="headerlink" title="内存视图"></a>内存视图</h2><p>内存视图（memoryview）可以在不需要复制内容的前提下，在不同的数据结构之间共享内存。当你需要在内存中处理大量二进制数据时，或者需要反复修改内存中某块数据的内容，内存视图可能会对你有很大帮助：因为在 Python 中，对字符串（str）和字节数组（bytesarray）进行切片都是会造成内存的复制，尤其是当需要对较大的数据进行切片的时候，所耗费的代价将会非常昂贵。</p><pre><code class="python">from time import timedef mv_vs_bytes(factory, name):    for n in (100000, 200000, 300000, 400000):        data = b&#39;x&#39; * n        t0 = time()        b = factory(data)        while b:            b = b[1:]        print(name, n, time() - t0)mv_vs_bytes(lambda x: x, &#39;bytes&#39;)mv_vs_bytes(lambda x: memoryview(x), &#39;memoryview&#39;)&quot;&quot;&quot;output:bytes 100000 0.15474176406860352bytes 200000 0.6353733539581299bytes 300000 1.5503427982330322bytes 400000 2.8593809604644775memoryview 100000 0.008246183395385742memoryview 200000 0.017104148864746094memoryview 300000 0.025980710983276367memoryview 400000 0.03431963920593262&quot;&quot;&quot;</code></pre><p>可以看出，对 <code>bytes</code> 切片的时间复杂度是 O(n^2)，而对 <code>memoryview</code> 切片总能在线性时间内完成。</p><p>当然，由于 <code>bytes</code> 本身是不可变（immutable）的字节序列，如果想对 <code>memoriview</code> 中的数据进行修改的话，就需要用 <code>bytearray</code> 的方式构造 <code>memoryview</code> 对象：</p><pre><code class="python"># readonlyb = b&#39;Hello&#39;mv_b = memoryview(b)assert mv_b.readonly == True&gt;&gt;&gt; mv_b[0] = 73TypeError: cannot modify read-only memory# can writeba = bytearray(b)mv_ba = memoryview(ba)assert mv_ba.readonly == False&gt;&gt;&gt; mv_ba[0] = 73&gt;&gt;&gt; mv_ba.tobytes()b&#39;Iello&#39;</code></pre><p>由于 <code>memoryview</code> 使用了缓冲区协议（协议提供的是 C 语言级别的 API），导致 <code>memoryview</code> 只有在 CPython 中才能发挥它最大的作用。</p><p>本系列全部文章可访问「<a href="../../tags/知多少/">知多少</a>」标签查看。</p><p>参考：</p><ul><li><a href="https://www.oreilly.com/library/view/fluent-python/9781491946237/" target="_blank" rel="noopener">Fluent Python</a></li><li><a href="https://effectivepython.com/" target="_blank" rel="noopener">Effective Python</a></li><li><a href="https://eli.thegreenplace.net/2011/11/28/less-copies-in-python-with-the-buffer-protocol-and-memoryviews" target="_blank" rel="noopener">Less copies in Python with the buffer protocol and memoryviews</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 知多少 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Socket 编写 HTTP 服务器</title>
      <link href="/posts/89381f22/"/>
      <url>/posts/89381f22/</url>
      
        <content type="html"><![CDATA[<p>在大二上《计算机网络》这门课的时候，由于并不是很喜欢这门课的老师，导致我在上课的大部分时间都在摸鱼<del>（啊喂，学校教的哪门课你没在摸鱼啊？）</del>。最近看了《<a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">图解HTTP</a>》这本书，借这本书正好也复习了一下应用层和传输层协议，毕竟现在的 Web 应用几乎都是在应用层的 HTTP 协议运行的，而 HTTP 又是基于传输层的 TCP 协议来实现的。</p><a id="more"></a><p>我一直认为检验学习新知识是否牢靠最好的方法就是写一个小的实例，于是乎，借助于 Socket 模块（仅对 BSD Sockets API 进行封装），我也实现了一个静态的 HTTP 服务器，当然，比标准库提供的 SimpleHTTP 要强一点，因为我编写的支持并发。源码见<a href="https://github.com/WincerChan/Tiny-Http" target="_blank" rel="noopener">这里</a>。</p><h2 id="Socket-服务器"><a href="posts/89381f22/posts/89381f22/#Socket-服务器" class="headerlink" title="Socket 服务器"></a>Socket 服务器</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>HTTP 协议是基于 TCP 协议来实现的，也就是说要实现 HTTP 服务器首先就需要先创建一个 TCP 连接，而一个完整的 TCP 连接是同时需要客户端和服务端的，而客户端和服务端的创建，就需要借助 Socket（套接字）了。</p><p>通常创建一个 Socket 需要为其指定地址族（包括本机、IPV4、IPV6）、套接字类型（流式、数据报式，分别对应 TCP 和 UDP）</p><pre><code class="python">from socket import AF_INET, SOCK_STREAM, socket# create a tcp socketsock = socket(AF_INET,SOCK_STREAM)# equal tosock = socket()</code></pre><p>随后需要为该 <code>socket</code> 绑定一个 IP 地址和端口，并开始监听该地址（listen 可传入参数，表示排队连接的数量）：</p><pre><code class="python">sock.bind((&#39;0.0.0.0&#39;, 8888))sock.listen()</code></pre><p>随后，就可以等待客户端发起连接请求了：</p><pre><code class="python">conn, addr = socket.accept()</code></pre><p>随后该连接会阻塞，直到 accept 到客户端的连接之后（客户端可使用 <code>telnet 0.0.0.0 8888</code> 来连接），随后程序就会继续运行，这时就可以通过 socket 连接来传输数据了，在 telnet 输入任何字符，随后在客户端接收，再响应请求：</p><pre><code class="python"># accept 10 bytes dataconn.recv(10)# send responseconn.send(b&#39;hello world&#39;)</code></pre><h3 id="封装"><a href="posts/89381f22/#封装" class="headerlink" title="封装"></a>封装</h3><p>我们后续编写 HTTP 服务器仍是基于这一套流程，只是在客户端请求和服务端应答的内容不一样，故而封装成一个类，方便继承，以下为一个回显服务端，从客户端接收到的任何消息都会将其返回：</p><pre><code class="python">from socket import AF_INET, SOCK_STREAM, socketclass EchoServer:    def __init__(self, port=8888, addr=&#39;0.0.0.0&#39;, family=AF_INET,                 type_=SOCK_STREAM, backlog=0, init=True):        self.addr = addr        self.port = port        self.family = family        self.type_ = type_        self.backlog = backlog    def _echo(self, sock: socket):        while True:            try:                req_head = sock.recv(1)            except BrokenPipeError:                break            else:                if not req_head:                    break                sock.send(req_head)    def _run(self):        self.sock.listen(self.backlog)        while True:            sock, addr = self.sock.accept()            print(&#39;Connect by {} Port {}&#39;.format(*addr))            self._echo(sock)    def __call__(self):        self.sock = socket(self.family, self.type_)        self.sock.bind((self.addr, self.port))        print(&#39;Listen in %s port.&#39; % self.port)        self._run()</code></pre><h3 id="测试用例"><a href="posts/89381f22/#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><pre><code class="python">&gt;&gt;&gt; serve = EchoServer()&gt;&gt;&gt; serve()&quot;&quot;&quot;telnet 0.0.0.0 8888Trying 0.0.0.0...Connected to 0.0.0.0.Escape character is &#39;^]&#39;.HelloHelloI&#39;m Wincer.I&#39;m Wincer.&quot;&quot;&quot;Listen in 8888 port.Connect by 127.0.0.1 Port 45186...</code></pre><h2 id="HTTP-服务器"><a href="posts/89381f22/#HTTP-服务器" class="headerlink" title="HTTP 服务器"></a>HTTP 服务器</h2><h3 id="HTTP-报文"><a href="posts/89381f22/#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p>那么有了 TCP 连接，该怎么实现 HTTP 协议呢，其实很简单，HTTP 协议只是在传输的内容上做了规定：满足「报文首部」、「空行」、「报文主体」，这样通过服务器发出去就算是一个 HTTP 报文了，不信？试试就知道了。</p><p>将上面的 EchoServer 中的 <code>_echo</code> 方法修改一下，让其返回以下数据：</p><pre><code class="python">data = &quot;&quot;&quot;HTTP/1.1 200 OKContent-Length: 11Hello World&quot;&quot;&quot;class EchoServer:    def _echo(self, sock):        try:            req_head = sock.recv(1)        except BrokenPiperError:            return         else:            if not req_head:                return            # 注意这里必须要将字符串编码成 bytes 才能发送。        sock.send(data.encode(&#39;utf-8&#39;))        sock.close()&gt;&gt;&gt; serve = EchoServer(8888)&gt;&gt;&gt; serve()Listen in 8888 port.</code></pre><p>咳咳，准备好了吗，打开浏览器，输入 <code>http://0.0.0.0:8888</code>，如无意外，你就可以在屏幕上看见 <code>Hello World</code> 了。</p><p>这就算最「小」的 HTTP 服务器了，不管向它发送什么请求，不管请求的是什么，它都会返回 <code>Hello World</code>：</p><pre><code class="bash">curl http://0.0.0.0:8888Hello Worldcurl http://0.0.0.0:8889/\?testHello Worldcurl -X OPTIONS http://0.0.0.0:8889/\?testHello Worldcurl -X POST http://0.0.0.0:8889/\?test\&amp;param\=blockHello World</code></pre><p>这是因为我们还没有对请求报文首部进行分析，从而根据请求路径的不同或者请求方式的不同来返回相应的数据。</p><h3 id="响应请求"><a href="posts/89381f22/#响应请求" class="headerlink" title="响应请求"></a>响应请求</h3><p>既然要做一个静态的服务器，最少也应该分析 <code>GET</code> 请求，根据请求的 URL 作出响应，那么就需要增加额外的函数了：</p><pre><code class="python">class HttpServer(EchoServer):    def _echo(self, sock: socket):        try:            req_head = sock.recv(1024)        except BrokenPipeError:            return        else:            if not req_head:                return            head = self._get_head(req_head)            sock.send(head.encode(&#39;utf-8&#39;))            self._send_body(sock)            logging.info(&#39;HTTP/1.1 %s GET %s&#39; % (self.status, Signal.path))        sock.close()</code></pre><p>我这里（在 <code>_echo</code> 中）增加了两个函数：<code>_get_head</code> 和 <code>_send_body</code>。作用分别是根据客户端的请求报文的首部来生成相应的服务端响应报文首部和根据客户端的请求 URL 发送响应的报文主体内容，比如，请求首部：</p><pre><code class="http">GET /index.html HTTP/1.1HOST: 0.0.0.0:8888USER-AGENT: curl/7.61.0Accept: */*</code></pre><p>响应首部（可将请求的资源以 <code>rb</code> 模式打开，并读入内存，再作为响应报文主体发送）：</p><pre><code class="http">HTTP/1.1 200Content-Length: 11Content-Type: text/html; charset=utf-8Date: Thu, 02 Aug 2018 03:58:09 GMTServer: TinyHttpHello World</code></pre><p>有关这两个函数的具体实现，可以参考我这部分的<a href="https://github.com/WincerChan/Tiny-Http/blob/master/tinyhttp/http/server.py#L49-L70" target="_blank" rel="noopener">源码</a>。</p><h2 id="并发请求优化"><a href="posts/89381f22/#并发请求优化" class="headerlink" title="并发请求优化"></a>并发请求优化</h2><p>我们的服务器现在已经可以根据 GET 请求的 URL 来返回相应的报文了，很好，但现在的服务器不支持并发请求，也就是说必须先对前一个请求作出完整的响应，并将响应发送出去之后，才能处理下一个请求，造成这种后果最重要的一点原因就是：<code>socket.recv()</code> 和 <code>socket.send()</code> 都是阻塞型 I/O 函数，也就是说，CPU 会一直等待这两个函数执行完成才继续执行后面的代码。</p><p>虽然在本地局域网内，作出大部分响应的时间都很快（毫秒级别），但我们仍有必要对阻塞型 I/O 函数进行优化，优化方法有两种：</p><ol><li>在单独的线程中运行该阻塞型操作</li><li>把该阻塞调用转化为非阻塞的异步调用使用</li></ol><p>其中第一个方法很简单，借助 <code>threading</code> 模块即可实现，重写一下 <code>_run</code> 方法：</p><pre><code class="python">class ThreadHttpServer(HttpServer):    def _run(self):        self.sock.listen(self.backlog)        while True:            sock, addr = self.sock.accept()            Thread(target=self._echo, args=(sock,)).start()</code></pre><p>而第二个方法就需要借助 Asyncio 这个库了（由于借助了 Asyncio 这个库，要求 Python 版本为 3.5+），该库重写了标准库 socket 中的阻塞 I/O 函数，将其改为了非阻塞形式的异步调用，由于该方法改动的地方太大，就不贴完整的代码了，可移步至这部分的<a href="https://github.com/WincerChan/Tiny-Http/blob/master/tinyhttp/async/asyncserver.py" target="_blank" rel="noopener">源码</a>。</p><h2 id="薛定谔的-BUG"><a href="posts/89381f22/#薛定谔的-BUG" class="headerlink" title="薛定谔的 BUG"></a>薛定谔的 BUG</h2><p>同我在<a href="../8575e868/#%E5%AE%9E%E7%8E%B0">之前一篇博文</a>提到的类似，这次同样遇上了一些薛定谔的 BUG：</p><h3 id="大文件传输"><a href="posts/89381f22/#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h3><p>当以 <code>open</code> 函数打开某一个文件时，会把这个文件的内容读入到内存中，如果只是普通的文本或者图片倒是不会出现什么问题，但是一旦读入的文件过大（比如我就喜欢在电脑开启静态 HTTP 服务，然后在局域网内其它的设备打开共享的视频来播放），就会出现两个情况：</p><ol><li>占用的内存空间过大，程序 gg；</li><li>成功读入内存，但花了很多时间读入内存，服务端又花了很多时间发送，客户端又花了很多时间接收；</li></ol><p>于是乎，大名鼎鼎的「generator（生成器）」终于派上了用场。将 <code>_get_body</code> 函数（请求的文件内容）中的 <code>open</code> 函数作为一个生成器，每读取一行（<code>readline()</code>）就 yield 一次，在 <code>_send_body</code> 函数中不断对 <code>_get_body()</code> 返回的数据进行迭代发送，这样既不会一次性全部读入内存，造成内存空间不足、又不会花费过多的时间在 I/O 上，一举两得，当然，为此你需要加上一个 <code>Content-Lenght</code> 的首部，用以告诉客户端什么时候接收完毕。</p><h3 id="目录与文件"><a href="posts/89381f22/#目录与文件" class="headerlink" title="目录与文件"></a>目录与文件</h3><p>当请求的是目录时，URL 最尾端应当为 <code>/</code>，这时返回的应该是该目录下的 <code>index.html</code> 文件，如没有的话就返回该目录下的文件列表（同样的，列表中的目录应当以 <code>/</code> 在末尾标识），如果点击了该目录下的子目录，则应递归的显示子目录。</p><p>但当以 <code>os.listdir</code> 列出文件列表时，并不会显式的将目录以 <code>/</code> 标识，而仍需我们手动判断，当请求同名目录但末尾没有 <code>/</code> 时，应当将状态码设置为 301，并在响应头部加上 <code>Location: https://localhost:8888/xxx/</code> 用以显式的指向目录。</p><h2 id="结语"><a href="posts/89381f22/#结语" class="headerlink" title="结语"></a>结语</h2><p>其实这个服务器在结构上并不复杂，甚至可以说简单，就是依据 Socket 建立 TCP 连接，再分析请求首部得到的 URL，用 <code>rb</code> 模式加载并作为响应主体返回，但也确实让我学习到了不少：比如说「面向对象」范式的好处，即在构建以 <code>TCP-&gt;HTTP-&gt;ThreadHTTP、AsyncHTTP</code> 这样自顶向下的结构时，继承（<code>ThreadHTTP</code> 继承于 <code>HTTP</code>，而 <code>HTTP</code> 又继承于 <code>TCP</code>）可以大大的减少代码量和提高可重用性；再比如说生成器，即惰性求值的好处（节省内存），这好像还是我第一次正式在代码中用到生成器。</p><p>而这两点，想来只有自己在生产代码中遇到过，才能切实体会到好处。</p>]]></content>
      
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
            <tag> 异步 </tag>
            
            <tag> HTTP </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hitokoto（一言）API 2.0 正式上线</title>
      <link href="/posts/a5c39267/"/>
      <url>/posts/a5c39267/</url>
      
        <content type="html"><![CDATA[<p>去年夏天的时候，用 Flask 开发了一个<a href="../f6e1eb2a/">简易版的一言</a>，算是最初的 beta 版，部署在了 Heroku 上面（那时我还没购买服务器），由于 Heroku 免费版有时间池的限制，在我购置了服务器后就重新用 Go 重写了一下<a href="../b3085a7/#搭建-API">部署在自己的服务器上</a>，算是 1.0 版，这两天又重新拾坑，开发出了 2.0 版本。</p><a id="more"></a><h2 id="前言"><a href="posts/a5c39267/#前言" class="headerlink" title="前言"></a>前言</h2><p>在 1.0 版本使用了较长的时间后，基于以下考量，我还是重构了部分代码：</p><ol><li>收录一言数太少：我没事的时候就喜欢刷新玩，经常发现眼熟的，毕竟也就不到一千条；</li><li>性能：由于使用的是 SQLite，在每秒请求数在 1000 的时候就 GG 了；</li><li>查询参数：返回不超过查询长度参数的一言，但翻了一大堆 API，都并没有提供这个功能；</li></ol><p>于是乎，本着「生命不死，折腾不止」的态度，2.0 版本诞生了。</p><blockquote><p>本 API 的<a href="https://github.com/WincerChan/Hitokoto" target="_blank" rel="noopener">源码</a>已开源至 GitHub，如有需要的可自行搭建。</p></blockquote><p>以下是 2.0 版本的更新日志：</p><h2 id="数量问题"><a href="posts/a5c39267/#数量问题" class="headerlink" title="数量问题"></a>数量问题</h2><p>爬取数据时采用了异步爬虫，解决了 1.0 版本爬取时效率低下的问题，同时选取了 xxhash 作为散列函数，将一言主体 hash 后，得到的 64bit 的无符号整数作为主键，这样如果爬取到了重复的一言也不会插入数据库中。</p><p>得益于异步爬虫的高效率，在很短的时间内，爬取到了足够的一言数。目前，数据库内共有 <code>15371</code> 条一言。以后数量还会不断地增加。<a href="https://github.com/WincerChan/Hitokoto-Spider" target="_blank" rel="noopener">爬虫程序</a>已托管至 GitHub。</p><h2 id="性能问题"><a href="posts/a5c39267/#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>数据库更换成了 MySQL，以承受高并发访问，以下为建表语句：</p><pre><code class="mysql">+----------+---------------------+------+-----+---------+-------+| Field    | Type                | Null | Key | Default | Extra |+----------+---------------------+------+-----+---------+-------+| id       | bigint(20) unsigned | NO   | PRI | NULL    |       || hitokoto | varchar(300)        | NO   |     | NULL    |       || source   | varchar(64)         | NO   |     | NULL    |       || origin   | varchar(12)         | NO   |     | NULL    |       |+----------+---------------------+------+-----+---------+-------+</code></pre><h2 id="参数问题"><a href="posts/a5c39267/#参数问题" class="headerlink" title="参数问题"></a>参数问题</h2><p>2.0 版本共包含以下请求参数：</p><h3 id="编码格式"><a href="posts/a5c39267/#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><p>格式为 <code>encode=</code>，包含以下四个参数值：</p><ul><li>js：JavaScript 脚本，将一言插入 HTML 中第一次出现 <code>class = &#39;hitokoto&#39;</code> 的标签中</li><li>json：JSON 格式的字符串，包含主体（hitokoto），出处（source）</li><li>text：一言句子的主体</li><li>默认为：<code>×××××——「×××」</code>，即主体 + 出处</li></ul><h3 id="字符集"><a href="posts/a5c39267/#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>格式为 <code>charset=</code>，包含以下两个参数值：</p><ul><li>utf-8：在 Header 中的 <code>content-type</code> 字段添加 <code>charset=utf-8</code></li><li>gbk：同上</li></ul><h3 id="长度"><a href="posts/a5c39267/#长度" class="headerlink" title="长度"></a>长度</h3><p>格式为 <code>length=</code>，会随机返回一条不超过这个查询长度的语句。</p><h3 id="回调"><a href="posts/a5c39267/#回调" class="headerlink" title="回调"></a>回调</h3><p>格式为 <code>callback=</code>，会根据回调参数的值返回对应的函数调用，其中函数的参数为一个字典，key 分别为 <code>hitokoto</code> 和 <code>source</code>。</p><blockquote><p><strong>注意：callback 参数会覆盖掉 encode 参数</strong></p></blockquote><h2 id="使用示例"><a href="posts/a5c39267/#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>调用地址：<code>https://api.itswincer.com/hitokoto/v2/</code></p><p>例如，我想请求一个长度不超过 10 的一言，并以 JSON 格式返回：</p><pre><code class="bash">curl &#39;https://api.itswincer.com/hitokoto/v2/?encode=json&amp;length=10&#39;{&quot;hitokoto&quot;:&quot;(눈_눈)&quot;,&quot;source&quot;:&quot;进击的巨人&quot;}</code></pre><p>如果想在自己的网页使用的话，可以采取以下两种方法：</p><h3 id="JS-方法"><a href="posts/a5c39267/#JS-方法" class="headerlink" title="JS 方法"></a>JS 方法</h3><p>只需要在想要展示的标签加上 <code>class=&#39;hitokoto&#39;</code> 属性，随后在任何地方加上：</p><pre><code class="html">&lt;script src=&quot;https://api.itswincer.com/hitokoto/v2/?encode=js&quot;&gt;&lt;/script&gt;</code></pre><p>插入页面的显示结果是：××××××× ——「×××」形式。</p><p>展示结果见侧栏。</p><h3 id="回调方法"><a href="posts/a5c39267/#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><p>如果对 <code>encode=js</code> 返回的格式不满意，可自行定义页面展示的格式：比如以下代码仅展示一言的主体部分：</p><p>定义标签和函数：</p><pre><code class="html">&lt;p class=&quot;hitokoto&quot;&gt;&lt;/p&gt;&lt;script&gt;    // 定义回调函数名 showHitokoto    function showHitokoto(data){        // 比如我只想展示一言主体部分        var hitokoto = data.hitokoto;        // 插入 class=hitokoto 的标签        var dom = document.querySelector(&#39;.hitokoto&#39;);        Array.isArray(dom)?dom[0].innerText=hitokoto:dom.innerText=hitokoto;    }&lt;/script&gt;</code></pre><p>随后将请求地址加上参数 <code>callback=showHitokoto</code>：</p><pre><code class="html">&lt;script src=&quot;https://api.itswincer.com/hitokoto/v2/?callback=showHitokoto&quot;&gt;&lt;/script&gt;</code></pre><p>以上示例将会在 HTML 标签首个包含 <code>class=&#39;hitokoto&#39;</code> 的标签内部插入仅包含一言主体的部分。</p><h2 id="尾巴"><a href="posts/a5c39267/#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>你看到某句熟悉的一言从屏幕上显示的时候，勾起了之前第一次看到这句话时或感动、或开心、或难过的回忆，而某个陌生人也会因此和你一样陷入属于他的短暂回忆——想到这些不是很快乐吗？而我想那个陌生人一定也正想着同样的事情。我一直这样觉得。</p><p>而这，应当就是文字赋予一言的最大作用了。</p>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一言 </tag>
            
            <tag> API </tag>
            
            <tag> Hitokoto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客访问统计报告（2017.6.20-2018.7.4）</title>
      <link href="/posts/790223d2/"/>
      <url>/posts/790223d2/</url>
      
        <content type="html"><![CDATA[<p>我的博客<a href="../4a17b156/">建站至今</a>也一年有余了，本想着在一周年（今年 5 月初）之际写一篇文章纪念一下，顺便公布一下本博客在这一年的访问情况，可当时发现统计记录还没有满一年（我是在 2017 年 6 月底才开始使用的 Google 分析），于是就想干脆等到 6 月底再写。而前段时间又忙于准备期末考试，直到昨天放假回家，似乎才有时间写这一篇文章。</p><a id="more"></a><h2 id="前言"><a href="posts/790223d2/#前言" class="headerlink" title="前言"></a>前言</h2><p>首先我并不确定 Google 分析的准确性有多高，因为当我查看 Cloudflare 自带的分析功能时，得到的数据与 Google 分析的有很大很大的差别。以近一周的数据做对比：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1sonpB8mWBuNkSndV763sApXaO.png" alt="左 Google，右 Cloudflare" title="左 Google，右 Cloudflare"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">左 Google，右 Cloudflare</figure></p><p>虽说 Cloudflare 统计了所有的 HTTP 请求，但<strong>我博客实则只有 html 页面才会走 Cloudflare 的线路</strong>，其它的静态资源我都放在 CDN 了。而 Cloudflare 对于近一周访问 html 页面给出的数据是占总请求数的 48%——约 3411 次，这应该是与 Google 的页面浏览量（540）作为对比（加上其余两个子网站的浏览量分别为 121、4），可以看到仍然有将近 7 倍的差距，用户数也有近 5 倍差距——我确实想不出一个合理的解释（根据 Cloudflare 给出的解释，可能是由于某些网络爬虫，故与基于 Javascript 的统计工具来说有较大出入）。</p><p>但 Cloudflare 无法给出像 Google 分析那样包括平均会话、每次会话浏览数、跳出率等等指标，故本篇博客还是选取 Google 分析的数据进行分析。</p><h2 id="受众群体"><a href="posts/790223d2/#受众群体" class="headerlink" title="受众群体"></a>受众群体</h2><p>在过去的一年零两周内，本博客的基本访问情况如下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1RzYAKeOSBuNjy0Fd762DnVXaB.png" alt="概览"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">概览</figure></p><p>这期间，本博客一共迎来了 5,446 位用户，他们一共产生了 10,508 次会话以及 19,989 次浏览。平均每天 14 位用户、28 次会话、53 次浏览。</p><p>图表中有一个较为凸出的高峰（5 月 29 日），原因是我在 V2EX 发了帖介绍自己写的一个<a href="https://www.v2ex.com/t/458433#reply23" target="_blank" rel="noopener">表情包生成工具</a>，这个工具中算是间接性的把用户引导至本博客了。</p><h2 id="流量获取"><a href="posts/790223d2/#流量获取" class="headerlink" title="流量获取"></a>流量获取</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1.vYJKXuWBuNjSszb763S7FXaU.png" alt="流量"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">流量</figure></p><p>其中流量获取的来源主要是三部分：Referral（引荐）、Organic Search（搜索引擎）、Direct（直连）。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1VOjDtpooBKNjSZPh7632CXXaY.png" alt="对比"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">对比</figure></p><p>其中 Google 的流量占了大多数：36.80%，其次是本博客自身的引荐；本博客并没有添加百度站长的信息，并且主动屏蔽了百度蜘蛛的爬取，故并没有来自百度的流量。</p><p>现在的 Google 分析为了保护用户隐私，已经无法显示用户查询的关键词了。</p><h2 id="地理位置"><a href="posts/790223d2/#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1BiGLB2iSBuNkSnhJ762DcpXak.png" alt="地理"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">地理</figure></p><p>毫无疑问，本博客的主要流量都来自于中国大陆，不过令我感到奇怪的是第二名是美国。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1jDv.Kh1YBuNjy1zc762NcXXaZ.png" alt="语言"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">语言</figure></p><p>在操作系统语言中：</p><p>简体中文（zh-CN + zh-cn）占了 72.27%，较地理为中国大陆的 68.93% 多出了 3.34 个百分点；</p><p>英语（en-US + en-us）占了 16.91%，较地理为美国的 11.06% 也多出了 5.85 个百分点；</p><p>也就是说，并非只有美国地区的人才会使用英文，也并非中国地区的人才会使用中文。</p><h2 id="设备信息"><a href="posts/790223d2/#设备信息" class="headerlink" title="设备信息"></a>设备信息</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1MG58jNtnkeRjSZSg760AuXXa4.png" alt="浏览器"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">浏览器</figure></p><p>首先看看浏览器的占用，由于本博客的类型更偏技术一些，故 Chrome、Safari、Firefox 的使用占据前三甲，其中 IE 的份额不足 0.4%，这意味着我并不需要照顾 IE 的用户，可以尽情使用各种新技术。</p><p>第四的 Android Webview 应该是指 App（QQ、微信） 内置的浏览器。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1koW2tOMnBKNjSZFC7600KFXaT.png" alt="操作系统"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">操作系统</figure></p><p>操作系统毫无疑问是以 Windows 独占鳌头，其次是 Linux，我一直使用 Manjaro Linux 作为日常开发，比 Windows 方便许多，也没有 Windows 那么多 Bug，由于娱乐方式的缺乏，在 Linux 下开发也会更加专注。</p><h2 id="浏览页面"><a href="posts/790223d2/#浏览页面" class="headerlink" title="浏览页面"></a>浏览页面</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1GsLSKk9WBuNjSspe761z5VXal.png" alt="页面浏览"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">页面浏览</figure></p><p>在本站可访问页面中（仅统计文章页面），浏览量的前六名分别是：</p><ol><li><a href="/posts/ad42f575/">Linux 与 Windows 10 用 GRUB 引导教程</a></li><li><a href="/posts/cfd78fa9/">解除百度云下载限速</a></li><li><a href="/posts/2aa541e6/">Spacemacs 生存指北</a></li><li><a href="/posts/bf0413ac/">Nextcloud 搭建私人云服务教程</a></li><li><a href="/posts/72171293/">QQ 音乐外链解析</a></li><li><a href="/posts/8575e868/">Sorry，会写代码真的能为所欲为</a></li></ol><p>（唉，最满意的几篇文章浏览量反倒是挺低的，心情复杂.jpg。）</p><h2 id="后记"><a href="posts/790223d2/#后记" class="headerlink" title="后记"></a>后记</h2><p>自本博客运营至今共发布了 53 篇文章，其中自 17 年 9 月以来，发文的频率明显降低：首 4 个月发了 33 篇文章，17 年 9 月至今却只发了 20 篇。一方面是刚建站的时候事比较多；另一方面是相较于博客数量来说，更开始注重博客质量了。</p><p>最初我选择运营独立博客，并非想从中得到什么实质性的好处，只是作为一种兴趣。而如今在快餐时代坚持写独立文章的人越来越少，这也无可厚非，毕竟短期内看不到结果的话，有些人就无法坚持了。我周围的人似乎对此（我写博客这件事）也表示不太理解，但我还是会一直做下去。我一直认为，只要能长期的投入一件事中，最终一定能从中获取到乐趣和满足感。</p><p>我就是如此。</p>]]></content>
      
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Google-Analytics </tag>
            
            <tag> 访问统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用持续集成（CI）开发项目</title>
      <link href="/posts/f011ea9c/"/>
      <url>/posts/f011ea9c/</url>
      
        <content type="html"><![CDATA[<p>我的博客在建站后不久就使用了 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 自动部署服务，即我只需要将修改的源码推送至 GitHub，Travis CI 会自动将我提交的代码拉取，在 Travis CI 端生成静态文件后，同步至我的服务器，这样可以减少一些麻烦的步骤：可以直接在 GitHub 端修改代码；不用等待生成静态文件、压缩静态文件的时间。<a id="more"></a></p><h2 id="Circle-CI"><a href="posts/f011ea9c/#Circle-CI" class="headerlink" title="Circle CI"></a>Circle CI</h2><p>虽然使用 Travis CI 是能简化部分开发流程，但这货和 GitHub 是一对一的，只支持在 GitHub 托管的项目，并不支持 Bitbucket 和 GitLab，而 GitHub 免费版在私人仓库这一方面是比不上 Bitbucket 和 GitLab 的（虽然我是学生，可以使用 GitHub 私人仓库，可我也不一直是学生呀），同时支持 Bitbucket 的和 GitHub 私人仓库的 CI 工具（自建的除外）好像真的也就 <a href="https://circleci.com/" target="_blank" rel="noopener">CircleCI</a> 了，这里之所以没有考虑 GitLab 是因为 GitLab 自带有 CI/CD，而且这家公司给我的印象实在不太好（包括之前的删库事件，以及莫名奇妙的 Bug）。</p><p>在了解 CircleCI 后发现比 Travis CI 真是强不少（CircleCI 是基于 Docker 和 Workflows 设定模式的），不过在网上并没有很完善的中文教程<del>（虽然官方英文文档已经很完善了）</del>。所以如果你懒得翻官方文档的话，继续往下看我这篇文章就好了🤓。</p><h2 id="选择仓库"><a href="posts/f011ea9c/#选择仓库" class="headerlink" title="选择仓库"></a>选择仓库</h2><p>CircleCI 支持 GitHub 和 Bitbucket 帐号的登录，授权登录完成后，就可以添加 Projects 了，支持 GitHub 和 Bitbucket 的公有及私有仓库。这里以我的 <a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">Meme-generator</a> 仓库为例。</p><p>选完仓库后，就可以开始配置 CircleCI 了。</p><h2 id="准备工作"><a href="posts/f011ea9c/#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="添加-SSH-密钥"><a href="posts/f011ea9c/#添加-SSH-密钥" class="headerlink" title="添加 SSH 密钥"></a>添加 SSH 密钥</h3><p><a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">Meme-generator</a> 仓库用到 SSH 密钥的地方有两处：</p><ol><li>从 GitHub 克隆仓库</li><li>将编译后的静态文件推送至我的服务器</li></ol><p>如果你是用来推送至 GitHub 的话，可以直接用 GitHub 提供为该仓库提供的 Token 密钥，第一点也可以使用 HTTPS 方式克隆，就可以省去添加 SSH 密钥这个步骤。</p><p>点击 CircleCI 个人主页的 JOBS 菜单项，随后点击仓库名称右边的齿轮按钮 -&gt; 点击 <code>SSH Permissions</code> -&gt; 点击蓝色的 <code>Add SSH Key</code> 按钮，将<strong>私钥</strong>（看清楚了，是私钥）粘贴进去（超级良心有木有啊，比 Travis CI 将私钥加密上传这种土办法不知道高到哪里去了）。</p><h3 id="添加-IP-至-known-hosts"><a href="posts/f011ea9c/#添加-IP-至-known-hosts" class="headerlink" title="添加 IP 至 known_hosts"></a>添加 IP 至 known_hosts</h3><p>添加 SSH 密钥后，还需要将服务器的 IP 添加至 known_hosts 列表，否则每次部署的时候都会让你确认以下消息：</p><pre><code class="bash">The authenticity of host &#39;××.×××.×××.×××&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:7hkfahfla8VeiuyF/TLHKfhakgcJ0sHjaLxDyIKlfhak9fuaofoa.Are you sure you want to continue connecting (yes/no)?</code></pre><p>同 Travis CI 类似，CircleCI 在运行的过程中也是不接受命令行输入的（当然运行完成后就更不行了），所以我们需要提前将 IP 写入 known_hosts（在 CircleCI 中如何做？继续往后看）：</p><pre><code class="bash">ssh-keyscan $SSH_IP &gt;&gt; ~/.ssh/known_hosts</code></pre><p>在该仓库的管理页面中的 <code>Environment Variables</code> 选项卡中添加 SSH_IP 的环境变量。</p><h2 id="配置文件"><a href="posts/f011ea9c/#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="简单的例子"><a href="posts/f011ea9c/#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><p>由于我的配置文件太过长了，先以一个简化版为例：</p><pre><code class="yaml">version: 2jobs:  build:    docker:      - image: circleci/node:10.4.0    steps:      - checkout      - run:          name: Install Dependence          command: |            yarn install &amp;&amp; yarn build      - run:            name: Deploy            command: |              echo &quot;Denpendence installed.&quot;</code></pre><p>首先指明 CircleCI 的版本号——2.0（1.0 在 18 年 9 月之后就停止支持了）。</p><p>其次，为 Docker 指定 image（<a href="https://circleci.com/docs/2.0/circleci-images/" target="_blank" rel="noopener">这是</a>官方已经构建完成的镜像列表），可以指定多个 image。先前提到过，CircleCI 并不默认像 Travis CI 那样提供 Linux 虚拟机镜像，推荐使用的是 Docker（当然你也可以指定工作方式为 Machine），这是官方针对 Docker 和 Machine 的<a href="https://circleci.com/docs/2.0/executor-types/#overview" target="_blank" rel="noopener">对比报告</a>。</p><p>随后在 <code>steps</code> 里面是需要运行的指令：</p><ol><li><code>checkout</code> 是一个用于检查配置路径的源代码的特殊步骤，并可以通过 SSH 来 clone 远程仓库的代码（如果你已经添加了 SSH 私钥的话，不然就只好手动 clone 了），详解见<a href="https://circleci.com/docs/2.0/configuration-reference/#checkout" target="_blank" rel="noopener">官方文档</a></li><li><code>run:</code> 后面接的是 bash 命令，<code>name</code> 该任务的名称，<code>command</code> 为具体 bash 的指令</li></ol><h3 id="安装额外命令"><a href="posts/f011ea9c/#安装额外命令" class="headerlink" title="安装额外命令"></a>安装额外命令</h3><p>需要注意的是，如果你需要将生成的静态文件同步至服务器所用的 <code>rsync</code> 命令是没有被安装的，只有<a href="https://circleci.com/docs/2.0/circleci-images/#pre-installed-tools" target="_blank" rel="noopener">这些命令</a>是被安装在所有镜像中的。</p><p>docker 镜像预装的系统是 Ubuntu，可采取 <code>apt-get</code> 命令来安装需要的软件包：</p><pre><code class="yaml">run:   name: Update System  command: |    sudo apt-get update &amp;&amp; sudo apt-get install rsync</code></pre><h3 id="设置缓存"><a href="posts/f011ea9c/#设置缓存" class="headerlink" title="设置缓存"></a>设置缓存</h3><p>CircleCI 建议的 Workflows 中建议将整个工作流分割成不同的子作业，比如说以 Yarn 项目为例，可以分成 <code>build</code> 和 <code>deploy</code> 两个流程。其中 <code>build</code> 用以安装依赖和生成待部署的静态文件；<code>deploy</code> 用以将生成的静态文件部署至服务器。</p><p>可以看出，静态文件是横跨两个作业的，所以我们需要将包含静态文件的文件夹缓存下来（当然你也可以选择不使用 Workflows，这样就只需创建一个工作就好了），在 <code>build</code> 工作中缓存采取如下命令：</p><pre><code class="yaml">steps:  - restore_cache:    keys:      - build-v1-{{ checksum "package.json" }}    paths:      - &quot;build&quot;</code></pre><p>以上命令是将 <code>build</code> 文件夹以 <code>key-value</code> 形式缓存，其中 <code>key</code> 选择的是 <code>package.json</code> 的哈希值。这里的文件名最好选择仓库自带的文件。更多 <code>key</code> 的形式可以参考<a href="https://circleci.com/docs/2.0/caching/#using-keys-and-templates" target="_blank" rel="noopener">这里</a>。</p><p>在 <code>deploy</code> 工作中恢复缓存采取以下命令：</p><pre><code class="yaml">steps:  - checkout  - restore_cache:    keys:      - meme-v1-{{ checksum "package.json" }}</code></pre><p>注意在 <code>restore_cache</code> 之前一定要有 <code>checkout</code> 命令。</p><h3 id="完整的示例"><a href="posts/f011ea9c/#完整的示例" class="headerlink" title="完整的示例"></a>完整的示例</h3><p>直接贴 <a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">Meme-generator</a> 项目的配置代码了：<br><iframe style="height: 0;" frameborder="0" name="WincerChan" id="displayGist" width="100%" data-src="https://blog.itswincer.com/gist/v1/?user=WincerChan&gist=04b5e1ee8a1fbc8bc2e078d2c354bd7b"></iframe><button class="load_gist" onclick="let frame = document.querySelector('#displayGist');frame.src=''+frame.getAttribute('data-src')">Click me to load GIST</button></p><p>每次构建完成后，commits 列表的画风就变成这样了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858045/blog/ci_project/circleci_construction.png" alt="CircleCI 构建"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">CircleCI 构建</figure></p><p>点击 Details 就会显示每次构建的详细过程。</p><h2 id="后记"><a href="posts/f011ea9c/#后记" class="headerlink" title="后记"></a>后记</h2><p>虽然本文名为「使用持续集成（CI）开发项目」，但实际却好像只介绍了 CircleCI，当然我的意思不是钦定 CircleCI 作为最好的持续集成系统，我没有说 CircleCI 是最好的持续集成系统，没有任何这个意思。但你一定要问我为什么选 CircleCI，它现在对 Bitbucket 和 GitHub 的私人仓库支持最完善，我怎么能不支持它呢？</p><p>参考：</p><ul><li><a href="https://circleci.com/docs/2.0/" target="_blank" rel="noopener">2.0 Docs</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI </tag>
            
            <tag> 持续集成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorry，会写代码真的能为所欲为</title>
      <link href="/posts/8575e868/"/>
      <url>/posts/8575e868/</url>
      
        <content type="html"><![CDATA[<p>前一段时间「这个仇我先记下了」的表情包突然火了，导致我也萌生了自己写一个表情包生成工具的想法，毕竟我是重度表情包玩家😌。其实之前我就很喜欢做表情包，不过是用的 PS 等软件，有些麻烦，而且改 GIF 也不太方便。</p><p>于是乎，我决定也蹭一波热度，也写了一个，最初是只有「记仇」这个静态表情包的，现在加上了王境泽、为所欲为、打工是不可能打工的等等动图，模板后续还会添加，如果有好的素材可以私我。<a id="more"></a></p><h2 id="思路"><a href="posts/8575e868/#思路" class="headerlink" title="思路"></a>思路</h2><p>当然网上也有一些表情包生成器，比如「<a href="https://github.com/xtyxtyx/sorry" target="_blank" rel="noopener">sorry</a>」，但界面我不太喜欢，而且我觉得这类较为简单的处理没必要借助服务器端渲染合成，直接在浏览器端渲染就好了，<del>毕竟 JavaScript 算是一门「万能的语言」</del>。</p><p>核心思路是采用 omggif 对 GIF 进行解码，再用 Canvas 将文字绘制在每一帧上，最后再用 gif.js 将每一帧合成，再渲染后输出成 Blob 文件对象（<a href="https://caniuse.com/#search=blob" target="_blank" rel="noopener">现在不支持 Blob 的浏览器应该没有了吧？</a>），传递给 IMG 标签进行显示。</p><p>这是解码过程：</p><pre><code class="javascript">// 解码let gifReader = new omggif.GifReader(buffer);    // 获取帧let frameZero = girReader.frameInfo(0)            // 获取帧的宽高，绘制 Canvas 的时候会用到let [width, height] = [frameZero.width, frameZero.height]    let imageBuffer = new Uint8ClampedArray(width * height * 4)gifReader.decodeAndBlitFrameRGBA(frameNum, imageBuffer);// 生成图像数据，供 Canvas 使用let imageData = new window.ImageData(imageBuffer, width, height)</code></pre><p>这是绘制过程：</p><pre><code class="javascript">ctx.putImageData(imageData, 0, 0)// 这是字幕的白边ctx.strokeText(caption, width / 2, height - 5, width);// 这是字幕的主体ctx.fillText(caption, width / 2, height - 5, width)</code></pre><p>这是编码（渲染）过程：</p><pre><code class="javascript">let gif = new GIF({    workers: 3,    quality: 10,    width: imageWidth,    height: imageHeight,})// Canvas 的数据加入帧gif.addFrame(ctx, {    copy: true,    delay: frameInfo.delay,    dispose: -1})// 开始渲染gif.render()// 渲染完成gif.on(&#39;finished&#39;, Blob =&gt; {    gifUrl = window.URL.createObjectURL(Blob);    img.src = gifUrl;})</code></pre><p>以上是动图的设计思路，静态图就显得简单多了，采用 dom-to-img 绘制就行了，但是在 Edge 上似乎是无法使用的，作者提到似乎是因为添加了 foreignObject 标签，导致 toDataUrl() 在 Edge 上无法工作，所以 Edge 用户只能使用动图部分了。</p><p>其实核心思路很简单，gif.js 和 omggif 提供的 API 也不复杂，但我还是花了将近一周的时间，因为这是我首次使用 React 开发应用，所以有大半时间都花在了学习 React 上，然而写出来的结果还是偏「Pure JavaScript」一些。</p><p><a href="https://github.com/WincerChan/Meme-generator" target="_blank" rel="noopener">本项目</a>采用 <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a> 构建，CSS 框架采用了 <a href="https://github.com/jgthms/bulma" target="_blank" rel="noopener">bulma</a>，部分动图模板来自 <a href="https://github.com/xtyxtyx/sorry" target="_blank" rel="noopener">sorry</a>。</p><h2 id="实现"><a href="posts/8575e868/#实现" class="headerlink" title="实现"></a>实现</h2><p>刚刚有提到，我在设计该工具的时候大部分时间都没有花在核心思路部分，而是花在了——我称为「薛定谔的 Bug」上，即：你在设计该工具的蓝图的时候，没有设想到会出现这些 Bug，而实际编程中，也不一定会遇到，只有你亲自编写了，才知道这 Bug 是否会出现。</p><p>我在这次编程中就遇到了四个「薛定谔的 Bug」：</p><h3 id="Blob-文件对象"><a href="posts/8575e868/#Blob-文件对象" class="headerlink" title="Blob 文件对象"></a>Blob 文件对象</h3><p>关于静态图部分，我设计了两个按钮：「戳我预览」和「戳我下载」，其实本应该只需要一个下载按钮就够了，因为我使用 contenteditable 属性以编辑 p 标签。和生成的预览图几乎没什么差别，那么为什么要设计两个呢？就是因为 Blob 对象（后续思考了一下，虽然可以先行判断浏览器是否支持 Blob 下载，但针对动态图还是需要预览修正的，故为了设计上的统一性，还是将预览按钮保留了）。</p><p>其实大部分人应该是没有听说过这个名词的（包括我），但它还真的不是一个新玩意，甚至都不是 HTML5 新增的 API，相比于 HTML5 在 2014 年才完成标准制定，在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">MDN</a> 上查到 Blob 对象在 2010 年就被主流浏览器支持了（Chrome 5、Firefox 4、Opera 11.1），但，如今大部分手机浏览器却仍不支持 Blob 文件下载协议。</p><p>所以只好提供一个预览按钮来供不支持 Blob 文件下载协议的浏览器长按进行保存。</p><h3 id="服务器问题"><a href="posts/8575e868/#服务器问题" class="headerlink" title="服务器问题"></a>服务器问题</h3><p>由于我的服务器是在国外，而且还套了一层 Cloudflare，故而在某些情况下，加载动图会非常慢，尤其是在晚上（大约花费 1min，而且居然还没断，我真是很佩服 Cloudflare 的稳定性）。</p><p>当然图片的加载问题还不算大，可以放在<a href="https://sm.ms" target="_blank" rel="noopener">支持跨域的图床</a>上，由 <code>fetch</code> 调用，问题最大的是 Web Worker（合成 GIF 的时候需要使用），但这个 Web Worker 的地址在 Chrome 下<strong>只允许</strong>同域名下的脚本，即使是公共 CDN 上允许跨域都不行。</p><p>这里采用还是借助 Blob 对象，巧妙的规避这一限制：</p><pre><code class="javascript">let tmpWorker = await fetch(url),    workerSrcBlob = new Blob([await tmpWorker.text()], { type: &#39;text/javascript&#39; }),    workerBlobURL = window.URL.createObjectURL(workerSrcBlob);</code></pre><h3 id="React-Router-404-错误"><a href="posts/8575e868/#React-Router-404-错误" class="headerlink" title="React Router 404 错误"></a>React Router 404 错误</h3><p>在将代码生成「production build」时，遇到了一个 Bug，有时访问二级路由会出现 404，多次复现后，终于确定了：</p><p>在访问二级路由时，如果是正常从一级页面点击跳转的，则会正常访问；</p><p>但如果是直接访问二级路由或者是在二级路由刷新页面，则会出现 404；</p><p>但是这个 Bug 在「development build」中是没有的，原因在于当你点击路由时，并不是直接向服务器发起请求，而是由 react-router 路由库给出路由网址，故而刷新二级路由页面或者直接访问二级路由页面服务器是无法正确响应的。</p><p>以下是解决办法，在 Nginx 中添加 <code>try_files</code> 语句：</p><pre><code class="nginx">server {    location / {        try_files $uri /index.html    }}</code></pre><h3 id="GIF-渲染"><a href="posts/8575e868/#GIF-渲染" class="headerlink" title="GIF 渲染"></a>GIF 渲染</h3><p>当我解决了以上问题的时候，我发给室友首先试用，看到了「戳我预览」这个按钮，他就以「单身十八年」的手速猛戳了四五下，随后标志着渲染进度条就「鬼畜」了起来。因为他猛戳的那几下相当于在后台启动了好几个渲染程序，不仅会让进度条「鬼畜」起来，如果你以更快的手速戳的话（单身八十年？）还会让 CPU 负担加重，甚至会卡死，当然我是没有试过。其实这 Bug 算是无伤大雅的，本不太需要修复，<del>因为不像其它生成器拿服务器做后端，可能会造成服务器宕机，我的纯前端写的</del>。但我本着人道主义情怀、不让我的 Bug 陪我过夜的心理，以及最重要的强迫症，还是决定修复这个 Bug。</p><p>其实很简单，设置一个全局变量 <code>finished</code>，在渲染的过程中，该变量为 <code>false</code>，渲染完毕后设置成 <code>true</code>，再将渲染过程放置在 <code>if(finished)</code> 内就解决了。</p><h2 id="教程"><a href="posts/8575e868/#教程" class="headerlink" title="教程"></a>教程</h2><p>见<a href="https://github.com/WincerChan/Meme-generator/wiki" target="_blank" rel="noopener">本项目的 Wiki</a>。</p><h2 id="结语"><a href="posts/8575e868/#结语" class="headerlink" title="结语"></a>结语</h2><p>本工具还有很多需要改进的地方，比如 React 的写法不够规范、没有完全实现静态动态资源分离、用户自定义添加模板等等，这些我在空闲时间里都会一点点的改进。</p><p>目前在实用的角度来说，该工具已经可以投入使用了，剩下的细节就需要慢慢雕琢了。:)</p><p>参考：</p><ul><li><a href="https://github.com/xtyxtyx/sorry" target="_blank" rel="noopener">xtyxtyx/sorry</a></li><li><a href="https://blog.csdn.net/xfgryujk/article/details/79889942" target="_blank" rel="noopener">纯 JS 实现在前端制作 GIF 表情包的网站</a></li><li><a href="https://react-guide.github.io/react-router-cn/docs/guides/basics/Histories.html" target="_blank" rel="noopener">Histories</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 表情包 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 字典的原理及高级用法</title>
      <link href="/posts/4f2b4bfb/"/>
      <url>/posts/4f2b4bfb/</url>
      
        <content type="html"><![CDATA[<p>算算时间有段时间没写技术类的文章了，部分原因是最近过得确实比较忙。当然，也并没有忙到完全抽不出时间写博客，根本原因还是没有找到啥好的写作素材，随随便便糊弄一篇我又有点不好意思发上来，于是乎，就一直搁置到现在。</p><a id="more"></a><p>对于字典这一基础的数据结构来说，其对 Python 的程序重要性是无可替代的，在《代码之美》一书中，作者是这么描述的：</p><blockquote><p>字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到它。——A.M.Kuchling</p></blockquote><p>在 Python 程序里，无论是模块、函数、还是对象，均有自己的「命名空间」，而这命名空间即为一个字典（dict），key 就是变量名，value 就是变量值，除去「命名空间外」，对象的函数（方法）关键字也是存放在字典中，此时的 key 就是函数（方法）名，value 就是该函数（方法）的引用。可以采用 __builtins__.__dict__ 来查看这些函数（方法）。</p><h2 id="字典的原理"><a href="posts/4f2b4bfb/#字典的原理" class="headerlink" title="字典的原理"></a>字典的原理</h2><p>Python 的字典是依据<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener">散列表</a>（也叫哈希表）来实现的，首先简单介绍一下散列表的原理。</p><p>散列表中的每一个单元称为表元。在 dict 的实现里，每个 key-value 均占用一个表元，其中 key 为<strong>键的引用</strong>（这里是键的引用，而不是键本身，因为 key 可以为任意可散列对象），value 为值的引用。因为是引用：表元大小均一致，所以可通过偏移量来读取某个表元。</p><p>在 Python 中，散列函数由 hash() 方法出任，当我们查询 my_dict[search_key] 时，Python 会调用 hash(search_key) 来计算 search_key 的散列值，并将这个值的低几位数字当作偏移量，在散列表中查找表元，具体是几位，需要根据散列表的大小来决定。若表元为空，则说明 search_key 不存在，抛出 KeyError 异常。若非空，则表元会有一对 found_key:found_value，这时若 search_key == found_key 为真，那么就返回 found_value。</p><p>如果 search_key 和 found_key 不相等，这种情况成为散列冲突，发生这种情况是因为散列表只把该元素映射到了只有几位数字上。为了解决散列冲突，算法会在散列值中另外取几位，用新得到的数字做偏移量再次寻找。</p><h2 id="创建字典"><a href="posts/4f2b4bfb/#创建字典" class="headerlink" title="创建字典"></a>创建字典</h2><p>创建一个字典有许多方式：</p><pre><code class="python">a = dict(one=1, two=2, three=3)b = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}c = dict(zip([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [1, 2, 3]))d = dict([(&#39;two&#39;, 2), (&#39;one&#39;, 1), (&#39;three&#39;, 3)])e = dict({&#39;three&#39;: 3, &#39;one&#39;: 1, &#39;two&#39;: 2})&gt;&gt;&gt; a == b == c == d == eTrue</code></pre><p>在刚刚的原理中说到，由于字典的索引是根据 hash() 函数来获得的，所以 dict 其实是无序的，这也解释了为什么上面代码中的等式会成立。</p><h2 id="字典推导"><a href="posts/4f2b4bfb/#字典推导" class="headerlink" title="字典推导"></a>字典推导</h2><p>没错，在 Python3+ 里，推导式不再是列表的特性了。</p><pre><code class="python">numbers = range(5)numbers_square = {number: number ** 2 for number in numbers}</code></pre><h2 id="键查询"><a href="posts/4f2b4bfb/#键查询" class="headerlink" title="键查询"></a>键查询</h2><p>最简单的方法是采用下标方式来查询。即：my_dict[key]，这也是推荐的方法，但这是 key 存在的情况，而现实中，一定会遇到 key 不存在的时候，这时就会 raise 一个 KeyError。以下有几种解决办法：</p><h3 id="用-get-来获取"><a href="posts/4f2b4bfb/#用-get-来获取" class="headerlink" title="用 get 来获取"></a>用 get 来获取</h3><pre><code class="python">my_id = {&#39;name&#39;: &#39;wincer&#39;}&gt;&gt;&gt; my_id.get(&#39;name&#39;)&#39;wincer&#39;&gt;&gt;&gt; my_id.get(&#39;age&#39;, &#39;default&#39;)&#39;default&#39;</code></pre><p>若 key 存在，则返回对应的 value，若 key 不存在，且传入第二个参数，那么返回该参数，若无第二个参数，则返回 None。</p><h3 id="用-defaultdict-预先设置缺省（推荐）"><a href="posts/4f2b4bfb/#用-defaultdict-预先设置缺省（推荐）" class="headerlink" title="用 defaultdict 预先设置缺省（推荐）"></a>用 defaultdict 预先设置缺省（推荐）</h3><pre><code class="python">from collections import defaultdictmy_id = defaultdict(list)my_id.update({&#39;name&#39;: &#39;wincer&#39;})&gt;&gt;&gt; mydict[&#39;name&#39;]&#39;wincer&#39;&gt;&gt;&gt; mydict[&#39;age&#39;][]</code></pre><p>defaultdict 需要指定一个 factory，当查询 key 不存在时，会创建一个空的 factory 返回。推荐使用这种方式来处理 key 不存在的情况，因为该方法不仅可用于读取 value 值，还可随时用 append 来更新 value。同时需注意：<strong>defaultdict 中的参数只会在 __getitem__ 中被调用。如 dd 是一个 defaultdict，k 是一个不存在的键，dd[k] 用 factory 来创造一个默认值，但 dd.get(k) 却仍会返回 None。</strong></p><h3 id="使用-missing-方法"><a href="posts/4f2b4bfb/#使用-missing-方法" class="headerlink" title="使用 __missing__ 方法"></a>使用 __missing__ 方法</h3><p>当我们调用 my_dict[key] 时，<strong>如果 key 是一个字符串</strong>，我们会需要用 my_dict[‘name’] 来获取，如果你觉得比较麻烦，想直接用 my_dict[name] 的话，可以采用如下方法：</p><pre><code class="python">from collections import UserDictclass StrKeyDict(UserDict):    def __missing__(self, key):        if isinstance(key, str):            raise KeyError(key)        return self[str(key)]    def __contains__(self, key):        return str(key) in self.data    def __setitem__(self, key, item):        self.data[str(key)] = itemd = StrKetDict([(&#39;1&#39;, &#39;one&#39;), (&#39;2&#39;, &#39;two&#39;)])&gt;&gt;&gt; d[2]&#39;two&#39;</code></pre><h3 id="使用-getattr-方法（不推荐）"><a href="posts/4f2b4bfb/#使用-getattr-方法（不推荐）" class="headerlink" title="使用 __getattr__ 方法（不推荐）"></a>使用 __getattr__ 方法（不推荐）</h3><p>有时我们可能更懒，想要用类属性类似的 my_dict.name 方法来获取 value，这时，可以使用 __getattr__ 方法：</p><pre><code class="python">from collections import UserDictclass AttrDict(UserDict):    def __getattr__(self, attr):        return self[attr]d = AttrDict([(&#39;name&#39;, &#39;wincer&#39;), (&#39;age&#39;, &#39;20&#39;)])&gt;&gt;&gt; d.name&#39;wincer&#39;</code></pre><p>并不推荐这样做，因为在 dict 实现中，并没有要求 key 一定为合法标识符，只需要是可散列对象即可，而上面的写法一旦 key 不为合法标识符，会 raise 一个 SyntaxError：</p><pre><code class="python">d.update({(0): &#39;zero&#39;})&gt;&gt;&gt; d[(0)]&#39;zero&#39;&gt;&gt;&gt; d.0SyntaxError: invalid syntax</code></pre><p>如果非常想使用 . 来获取 value 的话，建议使用 namedtuple</p><p>当然这也就意味着必须使用合法标识符了：</p><pre><code class="python">from collections import namedtupleID = namedtuple(&#39;ID&#39;, &#39;name age&#39;)me = ID(&#39;wincer&#39;, 20)&gt;&gt;&gt; me.name&#39;wincer&#39;ID = namedtuple(&#39;ID&#39;, &#39;(1, 0) age&#39;)ValueError: Type names and field names must be valid identifiers: &#39;(1&#39;</code></pre><h3 id="实现-switch-…-case-结构"><a href="posts/4f2b4bfb/#实现-switch-…-case-结构" class="headerlink" title="实现 switch … case 结构"></a>实现 switch … case 结构</h3><p>同样借助键查询，可以实现 Python 中没有的 switch … case 结构：</p><pre><code class="python">def foo(x):    data = {        0: &#39;zero&#39;,        1: &#39;one&#39;,        2: &#39;two&#39;,    }    return data.get(x, None)</code></pre><p>所以说 Python 不设计 switch … case 语句是有原因的，看上面的实现，比 switch … case 不知道高到哪里去了。</p><h2 id="dict-和它的小伙伴们"><a href="posts/4f2b4bfb/#dict-和它的小伙伴们" class="headerlink" title="dict 和它的小伙伴们"></a>dict 和它的小伙伴们</h2><h3 id="OrderedDict"><a href="posts/4f2b4bfb/#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>在添加键的时候会按顺序添加，同时 .popitem 是会删除并返回字典的最后一个元素而不是像 dict 里面一样可能会删除任意元素。</p><h3 id="Counter"><a href="posts/4f2b4bfb/#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>这个映射会给键一个计数器，每次更新键时都会增加这个计时器，所以这个类型可以用以给可迭代类型计数：</p><pre><code class="python">from collections import Counterct = Counter(&#39;hfkjahfkakhf&#39;)&gt;&gt;&gt; ctCounter({&#39;a&#39;: 2, &#39;f&#39;: 3, &#39;h&#39;: 3, &#39;j&#39;: 1, &#39;k&#39;: 3})ct.update(&#39;fdjlahkla&#39;)&gt;&gt;&gt; ctCounter({&#39;a&#39;: 4, &#39;d&#39;: 1, &#39;f&#39;: 4, &#39;h&#39;: 4, &#39;j&#39;: 2, &#39;k&#39;: 4, &#39;l&#39;: 2})&gt;&gt;&gt; ct.most_common(2)[(&#39;h&#39;, 4), (&#39;f&#39;, 4)]</code></pre><h3 id="UserDict"><a href="posts/4f2b4bfb/#UserDict" class="headerlink" title="UserDict"></a>UserDict</h3><p>用法见键查询。</p><h3 id="不可变映射"><a href="posts/4f2b4bfb/#不可变映射" class="headerlink" title="不可变映射"></a>不可变映射</h3><p>在 Python 3.3 后的版本，types 模块引入一个名为 MappingProxyType 的类。如果给这个类一个映射，它会返回一个只读的映射视图。但它是动态的，如果原映射改动，那么它也会相应改动。</p><pre><code class="python">&gt;&gt;&gt; int.__dict__mappingproxy({&#39;__abs__&#39;: &lt;slot wrapper &#39;__abs__&#39; of &#39;int&#39; objects&gt;,              &#39;__add__&#39;: &lt;slot wrapper &#39;__add__&#39; of &#39;int&#39; objects&gt;,              ...})from types import MappingProxyTyped = {1: &#39;A&#39;}d_proxy = MappingProxyType(d)&gt;&gt;&gt; d_proxy[2] = &#39;x&#39;TypeError: &#39;mappingproxy&#39; object does not support item assignmentd[2] = &#39;B&#39;&gt;&gt;&gt; d_proxy[2]&#39;B&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《代码整洁之道》读书笔记</title>
      <link href="/posts/65e48179/"/>
      <url>/posts/65e48179/</url>
      
        <content type="html"><![CDATA[<blockquote><p>相对于任何宏伟愿景，对细节的关注甚至是更为关键的专业性基础。首先，开发者通过小型实践获得可用于大型实践的技能和信用度。其次，宏大建筑中最细小的部分，比如关不紧的门、有点儿没铺平的地板，甚至是凌乱的桌面，都会将整个大局的魅力毁灭殆尽。这就是整洁代码之所系。</p></blockquote><a id="more"></a><p>本书「序」中的这段话完美的诠释了作者写本书的意义。（简评在最后）</p><h2 id="序"><a href="posts/65e48179/#序" class="headerlink" title="序"></a>序</h2><ol><li>神在细节之中。</li><li>5S 哲学包括以下概念：<ul><li>整理（Seiri）</li><li>整顿（Seiton）</li><li>清楚（Seiso）</li><li>清洁（Seiketsu）</li><li>身美（Shitsuke）</li></ul></li></ol><h2 id="整洁代码"><a href="posts/65e48179/#整洁代码" class="headerlink" title="整洁代码"></a>整洁代码</h2><ol><li><p>有人也许以为，关于代码的书有点落后于时代——代码不再是问题：我们应当关注模型和需求。……扯淡！我们永远抛不掉代码，因为代码呈现了需求的细节。在某些层面上，这些细节无法被忽略或抽象，必须明确之。将需求明确到机器可以执行的细节程度，就是编程要做的事。而这种规约正是<strong>代码</strong>。</p></li><li><p>勒布朗（LeBlanc）法则：<strong>稍后等于永不</strong>（Later equals never）。</p></li><li><p>多数人都知道一幅画是好还是坏。但能分辨优劣并不表示懂得绘画。能分辨整洁代码和肮脏代码，也不意味着会写整洁代码！</p></li><li><p><strong>Bjarne Stroustrup（C++ 语言发明者）</strong>：我喜欢优雅和高效的代码。代码逻辑应当直截了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码；性能调至最优，省得引诱别人做没规矩的优化，高处一堆混乱来，整洁的代码只做好一件事。</p></li><li><p><strong>Grady Booch（《面向对象分析与设计》作者）</strong>：整洁的代码简单直接。整洁的代码如同优美的散文。整洁的代码从不隐藏设计者的意图，充满了干净利落的抽象和直截了当的控制语句。</p></li><li><p><strong>Ron Jeffries（《极限编程实施》作者）</strong>：简单代码，依其重要顺序：</p><ul><li>能通过所有测试；</li><li>没有重复代码；</li><li>体现系统中的全部设计理念；</li><li>包括尽量少的实体，比如类、方法、函数等。</li></ul></li><li><p><strong>Ward Cunningham（Wiki 发明者）</strong>：如果每个例程都让你感到深合己意，那就是整洁代码。如果代码让编程语言看起来像是专为解决那个问题而存在，就可以称之为漂亮的代码。</p></li><li><p>光把代码写好可不够。必须时时保持代码整洁。</p></li></ol><h2 id="有意义的命名"><a href="posts/65e48179/#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h2><ol><li><p><strong>名副其实</strong>：变量、函数或类的名称应该已经答复了所有的大问题。它该告诉你，它为什么会存在，它做什么事，应该怎么用。</p></li><li><p><strong>避免误导</strong>：应当避免使用与本意相悖的词。别用 accountList 来指称一组账号，除非它真的是 List 类型。用 accountGroup 或 bunchOfAccounts，甚至 accounts 都会好一些。</p></li><li><p><strong>做有意义的区分</strong>：以数字系列命名（a1、a2，……aN）是依义命名的对立面。这样的名称纯属误导——完全没有提供正确信息；没有提供导向作者意图的线索。</p><pre><code class="java">public static void copyChars(char a1[], char a2[]) {    for (int i = 0; i &lt; a1.length; i++) {        a2[i] = a1[i];    }}</code></pre><p>如果参数名改为 source 和 destination，这个函数就会像样许多。</p></li><li><p><strong>使用读得出来的名称</strong>：</p><pre><code class="java">private Date genymdhms; // 生成日期，年、月、日、时、分、秒private Date generationTimestamp;</code></pre></li><li><p><strong>使用可搜索的名称</strong>：窃以为单字母名称<strong>仅</strong>用于短方法中的本地变量。名称长短应于其作用域大小相对应。</p></li><li><p><strong>避免思维映射</strong>：不应当让读者在脑中把你的名称翻译为他们熟知的名称。</p></li><li><p><strong>类名</strong>：类名和对象名应该是名词或名词短语，如 Customer、WikiPage。避免使用 Manager、Data 这样的类名。</p></li><li><p><strong>方法名</strong>：方法名应当是动词或动词短语，如 postPayment、deletePage 或 save。</p></li><li><p><strong>每个概念对应一个词</strong>：给每个抽象概念选一个词，并且一以贯之。</p></li><li><p><strong>别用双关语</strong>：避免将同一单词用于不同目的。</p></li></ol><h2 id="函数"><a href="posts/65e48179/#函数" class="headerlink" title="函数"></a>函数</h2><ol><li><p>函数的第一规则是要短小。第二条规则是还要更短小。</p></li><li><p>函数应该做一件事。做好这件事。只做这一件事。</p></li><li><p>别害怕长名称。长而具有描述性的名称，要比短而令人费解的名称好。长而具有描述性的名称，要比描述性的长注释好。</p></li><li><p>最理想的参数数量是零（零参数函数），其次是一（单参数函数），再次是二（双参数函数），应尽量避免三（三参数函数）。如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了。</p></li><li><p>函数要么做什么事，要么回答什么事，但二者不可兼得。函数应该修改某对象的状态，或是返回该对象的有关信息。</p></li><li><p>重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。</p></li><li><p>我写函数时，一开始都冗长而复杂。有太多缩进和嵌套循环。然后我打磨这些代码，分解函数、修改名称、消除重复。我缩短和重新安置方法。有时我还拆散类。</p></li><li><p>大师级程序员把系统当作故事来讲，而不是当作程序来写。他们使用选定编程语言提供的工具构建一种更为丰富且更具表达力的语言，用来讲那个故事。</p></li></ol><h2 id="注释"><a href="posts/65e48179/#注释" class="headerlink" title="注释"></a>注释</h2><ol><li><strong>Brian W. Kernighan 与 P. J. Plaugher</strong>：别给糟糕的代码加注释——重新写吧。</li><li>注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。注意，我用了「失败」一词。我是说真的。注释总是一种失败。我为什么要极力遍地注释？因为注释会撒谎。</li><li><strong>好注释</strong>：<ol><li>法律信息</li><li>提供信息的注释</li><li>对意图的解释</li><li>阐释</li><li>警示</li><li>TODO</li></ol></li></ol><h2 id="格式"><a href="posts/65e48179/#格式" class="headerlink" title="格式"></a>格式</h2><ol><li>你今天编写的功能，极有可能在下一版本中被修改，但代码的可读性却会对以后可能发生的修改行为产生深远影响。</li><li><strong>垂直格式</strong>：<ol><li>关系密切的概念应该相互靠近。</li><li>变量声明应尽可能靠近其使用位置。</li><li>实体变量应该在类的顶部声明。</li><li>若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽肯能放在被调用者上面。</li></ol></li><li><strong>横向格式</strong>：<ol><li>应该尽量保持代码行短小。死守 80 个字符上限有点僵化，至多在 100 或 120 个字符。</li><li>赋值操作符周围加上空格字符，以此加上强调目的。</li><li>不在函数名和左圆括号之间加空格。</li><li>源文件是一种继承结构，而不是一种大纲结构。类中的方法相对该类缩进一个层级。方法的实现相对方法声明缩进一个层级。</li></ol></li></ol><h2 id="对象和数据结构"><a href="posts/65e48179/#对象和数据结构" class="headerlink" title="对象和数据结构"></a>对象和数据结构</h2><ol><li><p>过程式代码便于在不该动既有数据结构的前提下添加新函数。面向对象代码便于在不改动既有函数的前提下添加新类。</p></li><li><p>得墨忒耳率认为，类 C 的方法 f 只应该调用以下对象的方法：</p><ul><li>C</li><li>由 f 创建的对象；</li><li>作为参数传递给 f 的对象；</li><li>由 C 的实体变量持有的对象。</li></ul><p>方法不应调用由任何函数返回的对象的方法。换言之，只跟朋友谈话，不与陌生人谈话。</p></li><li><p>对象曝露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。数据结构曝露数据，没有明显的行为。便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。</p></li></ol><h2 id="错误处理"><a href="posts/65e48179/#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol><li>错误处理很重要，<strong>但如果它搞乱了代码逻辑，就是错误的做法</strong>。</li><li>在某种意义上，try 代码块就像是事务。catch 代码块将程序维持在一种状态，无论 try 代码块中发生了什么均如此，所以，在编写可能抛出异常的代码时，最好先写出 try-catch-finally 语句。</li><li>你抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所。</li><li>对异常可以依据其来源分类：是来自组件还是其他地方？或依其类型分类：是设备错误、网络错误还是编程错误？不过，当我们在应用程序中定义异常类时，最重要的考虑应该是<strong>它们如何被捕获</strong>。</li><li>返回 null 值，基本上是在给自己增加工作量，也是在给调用者添乱。只要有一处没检查 null 值，应用程序就会失控。在方法中返回 null 值是糟糕的做法，但将 null 值传递给其他方法就更糟糕了。</li></ol><h2 id="边界"><a href="posts/65e48179/#边界" class="headerlink" title="边界"></a>边界</h2><ol><li><strong>学习性测试</strong>（learning tests）：不要在生产代码中试验新东西，而是编写测试来遍览和理解第三方代码</li><li>使用尚不存在的代码，将尚未开发完毕的 API 从中隔离出来。自己通过使用符合应用程序的接口，一旦 API 被定义出来，再将二者对接。</li><li>通过代码中少数几处引用第三方边界接口的位置来管理第三方边界。</li></ol><h2 id="单元测试"><a href="posts/65e48179/#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol><li>TDD 三定律：<ol><li>在编写不能通过的单元测试前，不可编写生产代码。</li><li>只可编写刚好无法通过的单元测试，不能编译也不算通过。</li><li>只可编写刚好足以通过当前失败测试的生产代码。</li></ol></li><li>脏测试等同于——如果不是坏于的话——没测试。</li><li>测试代码和生产代码一样重要。它可不是二等公民。它需要被思考、被设计和被照料。它该像生产代码一般保持整洁。</li><li>整洁的测试有什么要素？有三个要素：可读性、可读性和可读性。</li><li>整洁的测试遵循以下 5 条规则：<ol><li><strong>快速（Fast）</strong>：测试应该够快。</li><li><strong>独立（Independent）</strong>：测试应该相互独立。</li><li><strong>可重复（Repeatable）</strong>：测试应当可在任何环境中重复通过。</li><li><strong>自足验证（Self-Validating）</strong>：测试应该有布尔值输出。</li><li><strong>及时（Timely）</strong>：测试应及时编写。</li></ol></li></ol><h2 id="类"><a href="posts/65e48179/#类" class="headerlink" title="类"></a>类</h2><ol><li>类的第一条规则是类应该短小。第二条规则是还要更短小。</li><li>单一权责原则（SRP）认为，类或模块应有且只有一条加以修改的理由。</li><li>系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。</li><li>通常而言，方法操作的变量越多，就越黏聚到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。</li><li>开放-闭合原则（OCP）：类应当对扩展开放，对修改封闭。</li><li>依赖倒置原则（DIP）：类应当依赖于抽象而不是依赖于具体细节。</li></ol><h2 id="系统"><a href="posts/65e48179/#系统" class="headerlink" title="系统"></a>系统</h2><ol><li>软件系统应将启始过程和启始过程之后的运行时逻辑分离开，在启始过程中构建应用对象，也会存在相互缠结的以来关系。</li><li>可以使用抽象工厂模式让应用自行控制何时创建对象，但构造的细节却隔离于应用程序代码之外。</li><li>依赖注入（Dependency Injection）：对象不应负责实体化对自身的依赖。反之，它应当将这份权移交给其他「有权力」的机制，从而实现控制的反转。</li><li>我们应该只去实现今天的用户故事，然后重构，明天再扩展系统、实现新的用户故事。这就是迭代和增量敏捷的精髓所在。</li><li>面向方面编程（aspect-oriented）：被称为方面的模块构造指明了系统中哪些点的行为会以某种一致的方式被修改，从而支持某种特定的场景。</li></ol><h2 id="迭进"><a href="posts/65e48179/#迭进" class="headerlink" title="迭进"></a>迭进</h2><ol><li>简单设计规则 1：运行所有测试：遵循有关编写测试并持续运行测试的简单、明确的规则，系统就会更贴近 OO 低耦合度、高内聚度的目标。</li><li>简单设计规则 2：重构：在重构过程中，可以应用有关优秀软件设计的一切知识。提升内聚性，降低耦合度，切分关注面，模块化系统性关注面，缩小函数和类的尺寸，选用更好的名称等。</li><li>不可重复：「小规模复用」可大量降低系统复杂性。</li><li>表达力：做到有表达力的最重要方式却是尝试。</li><li>尽可能少的类和方法。</li></ol><h2 id="并发编程"><a href="posts/65e48179/#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><table><thead><tr><th>名词</th><th>基础定义</th></tr></thead><tbody><tr><td>限定资源</td><td>并发环境中有着固定尺寸或数量的资源。例如数据库连接和固定尺寸读/写缓存等</td></tr><tr><td>互斥</td><td>每一时刻仅有一个线程能访问共享数据或共享资源</td></tr><tr><td>线程饥饿</td><td>一个或一组线程互相等待执行结束。</td></tr><tr><td>死锁</td><td>两个或多个线程互相等待执行结束。</td></tr><tr><td>活锁</td><td>执行次序一致的线程，每个都想要起步，但发现其他线程已经「在路上」。</td></tr></tbody></table><ol><li><p>对象是过程的抽象。线程是调度的抽象。</p></li><li><p>并发是一种解耦策略。它帮助我们把做什么（目的）和何时（时机）做分解开。</p></li><li><p>并发软件的中肯说法：</p><ul><li>并发会在性能和编写额外代码上增加一些开销；</li><li>正确的并发是复杂的，即便对于简单的问题也是如此；</li><li>并发缺陷并非总能重现，所以常被看做偶发事件而忽略，未被当做真的缺陷看待；</li><li>并发常常需要对设计策略的根本性修改。</li></ul></li><li><p>生产者-消费者模型：一个或多个生产者线程创建某些工作，并置于缓存或者队列中。一个或者多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。</p></li><li><p>读者-作者模型：当存在一个主要为读者线程提供信息源，但只是偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。协调读者线程不去读取正在更新的信息，而作者线程倾向于长期锁定读者线程。</p></li><li><p>宴席哲学家：许多企业级应用中会存在进程竞争资源的情形，如果没有用心设计，这种竞争会遭遇死锁，活锁，吞吐量和效率低等问题。</p></li></ol><p>本书后几章主要侧重于讲解 Java 代码的一些例子，对其它语言帮助不大，在这里就不做整理了。</p><hr><p>正如我在<a href="../a6c2a51d/">上一篇读书笔记</a>中所说的：每一本中都会充斥着许多作者的自己的观点、看法，而唯有价值观相符合或相接近的人才会觉得本书写得很不错，上一本《黑客与画家》是，这本《代码整洁之道》也是，你可能很难认为变量的命名需要有那么考究，函数的长短有那么重要，心里想着程序能运行就没事，甚至连 WARNING 都忽视掉，这类人想必并不是本书的目标群体。而本书的目标群体在开头已经注明了：你想成为一个更好的程序员。其实我觉得目标群体还可以加上一小撮人：有强迫症的程序员——比如我。</p><p>我曾经看自己四个月前的代码能羞愧得钻进地里，心想着怎么能写出这么烂的<a href="https://gist.github.com/WincerChan/362331456a6e0417c5aa1cf3ff7be2b7/revisions" target="_blank" rel="noopener">代码</a>。这四个月固然有我对该门语言较高层级的数据结构更加熟悉，能更熟练的操作它们，但更多的是编程观念的改变：需要用心来写代码，不要简单敷衍了事，不要认为程序只要能运行就算成功。程序毕竟还是写给人看的，就算不是为了别人，看着意义明确的变量，缩进优美的段落，结构分明的函数，想必自己心里也会很舒畅的。</p>]]></content>
      
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextcloud 搭建私人云服务教程</title>
      <link href="/posts/bf0413ac/"/>
      <url>/posts/bf0413ac/</url>
      
        <content type="html"><![CDATA[<p>我一直很不相信国内的那些云服务提供商（尤其是在李彦宏发表的讲话「中国用户对隐私问题没那么敏感，在个人隐私方面更加开放，一定程度上愿用隐私换方便和效率」后），因为怕隐私得不到保障，故而我的一些隐私数据都是存放在国外的云盘（如 Dropbox、Drive 等）上。<a id="more"></a></p><p>可这俩在国内都被墙了，而手机翻墙总是显得有些不够方便，与是我就琢磨着自己搭建一个云服务，随后就发现了 Nextcloud 这一开源云服务。而网上的教程都太过复杂了，对新手太过不友好，于是乎——一篇近乎傻瓜式的 Nextcloud 教程诞生了。</p><h2 id="安装"><a href="posts/bf0413ac/#安装" class="headerlink" title="安装"></a>安装</h2><p>这里采用 Docker 容器方式来安装 Nextcloud，这样就不用担心各种环境依赖了（Nextcloud 的依赖简直多得吓人，而 Dockerfile 会帮你把依赖都配置好）</p><h3 id="安装-Docker"><a href="posts/bf0413ac/#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><blockquote><p>注：Docker 仅支持 64-bit 的系统</p></blockquote><p>Docker 现已被各大发行版的仓库收入，采用正常安装命令即可：</p><pre><code class="bash">yum -y install docker</code></pre><p>随后，启动 Docker 守护进程：</p><pre><code class="bash"># systemctlsystemctl start docker# Serviceservice docker start</code></pre><h3 id="安装-NextCloud"><a href="posts/bf0413ac/#安装-NextCloud" class="headerlink" title="安装 NextCloud"></a>安装 NextCloud</h3><h4 id="自动安装"><a href="posts/bf0413ac/#自动安装" class="headerlink" title="自动安装"></a>自动安装</h4><p>有了 Docker 后，就可以几行代码安装 Nextcloud 了：</p><pre><code class="bash"># clone nextcloud 的 docker 容器git clone https://github.com/nextcloud/docker.git# 耐心等待安装docker run -d -p 8080:80 nextcloud </code></pre><p>安装完成后先别忙着启动，<code>docker ps -a -q</code> 查看一下容器的 id，是一串 12 位的字符串，为了便于记忆，重命名一下：</p><pre><code class="bash">docker rename ××× nextcloud     # ××× 即为容器 id</code></pre><p>随后就可以采用如下命令启动了：</p><pre><code class="bash">docker start nextcloud# 测试curl http://localhost:8080</code></pre><p>这样，就完成了 Nextcloud 的安装工作。</p><h4 id="手动安装"><a href="posts/bf0413ac/#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>方法一只能安装最新版的 Nextcloud，而最新版缺少部分功能，如：无法添加 Drive 和 Dropbox 的外置存储。如果你对外置存储不是很 care 的话，那就按照方法一安装就可以了。</p><pre><code class="bash">git clone https://github.com/nextcloud/docker.gitcd docker/12.0/apache</code></pre><p>这里采用官方编写的 Dockerfile 手动构建，所以时间会花得比较久。</p><pre><code class="bash">docker build -t nextcloud .</code></pre><p>这时候用 <code>docker images</code> 应该可以看到刚刚创建的镜像了，随后创建容器：</p><pre><code class="bash">docker create -v /var/www/html/apps/:/var/www/html/apps -v /var/www/html/config/:/var/www/html/config -v /var/www/html/data/:/var/www/html/data -p 127.0.0.1:8080:80/tcp --name nextcloud nextcloud</code></pre><p>稍稍解释一下参数：</p><ul><li>-v 后面是地址，前半部分是 VPS 的地址，后半部分是容器内的地址</li><li>-p 后面是端口号</li><li>–name 后面是容器名称</li><li>最后的 nextcloud 是镜像名称</li></ul><h2 id="配置"><a href="posts/bf0413ac/#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Nginx-配置"><a href="posts/bf0413ac/#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h3><p>由于 NextCloud 已经占用了 8080 端口，这里采用 Nginx 做反向代理，将域名直接解析至 8080 端口。</p><pre><code class="nginx">server {  listen 80;  server_name cloud.example.com;  location / {    proxy_pass http://localhost:8080;  }}</code></pre><p>重启 Nginx 服务后，就可以通过 cloud.example.com 来访问云服务了。</p><h3 id="NextCloud-配置"><a href="posts/bf0413ac/#NextCloud-配置" class="headerlink" title="NextCloud 配置"></a>NextCloud 配置</h3><pre><code class="bash"># 进入容器内的 bashdocker exec -i -t nextcloud bash</code></pre><h4 id="重定向-overwritehost"><a href="posts/bf0413ac/#重定向-overwritehost" class="headerlink" title="重定向 overwritehost"></a>重定向 overwritehost</h4><p>有时候 NextCloud 会自己定向至本地的 8080 端口，所以需要手动重写正确的地址：如果提示不能定位软件包，先执行 <code>apt-get update</code>。</p><pre><code class="bash">vim config/config.php# 加上下面这行&#39;overwritehost&#39; =&gt; &#39;cloud.example.com&#39;,</code></pre><p>重启，让配置生效：</p><pre><code class="bash">docker restart nextcloud</code></pre><h3 id="MySQL-配置"><a href="posts/bf0413ac/#MySQL-配置" class="headerlink" title="MySQL 配置"></a>MySQL 配置</h3><p><del>由于我 VPS 的内存比较小，所以并没有启用 MySQL/MariaDB 数据库（怕爆内存），而是采用了 SQLite，反正也是我一个人用，问题不大。</del></p><p>开启了 MySQL 后发现内存也就多了 20M（但性能的提升可不是一点半点），遂还是改成 MySQL 了：</p><ol><li><p>安装 MySQL（这里采用 MariaDB 分支）</p><pre><code class="bash">yum -y install mariadb-server mariadb-client# 设置一下 root 密码等mysql_secure_installation</code></pre></li><li><p>开启 daemon 服务</p><pre><code class="bash">systemctl start mariadbsystemctl enable mariadb</code></pre></li><li><p><code>mysql -uroot -p</code> 登录 MySQL</p><pre><code class="mysql"># 创建 nextcloud 数据库CREATE DATABASE nextcloud CHARACTER SET = utf8 COLLATE = utf8_general_ci;# 创建 nextcloud 的用户CREATE USER nextcloud IDENTIFIED BY &#39;admin123&#39;;# 赋予对数据库所有的权限GRANT ALL ON nextcloud.* TO nextcloud;</code></pre></li></ol><h3 id="初始设置"><a href="posts/bf0413ac/#初始设置" class="headerlink" title="初始设置"></a>初始设置</h3><ol><li><p>打开 <a href="https://cloud.example.com" target="_blank" rel="noopener">https://cloud.example.com</a></p></li><li><p>创建管理员帐号和密码</p></li><li><p>数据库就选择 MySQL/MariaDB，其它参考下表：</p></li></ol><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">值</th></tr></thead><tbody><tr><td style="text-align:center">用户名</td><td style="text-align:center">nextcloud</td></tr><tr><td style="text-align:center">密码</td><td style="text-align:center">admin123</td></tr><tr><td style="text-align:center">数据库名</td><td style="text-align:center">nextcloud</td></tr><tr><td style="text-align:center">地址</td><td style="text-align:center">172.17.0.1</td></tr></tbody></table><p><strong>注意：这里的地址千万不要填写成了 localhost 或者 172.0.0.1，因为这里的地址需要容器内与外部通信。</strong></p><p>点击完成后，等待几秒就可以使用了。</p><h2 id="挂载外部云盘"><a href="posts/bf0413ac/#挂载外部云盘" class="headerlink" title="挂载外部云盘"></a>挂载外部云盘</h2><p>由于我 VPS 的容量只有 10g，故而放不了过多的视频，就考虑采用外部存储的方法，将 Drive、Dropbox 挂载至 Nextcloud 外部存储或者 VPS。</p><blockquote><p>注：Nextcloud 13 已经取消对 Drive、Dropbox 外部存储的支持（这时候你也可以选择把 Drive 直接挂载至 VPS 本地目录，再通过外部存储链接至挂载目录来完成）。</p></blockquote><h3 id="启用外部存储插件"><a href="posts/bf0413ac/#启用外部存储插件" class="headerlink" title="启用外部存储插件"></a>启用外部存储插件</h3><p>在应用页面，启用 <code>External storage support</code> 插件：如果提示：「没有安装 “smbclient”无法挂载 “SMB / CIFS”, “SMB / CIFS 使用 OC 登录信息”. 请联系您的系统管理员安装」</p><p>解决办法：</p><h3 id="安装-smbclient"><a href="posts/bf0413ac/#安装-smbclient" class="headerlink" title="安装 smbclient"></a>安装 smbclient</h3><pre><code class="bash"># 进入容器的内的 consoledocker exec -i -t nextcloud bashapt-get install libsmbclient-dev</code></pre><p>这里简单说一下，不管你的 VPS 原本的系统是 CentOS、RedHat、Debian，统一都用 apt-get 安装，因为现在处于的是 docker 容器内的系统，与 VPS 的系统是分离的。</p><p>接着再安装 smbclient：</p><pre><code class="bash">pecl install smbclient</code></pre><p>同时会提示：「You should add “extension=smbclient.so” to php.ini」，这里又被小坑一把，网上大部分教程所说的 <code>/etc/php.d/php.ini</code> 并不存在，在 docker 容器内部该文件是在：</p><pre><code class="bash">vim /usr/local/etc/php/conf.d/docker-php-ext-intl.ini# 加上下面这行extension=smbclient.so</code></pre><p>随后重启 Nextcloud 服务就应该就 OK 了。</p><p>随后如果你安装的 Nextcloud 是 13 版本及以上的话，就只有考虑用 <a href="https://www.box.com/" target="_blank" rel="noopener">box</a> 提供的 <a href="https://community.box.com/t5/Upload-and-Download-Files-and/WebDav-with-Box/ta-p/310" target="_blank" rel="noopener">WebDAV</a> 来作为外置存储了，不过只有 10G 的容量，且最大文件限制是 250MB。如果是用的 12 版本及以下的话，就可以考虑采取 Drive 作为外置存储了：</p><h3 id="获取-API"><a href="posts/bf0413ac/#获取-API" class="headerlink" title="获取 API"></a>获取 API</h3><ol><li><p>访问 <a href="https://www.orgleaf.com/go.php?url=https://console.developers.google.com" target="_blank" rel="noopener">Google 开发者平台</a>：</p></li><li><p>点击「启用 API 和服务」</p></li><li><p>点击「Google Drive API」</p></li><li><p>点击「启用」</p></li><li><p>点击左侧的凭据 -&gt; OAuth 同意屏幕：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1F7e1KkKWBuNjy1zj763OypXaf.png" alt="oauth 示例"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">oauth 示例</figure></p><p>按照以上格式填写，点击保存</p></li><li><p>随后创建凭据：</p><p>应用类型选择<strong>网页应用</strong>，其它的参考以下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1mgtydi6guuRjy0Fm7610DXXan.png" alt="url 配置"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">url 配置</figure></p><p>点击创建后，会弹出悬浮框告诉你 ID 和 Key。</p></li></ol><h3 id="配置-Nextcloud"><a href="posts/bf0413ac/#配置-Nextcloud" class="headerlink" title="配置 Nextcloud"></a>配置 Nextcloud</h3><p>登录 Nextcloud，转至管理页面，点击「外部存储」，选择 Google Drive，填入 API 和 Key，点击授权，若授权时出现 400 错误，那么是重定向的 URI 出问题了，再添加如下一条：</p><pre><code>https://cloud.example.com/index.php/settings/admin/externalstorages</code></pre><p>如果提示「此应用未经过验证」，点击高级 -&gt; 转至 example.com，忽略掉就行。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1OjWeKXmWBuNjSspd762ugXXaE.png" alt="外置存储"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">外置存储</figure></p><p>当出现了绿色按钮，就表示配置成功了。</p><p>参考：</p><ul><li><a href="https://github.com/nextcloud/docker#how-to-use-this-image" target="_blank" rel="noopener">Docker image of Nextcloud</a></li><li><a href="https://oing9179.github.io/blog/2017/03/Setup-Nextcloud-using-Docker-and-Nginx/" target="_blank" rel="noopener">用 Docker 和 Nginx 搭建自己的云服务器（Nextcloud）</a></li><li><a href="https://www.orgleaf.com/903.html" target="_blank" rel="noopener">连接 Google Drive 教程</a></li><li><a href="https://www.brilliantcode.net/486/freenas-10-nextcloud-use-smb-as-external-storage/" target="_blank" rel="noopener">FreeNAS 10 NextCloud 開啟外部儲存媒體的 SMB 功能</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPS </tag>
            
            <tag> 云服务 </tag>
            
            <tag> NextCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没有希望的事儿，还有坚持的必要吗</title>
      <link href="/posts/18b98ea6/"/>
      <url>/posts/18b98ea6/</url>
      
        <content type="html"><![CDATA[<p>「你说，没有希望的事，还有坚持的必要吗？」</p><p>确实是没想到，看国产青春剧也能看出了共鸣。<a id="more"></a></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1zLRQKaSWBuNjSsrbq6y0mVXaB.jpg" alt="拼接截图.jpg"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">拼接截图.jpg</figure></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1c_1MKqmWBuNjy1Xaq6xCbXXaP.jpg" alt="拼接截图 (1).jpg"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">拼接截图 (1).jpg</figure></p><p>忘记很早之前在哪看到过一句话：人会长大三次。第一次是在发现自己不是世界中心的时候；第二次是在发现即使再怎么努力，终究还是有些事令人无能为力的时候；第三次是在明知道有些事可能会无能为力，但还是会尽力争取的时候。</p><p>最初看这句话还没什么感觉，最近看了「最好的我们」后，突然就触动了。</p><p>那种触动，想来就是怎么也绕不开的「成长」了：自己做了想做的事，而生活却没有给自己想要的结果。于是乎，以后再遇见了想做的事，开始犹豫了，开始畏缩了，开始计较得失了，因为有了之前的经历，担心自己做了，却也得不到自己想要的结果。</p><p>你当然可以说是因为自己长大了，会计较得失了、不会像小时候一样：想干什么就去干什么。是啊，第二次成长的你知道了有些事情即使再怎么努力，也不会得到满意的结果，于是干脆就不去做了。</p><p>可目前处于不明成长阶段的我啊，又觉得凡事要是都仔细衡量得失后再去想做还是不做的话，那人生想必会少掉许多乐趣、会错过许多事情。</p><hr><p>我果然还是不适合看电视剧，花了一个月时间才把《最好的我们》看完（小时候那种看电视剧甚至广告时间都不愿意转台生怕错过衔接部分的劲儿都不知道哪去了，以后有时间还是多看看电影和书），听说还有几部青春剧也挺不错（《你好，旧时光》、《一起同过窗》等），就不看了，虽说确实能勾起高中时的那些或苦涩或美好的回忆，可那些回忆却再也不可得了。</p><p>也不想总是陷在回忆里，毕竟我，到底是已经长大了。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QQ 音乐外链解析</title>
      <link href="/posts/72171293/"/>
      <url>/posts/72171293/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="posts/72171293/#起因" class="headerlink" title="起因"></a>起因</h2><p>大概在五天前，忽然发现一直在用的网易云解析不能用了，去作者的项目查看才知道原来是网易云更换了新的接口，旧接口的请求现在统一返回 403。于是乎，便萌生了自己写一个接口的想法。</p><a id="more"></a><p>其实网易云的外链获取目前还是有几种可用方案，比如：</p><ol><li><a href="https://m1.jixun.moe/" target="_blank" rel="noopener">云音乐直链生成器</a></li><li>手动替换：<code>https://music.163.com/song/media/outer/url?id=[].mp3</code>，将中括号改为歌曲 id，即为外链</li></ol><p>这两种方法其实大同小异，都会 302 至歌曲的缓存地址，但也存在一个身为强迫症的我无法忍受的缺点——<del>缓存地址的协议是 <code>HTTP</code>（从云音乐官网现在还有大量的 Mixed Content 就可以看出网易对这方面并不上心），而且自己将协议修改成 <code>HTTPS</code> 后访问部分歌曲又会有机率出现 403，这可真是逼死我了</del>现在第二个方法已经会直接 302 至  HTTPS 协议了。于是决定暂时放弃掉网易云，换其他家的顶着。</p><p>我又用回了网易云接口，并编写了一个 <a href="https://api.itswincer.com/cloudmusic/" target="_blank" rel="noopener">API 文档</a>，欢迎使用。</p><h2 id="QQ-音乐"><a href="posts/72171293/#QQ-音乐" class="headerlink" title="QQ 音乐"></a>QQ 音乐</h2><p>考虑了一圈，还是决定选 QQ 音乐。在网上也找到了 QQ 音乐所提供的接口：</p><ul><li>请求地址：<code>https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg</code></li><li>参数，有三个：<ol><li>songmid：歌曲页 Url 的 <code>https://y.qq.com/n/yqq/song/{}.html</code> 括号部分</li><li>filename：歌曲名 <code>&#39;C00&#39; + songmid + &#39;.m4a&#39;</code></li><li>guid：随机生成的数字串 <code>int(random() * 2147483647) * int(time() * 1000) % 10000000000</code></li></ol></li></ul><p>综上，歌曲的请求地址为：<code>https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?format=json&amp;cid=205361747&amp;uin=0&amp;songmid={smid}&amp;filename={filename}&amp;guid={guid}</code></p><p>向这个地址请求后，会得到一个 JSON 格式的数据文件，包含了我们需要的信息：vkey</p><pre><code class="bash">curl &#39;https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?format=json&amp;cid=205361747&amp;uin=0&amp;songmid={smid}&amp;filename={filename}&amp;guid={guid}&#39;{&quot;code&quot;:0,&quot;cid&quot;:205361747,&quot;userip&quot;:&quot;××.××.××.××&quot;,&quot;data&quot;:{&quot;expiration&quot;:80400,&quot;items&quot;:[{&quot;subcode&quot;:104001,&quot;songmid&quot;:&quot;000uhMwj387EBp&quot;,&quot;filename&quot;:&quot;C00000uhMwj387EBp.m4a&quot;,&quot;vkey&quot;:&quot;B6BB8F604606DFDC82FD81CE33BC9C0277365D4B8B1BC8BCC909E408EAC9822315B2B9D021F42B495FA14AADCB598B21BCDB867931B7A953&quot;}]}}</code></pre><p>得到了最重要的 <code>vkey</code> 字段后，就可以解析出歌曲的「真实链接」了：</p><p><code>https://dl.stream.qqmusic.qq.com/{filename}?vkey={vkey}&amp;guid={guid}&amp;uin=0&amp;fromtag=66</code></p><p>你可能注意到返回的信息中还包含了 <code>expiration</code> 字段。是的，<code>vkey</code> 只有在该时间段内才有效，当然这个问题很好解决，可以把该程序部署至服务器，而从服务器发起请求获取链接后 302 至歌曲链接。</p><p>而当我满心欢喜的把这个脚本向服务端部署的时候，却失败了：原因是接口的请求地址只支持国内的（想来是因为 QQ 音乐只拿到了在大陆地区的版权），而我的服务器在美国，这个问题就有些难解决了（我没有国内的服务器）。</p><p>于是我想另辟蹊径。</p><h2 id="纯-JS-解析"><a href="posts/72171293/#纯-JS-解析" class="headerlink" title="纯 JS 解析"></a>纯 JS 解析</h2><p>既然服务端无法解析，那就用 JS 在用户端解析。</p><p>但又带来了另一个问题——跨域。</p><p>目前跨域请求比较好的解决方案有两种：CORS 和 JSONP，其中 CORS 需要服务器端设置 <code>Access-Control-Allow-Origin</code>，所以也就只有使用 JSONP 了。</p><blockquote><p>注意：跨域请求失败原因浏览器端阻止显示，并非服务器端无法返回数据</p></blockquote><p>使用 JSONP 时要求服务端返回的是满足 <a href="https://zh.wikipedia.org/wiki/JSONP#%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">JSONP 模式</a>的文件，不能是纯 JSON 文件，举个例子：</p><pre><code class="javascript">var url1 = &quot;https://lab.itswincer.com/jsonp/without-callback.js&quot;;var url2 = &quot;https://lab.itswincer.com/jsonp/with-callback.js&quot;;function foo(data) {    alert(`Hi, I am ${data.name}`);}var script = document.createElement(&#39;script&#39;);script.setAttribute(&#39;src&#39;, url1);document.body.appendChild(script);script.setAttribute(&#39;src&#39;, url2);document.body.appendChild(script);</code></pre><p>其中 <code>without-callback.js</code> 返回的是纯 JS 文件，<code>with-callback.js</code> 返回的是满足模式的 JS 文件。可以运行上面代码看看结果。</p><p>本想直接用现成的 <code>ajax</code>，考虑到并非所有的网站都引入了 jQuery，而为 <code>ajax</code> 就引入一个那么庞大的库又有些没必要。</p><p>于是就自己封装了一个 <code>getJSONP()</code> 接口来搭配 <code>getMusic()</code> 使用。</p><p>项目已开源，具体的代码见<a href="https://github.com/WincerChan/QQMusic-Parse" target="_blank" rel="noopener">这里</a>，有很详细的注释。</p><h3 id="使用"><a href="posts/72171293/#使用" class="headerlink" title="使用"></a>使用</h3><p>为了使接口更干净，没有使用 callback 函数，而是使用了 ES7 的新特性 async、await。尝试过使用 Babel 等工具转换成兼容更好的 ES5 代码，但是并没有成功，故而浏览器的兼容可能存在问题。</p><p>引入<a href="https://cdn.jsdelivr.net/gh/wincerchan/QQMusic-Parse@0.3/parse.min.js" target="_blank" rel="noopener">这个 JS 文件</a>：</p><p>接口：<code>await getMusic()</code>，如下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844981/blog/qqmusic_parse/sample.png" alt="示例"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">示例</figure></p><blockquote><p>注意：在调用 getMusic() 的时候一定要加上 await 关键字，否则返回的就是一个 Promise 对象了</p></blockquote><h3 id="配合-Aplayer"><a href="posts/72171293/#配合-Aplayer" class="headerlink" title="配合 Aplayer"></a>配合 Aplayer</h3><p>由于使用了 ES7 的新特性：async 和 await，故而 Aplayer 的配置文件也需要稍加改动：需要将原配置信息放至包含 <code>async</code> 关键字的函数内，随后调用这个函数，如下：</p><pre><code class="javascript">async function syncHand() {    new Aplayer(...);}syncHand();</code></pre><h2 id="结语"><a href="posts/72171293/#结语" class="headerlink" title="结语"></a>结语</h2><p>越来越认同保罗 · 格雷厄姆那句「黑客就像画家，工作起来是有心理周期的有时候，你有了一个令人兴奋的新项目，你会愿意为它一天工作 16 个小时。等过了这一阵，你又会觉得百无聊赖，对所有事情都提不起兴趣。」话了，简直就是我的写照：这四天大约花费了 30 小时（当然有很大一部分缘由是之前没怎么学过 JavaScript，修改一下别人的代码还行，自己写就有点「捉襟见肘」了），而估计后几天又会陷入「空窗期」了。</p><p>而 JavaScript 又是一门有很多<del>坑爹</del>特性的语言，也让我把初学者的坑基本上都踩完了（还是写 Python 爽）。同时也感觉学习新东西的最好、最快的方法就是实战，换句话说，抱着解决问题的目的去学习所学到的知识远比你抱着单纯学习目的所学的知识要更快、更牢靠。</p>]]></content>
      
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐解析 </tag>
            
            <tag> Javascript </tag>
            
            <tag> 网易云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一台 VPS 的正确打开方式</title>
      <link href="/posts/b3085a7/"/>
      <url>/posts/b3085a7/</url>
      
        <content type="html"><![CDATA[<p>其实像 Hexo 这样的静态博客框架本不需要服务器的，GitHub Pages 就提供免费的托管服务、且不限流量，但内心那点不安分因素总是撩拨着我：比如可以自定防护规则、可以搭建私有 Git 服务、可以搭建自己的 API（这个比较重点）、还能自己搭建 SS 服务，于是乎就买了一台 VPS。<a id="more"></a></p><p>由于我的博客使用了 <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">Cloudflare</a> 作为 CDN 服务商，而国内的电信和联通用户是默认解析到 Cloudflare 的美西结点，只有移动用户是解析到香港节点，所以为了 API 的快取速度（即：本机 -&gt; Cloudflare -&gt; VPS -&gt; Cloudflare -&gt; 本机），将服务器选在了洛杉矶，每年 20$、1T 流量、10G 固态、512M 内存，搭建一个静态博客和几个 API 足够了。</p><h2 id="简化-SSH-登录"><a href="posts/b3085a7/#简化-SSH-登录" class="headerlink" title="简化 SSH 登录"></a>简化 SSH 登录</h2><p>SSH 的安全验证有两种级别：</p><ol><li>基于密码：知道帐号和密码，就可以登录到远程主机，这种方式无法避免「中间人」攻击</li><li>基于密钥：创建一对密钥，并把公钥放至服务器，每次通信都会检验密钥，从而可以避免「中间人」攻击</li></ol><p>这里介绍第二种方法。</p><h3 id="生成密钥"><a href="posts/b3085a7/#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>如果在使用 GitHub 的时候已经生成过，那么这一步可以略过</p><pre><code class="bash">ssh-keygen                        # 默认生成长度为 2048 位的 RSA 密钥ssh-keygen -b 4096                # 可以通过添加参数 -b 设定长度</code></pre><p>随后就会生成一对密钥，默认为：id_rsa（私钥）、id_rsa.pub（公钥）</p><h3 id="上传至服务器"><a href="posts/b3085a7/#上传至服务器" class="headerlink" title="上传至服务器"></a>上传至服务器</h3><p>使用 ssh-copy-id 命令</p><pre><code class="bash">ssh-copy-id username@server-addr</code></pre><p>需要输入远程服务器的登录密码，随后 id_rsa.pub（公钥）会自动上传至服务器的 <code>~/.ssh/authorized_keys</code> 文件中</p><p>随后再进行 SSH 连接时，就不需要再输入密码了</p><h3 id="简化-IP"><a href="posts/b3085a7/#简化-IP" class="headerlink" title="简化 IP"></a>简化 IP</h3><p>虽不用输入密码，但仍需要输入服务器登录名和 IP 地址，所以需要将配置写入 <code>~/.ssh/config</code> 中：</p><pre><code class="yaml">Host wincer                # 这里填写简化名称  HostName ××.××.××.××    # 服务器 IP  Port 22                # 端口号  User root                # 远程登录用户名</code></pre><p>随后再进行 SSH 连接时，输入 <code>ssh wincer</code> 就可以登录了</p><p><code>scp</code> 命令也可以简化成以下：</p><pre><code class="bash">scp FILENAME wincer:PATH </code></pre><h2 id="作为-GitHub-Pages"><a href="posts/b3085a7/#作为-GitHub-Pages" class="headerlink" title="作为 GitHub Pages"></a>作为 GitHub Pages</h2><p>目前我的博客仍然在<a href="https://github.com/WincerChan/MyBlog" target="_blank" rel="noopener">该仓库</a>的 master 分支上保留有静态文件，仅作备份。</p><h3 id="添加-DNS-记录"><a href="posts/b3085a7/#添加-DNS-记录" class="headerlink" title="添加 DNS 记录"></a>添加 DNS 记录</h3><p>首先为 DNS 解析添加一条 「A 记录」，记录值为 VPS 所分配的 IP</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530857776/blog/vps_open_mode/a_record.png" alt="A 记录"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">A 记录</figure></p><h3 id="更改-Nginx-配置"><a href="posts/b3085a7/#更改-Nginx-配置" class="headerlink" title="更改 Nginx 配置"></a>更改 Nginx 配置</h3><p>SSH 登录后，编辑 Nginx 的配置文件 <code>vim /etc/nginx/nginx.conf</code>：</p><pre><code class="nginx">server {  listen        80;  server_name    blog.itswincer.com;  index         index.html;  root             /data/www/hexo;}</code></pre><p>可部署多个子域名，只需将 <code>server_name</code> 和 <code>root</code> 替换成相应的子域名和文件夹就可以了</p><p>可以先创建一个 <code>index.html</code>  测试一下，访问 <code>blog.itswincer.com</code>  看看是否成功</p><h3 id="加密-CI-配置"><a href="posts/b3085a7/#加密-CI-配置" class="headerlink" title="加密 CI 配置"></a>加密 CI 配置</h3><p>这一步可选，你也可以手动用 <code>scp</code> 命令将每次 <code>hexo g</code> 生成的静态文件上传至服务器，只不过略微麻烦。</p><p>Travis CI 的终端并不能支持用户输入密码，而 GitHub 的 Token 又无法在自己的服务器使用，故而只能采取<a href="#简化 SSH 登录">简化 SSH 登录</a>这步中类似的方法，即用私钥（即 id_rsa）去确认登录的身份，而将私钥公开至 GitHub 又是很危险的，所以我们需要将私钥加密：</p><pre><code class="bash">gem install travis        # 需要安装 gem，自备梯子travis login            # 输入 GitHub 的账户密码travis encrypt-file ~/.ssh/id_rsa --add        # 加密私钥，同时解密命令会添加至 travis.yml</code></pre><p>Travis CI 上的 known_hosts 只添加了 GitHub 下的三个域名，在使用 SSH 登录时，会提示是否添加该主机，同样因为终端无法输入，所以需现将服务器的 IP 与端口号添加至 known_hosts：</p><pre><code class="yaml">addons:  ssh_known_hosts: ××.××.××.××</code></pre><blockquote><p>这里忍不住吐槽一下 Travis CI 的加密：居然无法同时加密两个文件，而官方提供的方法是先把需要加密的文件压缩后加密，再解压。</p></blockquote><h2 id="搭建-API"><a href="posts/b3085a7/#搭建-API" class="headerlink" title="搭建 API"></a>搭建 API</h2><p>Hexo 这类静态博客所需的内存其实是挺少的，只需在后台运行一个 Nginx 进程就可以了，只运行一个 Nginx 进程时用「搬瓦工」的管理面板查看发现一共内存才使用了 40M，才用了不到 10%，所以就想着可以将之前写的「一言」API 放到我的服务器上，毕竟 Heroku 在国内访问还是挺不稳定的。</p><p>之前是用 Python3 写的，后来发现 VPS 自带的 Python 版本居然是 2.7，深知其中坑的我就没打算再用 Python 了，于是就是用 Node.JS 写了一个，本地调试了一下，就扔到服务器上了。第二天早上起来一看，发现内存占用居然到了 110M，一查看原来都是 Node 的占用，其中每一个 API 请求，平均就会多占用 2M 的内存，而且这个请求所占用的内存并不会释放，这样下去怕是没两天服务器就要爆内存了。</p><p>后来我也想过解决办法，比如用 PM2 这个工具来限制运行的内存，超过就重启 Node 环境，也想过定时重启服务器，再转念一想，我是大爷诶，凭啥要我去迁就辣鸡 Node.JS 的内存管理，你不行那我换一个具有垃圾回收的语言不就好了，那就 Java？好像也不太行，毕竟服务器就那么点硬盘，JDK 和 JRE 不知道要占用我多少空间，再者说来毕竟我可是 「Java 黑」。</p><p>那么就归纳一下我的需求：「占用内存小、部署方便、有垃圾回收（不会爆内存）、<del>不要 Java</del>」，然后考虑到编译型程序比解释型程序占用的内存更小，所以也就没考虑 Ruby &amp; Python，满足这些要求的好像也只有 Golang 了。</p><p>写了那么久的动态类型语言，突然要我写静态类型语言还真是有点不适应。在网上找了个例子，自己捣鼓了一个下午，就写出来了，算是一个勉强遵循「RESTful」风格的 API，开始还有日志功能，后来想想没必要，Nginx 也可以监控端口的访问日志，就删去了。</p><p>然后在 Nginx 配置端口</p><pre><code class="nginx">server {  listen        80;  server_name    api.itswincer.com;  location / {    add_header Content-Type &#39;application/javascript&#39;;    proxy_pass http://localhost:520;  }}</code></pre><p>而且 Golang 的部署也是很方便，将 *.go 拷贝就行了。跑了几天，内存占用稳定在 10M 上下。</p><p><a href="https://github.com/WincerChan/hitokoto" target="_blank" rel="noopener">该项目</a>已托管至 GitHub。</p><h2 id="搭建-SS"><a href="posts/b3085a7/#搭建-SS" class="headerlink" title="搭建 SS"></a>搭建 SS</h2><p>搬瓦工的 SS/SSR 搭建可以说是非常的方便了：</p><ol><li>先进入 KiwiVM 面板</li><li>在左侧点击 <code>Shadowsocks Server</code> 按钮</li><li>再点击 <code>install Shadowsocks Server</code> 按钮</li></ol><p>大约半分钟后，会提示已经安装完成：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530857869/blog/vps_open_mode/ss_install.png" alt="安装"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">安装</figure></p><p>再点击 <code>Go back</code> 按钮，回到以下界面，再点击 <code>Start</code>：<img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530857945/blog/vps_open_mode/ss_sample.png" alt="配置"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">配置</figure></p><p>SS 服务配置完成了，将以上信息填入 SS 客户端即可使用。</p><p>不过由于服务器是在美西，所以无论怎么优化（BBR），延迟都会在 160ms 以上，当然这对浏览网页看视频来说也没有什么影响。</p><blockquote><p>注意：<strong>当你使用 VPS 翻墙时，会同时计算上行、下行流量，也就是说如果翻墙使用 1G 流量，其实等于使用了 VPS 的 2G 流量</strong>。</p></blockquote><h2 id="搭建私有云笔记"><a href="posts/b3085a7/#搭建私有云笔记" class="headerlink" title="搭建私有云笔记"></a>搭建私有云笔记</h2><p>我最近有在思考私有云笔记的必要性，毕竟有了博客，那云笔记的作用可能就鸡肋了一点。但我还是选择了搭建。我的想法是：博客用于存放、发布一些较正式的文章，而笔记可以休闲一点（类似作文和日记的区别）。</p><p>回到正题，目前来说，体验好的云笔记要么需要会员、要么存在诸多功能限制，而我又不想多浪费钱，那么选择一个支持多设备（其实主要是解决手机设备）的同步方案并借助私有的服务器架设自然也就是最好的解决办法了。我选择了 <a href="../bf0413ac/">Nextcloud 作为解决方案</a>，并借助他的 WebDAV 功能作为多端同步工具。</p><p>手机端笔记软件选择的是<a href="https://www.coolapk.com/apk/me.tshine.easymark" target="_blank" rel="noopener">易码</a>，支持 Markdown 语法和 WebDAV 同步，电脑端可以选择直接用浏览器访问 Nextcloud，可以在线 Markdown 编辑和预览，当然也可以选择用 Nextcloud 同步至本地文件夹，并用其它编辑器打开就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> VPS </tag>
            
            <tag> Nginx </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑客与画家》读书笔记</title>
      <link href="/posts/a6c2a51d/"/>
      <url>/posts/a6c2a51d/</url>
      
        <content type="html"><![CDATA[<p>去年年底那会，花了大概一周多时间，阅读完了《黑客与画家》这本书，收获颇丰。可惜当时确实没多少时间整理出读书笔记，期末考试结束后，回到家中，本想着有时间能好好补一下博客，结果回家之后也没有想象中的空闲，看着「搬瓦工」把每年 20$ 的套餐补货了，于是就购置了一台服务器，将博客源码从 GitHub 上转移到了自己的服务器上，还拿 Golang 重写了一下「一言」的 API（扯远了，服务器的事等以后再开一篇博客说说），还补了一部早已加入想看列表却一直没看的番——「反叛的鲁路修」（嘻嘻 😌）。</p><p>直到今天，才终于有时间能把这篇读书笔记给整理出来了，笔记是直接在 Kindle 上标注的，然后用「<a href="https://www.clippings.io/" target="_blank" rel="noopener">Clippings.io</a>」这个工具导出（为什么 Kindle 不能开发一个好用一点的笔记管理系统呢！？）。</p><p>好在 azw3 版本在 Kindle 上的体验还不错，即使有代码段排版也没有垮掉，所以决定原谅你。</p><p>（👇以下为文摘）</p><hr><ol><li><p>在一个人产生良知之前，折磨就是一种娱乐。</p></li><li><p>程序写出来是给人看的，附带能在机器上运行。（这句话的出处是在《SICP》这本书的卷首语，作者引用了）</p></li><li><p>如果有必要的话，大多数物理学家有能力拿到法国文学的博士学位，但是反过来就不行，很少存在法国文学的教授有能力拿到物理学的博士学位。</p></li><li><p>人们喜欢讨论的许多问题实际上都是很复杂的，马上说出你的想法对你并没有什么好处。</p></li><li><p>小时候，每个人都会鼓励你不断成长，变成一个心智成熟、不再耍小孩子脾气的人。但是，很少有人鼓励你继续成长，变成一个怀疑和抵制社会错误潮流的人。<br>如果自己就是潮水的一部分，怎么能看见潮流的方向呢？你只能永远保持质疑。</p></li><li><p>不服从管教，其实是黑客之所以成为优秀程序员的原因之一。</p></li><li><p>公民自由并不仅仅是社会制度的装饰品，或者一种很古老的传统。公民自由使得国家富强。</p></li><li><p>经济学里有一条拉弗曲线（Laffer curve），认为随着税率的上升，税收收入会先增加后减少。我认为政府的力量也是如此，随着对公民自由的限制不断上升，政府的力量会先增加后减小。</p></li><li><p>极权主义制度只要形成了，就很难废除。（咳咳）</p></li><li><p>一定数量的盗版对软件公司是有好处的。不管你的软件定价多少，有些用户永远都不会购买。如果这样的用户使用盗版，你并没有任何损失。事实上，你反而赚到了，因为你的软件现在多了一个用户，市场影响力就更大了一些，而这个用户可能毕业以后就会出钱购买你的软件。</p></li><li><p>首先，管理企业其实很简单，只要记住两点就可以了：做出用户喜欢的产品，保证开支小于收入。</p></li><li><p>一个大学毕业生总是想「我需要一份工作」，别人也是这么对他说的，好像变成某个组织的成员是一件多么重要的事情。更直接的表达方式应该是「你需要去做一些人们需要的东西」。即使不加入公司，你也能做到。公司不过是一群人在一起工作，共同做出某种人们需要的东西。真正重要的是做出人们需要的东西，而不是加入某个公司。</p></li><li><p>要鼓励大家去创业。只要懂得藏富于民，国家就会变得强大。让书呆子保住他们的血汗钱，你就会无敌于天下。</p></li><li><p>财富是用工作成果衡量的，而不是用它花费的成本衡量的。如果我用牙刷油漆房屋，屋主也不会付给我额外工资的。</p></li><li><p>好设计是艰苦的设计。如果观察那些做出伟大作品的人，你会发现他们的共同点就是工作得非常艰苦。如果你工作得不艰苦，你可能正在浪费时间。</p></li><li><p>并非所有的痛苦都是有益的。世界上有有益的痛苦，也有无益的痛苦。你需要的是咬牙向前沖刺的痛苦，而不是脚被钉子扎破的痛苦。解决难题的痛苦对设计师有好处，但是对付挑剔的客户的痛苦或者对付质量低劣的建材的痛苦就是另外一回事了。</p></li><li><p>等到你逐渐对一件事产生热情的时候，就不会满足于模仿了。</p></li><li><p>「你用什么语言并不重要，重要的是你对问题是否有正确的理解。代码以外的东西才是关键。」这当然是一派胡言。各种语言简直是天差地别。</p></li><li><p>语言设计者之间的最大分歧也许就在于，有些人认为编程语言应该防止程序员干蠢事，另一些人则认为程序员应该可以用编程语言干一切他们想干的事。</p></li><li><p>允许你做某事的语言肯定不差于强迫你做某事的语言。</p></li><li><p>它们（指某些语言）的内核设计得并非很好，但是却有着无数强大的函数库，可以用来解决特定的问题。（你可以想象一辆本身性能很差的小汽车，车顶却绑着一个飞机发动机。）有一些很琐碎、很普遍的问题，程序员本来要花大量时间来解决，但是有了这些函数库以后，解决起来就变得很容易，所以这些库本身可能比核心的语言还要重要。所以，这些奇特组合的语言还是蛮有用的，一时间变得相当流行。车顶上绑着飞机发动机的小车也许真能开，只要你不尝试拐弯，可能就不会出问题。（内心 OS：我可没有针对 C++ 😏）</p></li><li><p>当我说 Java 不会成功时，我的意思是它和 Cobol 一样，进化之路已经走到了尽头。</p></li><li><p>如果摩尔定律依然成立，一百年后计算机的运行速度将是现在的 74 乘以 10 的 18 次方倍（准确地说是 73 786 976 294 838 206 464 倍）。</p></li><li><p>即使最后只是略微快了 100 万倍，也将实质性地改变编程的基本规则。如果其他条件不变，现在被认为运行速度慢的语言（即运行的效率不高）将来会有更大的发展空间。</p></li><li><p>效率低下的软件并不等于很烂的软件。一种让程序员做无用功的语言才真正称得上很烂。</p></li><li><p>自下而上的编程方法意味着要把软件分成好几层，每一层都可以充当它上面那一层的开发语言。这种方法往往会产生更小、更灵活的程序。它也是通往软件圣杯——可重用性（reusability）——的最佳路线。</p></li><li><p>罗伯特·莫里斯和我都很了解 Lisp 语言，我们相信自己的直觉，找不出任何不使用它的理由。我们知道其他人都用 C++ 或 Perl 开发软件，但是我们不觉得这说明了什么问题。如果别人用什么技术，你也用什么技术，那么你大概只能使用 Windows 了（日常黑 Windows）。</p></li><li><p>编程语言的特点之一就是它会使得大多数使用它的人满足于现状，不想改用其他语言。</p></li><li><p>如果从图灵等价（Turing-equivalent）的角度来看，所有语言都是一样强大的，但是这对程序员没有意义。</p></li><li><p>最不用担心的竞争对手就是那些要求应聘者具有 Oracle 数据库经验的公司，你永远不必担心他们。如果是招聘 C++ 或 Java 程序员的公司，对你也不会构成威胁。如果他们招聘 Perl 或 Python 程序员，就稍微有点威胁了。至少这听起来像一家技术公司，并且由黑客控制。如果我有幸见到一家招聘 Lisp 黑客的公司，就会真的感到如临大敌。</p></li><li><p>你的经理其实不关心公司是否真的能获得成功，他真正关心的是不承担决策失败的责任。</p></li><li><p>黑客欣赏的一个特点就是简洁。黑客都是懒人，他们同数学家和现代主义建筑师一样，痛恨任何冗余的东西或事情。</p></li><li><p>简洁性是静态类型语言的力所不及之处。只要计算机可以自己推断出来的事情，都应该让计算机自己去推断。举例来说，hello-world 本应该是一个很简单的程序，但是在 Java 语言中却要写上一大堆东西，这本身就差不多可以说明 Java 语言设计得有问题了。</p><pre><code class="java">public class Hello {  public static void main(String[] args) {    System.out.println(&quot;Hello, world!&quot;);  }}</code></pre><p>如果你从来没没有接触过编程，看到上面的代码可能会很奇怪，让计算机显示一句话为什么要搞得这么复杂？有意思的是，资深程序员的反应与你一样。</p></li><li><p>语言设计者应该假定他们的目标用户是一个天才，会做出各种他们无法预知的举动，而不是假定目标用户是一个笨手笨脚的傻瓜，需要别人的保护才不会伤到自己。如果用户真的是傻瓜，不管你怎么保护他，他还是会搬起石头砸自己的脚。</p></li><li><p>对黑客来说，选择编程语言的时候，还有一个因素比简洁更重要，那就是这种语言必须能够帮助自己做到想做的事。</p></li></ol><p>（👇以下为简评）</p><hr><p>这本书算是我从去年 7 月以来看完的第一本书了（《计算机程序的构造和解释》这本书太难了，看了前两章就没时间看，到还书的日期了），主要也在于作者 Paul Graham 的行文十分流畅，阮一峰的翻译也很到位，没有什么阅读障碍，还有「读至好几处都有一拍大腿，哎呀妈呀我也是这么想的啊」的想法，读完之后，思想也似乎豁然开朗了些。</p><p>关于第六章——「如何创造财富」，财富的获得是看你最终的结果，不是看你的付出（过程）。你做出了别人需要的产品，没人在乎你是做了三天还是三十天，他并不会因为你只做了三天就完成而少付给你报酬，更不会因为你是三十天完成而多给你报酬。还有关于「财富并不是固定不变的」这个理论，他给出了一个例子：你拥有一辆老爷车，你可以不去管它，也可以自己动手把它修葺一新这样的话，你就创造了财富：世界上因此多了一辆新的车，财富就变得多了一点，如果你把车卖掉，你得到的卖车款就会比以前更多，与此同时，你并没有使任何人变得更贫穷。正因为这个理由，他也建议我们多多创业，但也给我们泼了一盆「凉水」：创业的付出与回报总体上是成比例的，但是在个体上是不成比例的，不要把创业过于神话，但创业的确给了我们更多的可能。</p><p>还有就是关于编程语言的争论，作者似乎和我一样很喜欢黑 Java，认为 Java 是「进化之路已经走到了尽头」，因为编程语言并不应该限制程序员去做某些事情，即使这些事情是有害的。同时也抛出了另一个很新颖的说法：关于一百年以后，我们该使用什么样的编程语言？按照摩尔定律：预计 18 个月会将芯片的性能提高一倍，那时候电脑的运行速度将是现在的 73 786 976 294 838 206 464 倍，所以他认为现在某些因为运行速度略慢但编程起来更舒服的语言在未来反而是主流，即有更大的发展空间，同时作者似乎很推崇动态类型语言，因为写起来比静态类型语言方便、看起来也比较简洁。作者也不止一次的推崇了 Lisp，甚至不惜黑 Oracle 数据库、C++、Java（见上面第 30 条）。</p><p>最后，这本书算是 Paul Graham 的一本随笔文集，其中自然充斥着许多作者的价值观，如果这些价值观与你的价值观符合，那么你就会像「捡到宝」一样的对待这本书，反之，你会认为这本书的观点完全是和「邪教信条」一般，很庆幸，我是前者。</p><hr><p>处于马上步入社会的我啊，在迷茫的时候，不妨也多阅读几本好书。</p>]]></content>
      
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 黑客与画家 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>豆瓣电影 Top 250 数据分析</title>
      <link href="/posts/7a8186a0/"/>
      <url>/posts/7a8186a0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="posts/7a8186a0/#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间忙于备考，博客有段时间没更新了。其实早就有写这篇博客的想法了，原因嘛——我是比较喜欢看电影的，而且近来也对数据分析颇感兴趣，于是花了一天时间，先是爬取数据，再分析整理，数据可视化。<br><a id="more"></a></p><p>其实豆瓣对爬虫的防范算是比较高级了，即使伪造了 Cookie，还是会封禁 IP（还好我的代理 IP 多😏），甚至还会把你的帐号暂时冻结，其实要不是有一些电影词条必须登录才可见，也不用伪造 Cookie 这么麻烦。</p><h2 id="爬取"><a href="posts/7a8186a0/#爬取" class="headerlink" title="爬取"></a>爬取</h2><p>之前爬取都是用的正则匹配，这次首次接触了「<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">Beautiful Soup</a>」这个库，相见恨晚啊，不多说，先上代码：</p><pre><code class="python">def get_info(url):    movie = {}    proxies = {&#39;https&#39;: &quot;socks5://127.0.0.1:1080&quot;}    info = get(url, cookies=read_cookie(), proxies=proxies).text    soup = BeautifulSoup(info)    try:        # get movie name        name = soup.find(property=&#39;v:itemreviewed&#39;).get_text()        movie[&#39;name&#39;] = name.split(&#39; &#39;)[0]        # get movie year        year = soup.find(class_=&#39;year&#39;).get_text()        movie[&#39;year&#39;] = year[1:-1]        # get movie info        info = soup.find(id=&#39;info&#39;).get_text().replace(&#39; &#39;, &#39;&#39;).split(&#39;\n&#39;)        info = [x for x in info if x is not &#39;&#39;]        for item in info:            if &#39;导演:&#39; in item:                movie[&#39;director&#39;] = item[3:].split(&#39;/&#39;)            if &#39;主演:&#39; in item:                movie[&#39;actors&#39;] = item[3:].split(&#39;/&#39;)            if &#39;类型:&#39; in item:                movie[&#39;type&#39;] = item[3:].split(&#39;/&#39;)            if &#39;国家/地区:&#39; in item:                movie[&#39;region&#39;] = item[8:].split(&#39;/&#39;)            if &#39;语言:&#39; in item:                movie[&#39;language&#39;] = item[3:].split(&#39;/&#39;)            if &#39;片长:&#39; in item:                time = [                    search(r&#39;[\d]*&#39;, x).group() for x in item[3:].split(&#39;/&#39;)                ]                movie[&#39;time&#39;] = sorted(time, reverse=True)[0]        # get top250 info        movie[&#39;rank&#39;] = soup.find(class_=&#39;top250-no&#39;).get_text()        movie[&#39;number&#39;] = soup.find(property=&#39;v:votes&#39;).get_text()    except Exception as e:        print(e)    return movie</code></pre><p>其中片长取得是无删减版的片长，即不同版本中最长的。</p><p>地区、导演、语言等由于会出现多项内容，采取列表存放。</p><p><strong>以下统计数据截止至 2018/01/20</strong></p><h2 id="导演"><a href="posts/7a8186a0/#导演" class="headerlink" title="导演"></a>导演</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858719/blog/douban_movie_analytics/director.png" alt="电影导演统计"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">电影导演统计</figure></p><p>其中由「宫崎骏」和「克里斯托弗·诺兰」贡献最多，均为 7 部，具体为：</p><p>宫崎骏（日本）：</p><ul><li>《千与千寻》，上映年份为「2001」，排名为 No.6</li><li>《龙猫》，上映年份为「1988」，排名为 No.17</li><li>《天空之城》，上映年份为「1986」，排名为 No.33</li><li>《哈尔的移动城堡》，上映年份为「2004」，排名为 No.45</li><li>《幽灵公主》，上映年份为「1997」，排名为 No.80</li><li>《风之谷》，上映年份为「1984」，排名为 No.106</li><li>《魔女宅急便》，上映年份为「1989」，排名为 No.189</li></ul><p>克里斯托弗·诺兰（英国）：</p><ul><li>《盗梦空间》，上映年份为「2010」，排名为 No.9</li><li>《星际穿越》，上映年份为「2014」，排名为 No.25</li><li>《蝙蝠侠：黑暗骑士》，上映年份为「2008」，排名为 No.32</li><li>《致命魔术》，上映年份为「2006」，排名为 No.61</li><li>《记忆碎片》，上映年份为「2000」，排名为 No.132</li><li>《蝙蝠侠：黑暗骑士崛起》，上映年份为「2012」，排名为 No.168</li><li>《追随》，上映年份为「1998」，排名为 No.170</li></ul><h2 id="演员"><a href="posts/7a8186a0/#演员" class="headerlink" title="演员"></a>演员</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858744/blog/douban_movie_analytics/actor.png" alt="电影演员统计"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">电影演员统计</figure></p><p>其中由「张国荣」贡献最多（前三居然都是香港地区的演员），有 8 部，分别是：</p><ul><li>《霸王别姬》，导演为「陈凯歌」，上映年份为「1993」，排名为 No.2</li><li>《春光乍泄》，导演为「王家卫」，上映年份为「1997」，排名为 No.77</li><li>《射雕英雄传之东成西就》，导演为「刘镇伟」，上映年份为「1993」，排名为 No.88</li><li>《倩女幽魂》，导演为「程小东」，上映年份为「1987」，排名为 No.113</li><li>《东邪西毒》，导演为「王家卫」，上映年份为「1994」，排名为 No.131</li><li>《英雄本色》，导演为「吴宇森」，上映年份为「1986」，排名为 No.140</li><li>《纵横四海》，导演为「吴宇森」，上映年份为「1991」，排名为 No.149</li><li>《阿飞正传》，导演为「王家卫」，上映年份为「1990」，排名为 No.183</li></ul><h2 id="地区"><a href="posts/7a8186a0/#地区" class="headerlink" title="地区"></a>地区</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858784/blog/douban_movie_analytics/region.png" alt="电影地区统计"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">电影地区统计</figure></p><p>其中「美国」地区一枝独秀，超过半数以上电影的制片地区均为「美国」，且远超第二名「英国」。</p><ul><li>美国：140 部</li><li>英国：34 部</li><li>日本：32 部</li><li>香港：26 部</li><li>法国：26 部</li><li>德国：20 部</li><li>中国大陆：16 部</li></ul><h2 id="片长"><a href="posts/7a8186a0/#片长" class="headerlink" title="片长"></a>片长</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858819/blog/douban_movie_analytics/length.png" alt="电影片长"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">电影片长</figure></p><table><thead><tr><th>统计名称</th><th>数值</th></tr></thead><tbody><tr><td>中位数</td><td>118.0</td></tr><tr><td>均值</td><td>124.0</td></tr><tr><td>众数</td><td>98.0（10 次）</td></tr><tr><td>标准差</td><td>34.1</td></tr><tr><td>极差</td><td>218.0</td></tr></tbody></table><p>其中片长最长的电影为《指环王3：王者无敌》，导演是「彼得·杰克逊」，片长为 263 mins，排名是 No.30。</p><p>其中片长最短的电影为《萤火之森》，导演是「大森贵弘」，片长为 45 mins，排名是 No.150。</p><h2 id="年份"><a href="posts/7a8186a0/#年份" class="headerlink" title="年份"></a>年份</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858844/blog/douban_movie_analytics/years.png" alt="电影年份"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">电影年份</figure></p><table><thead><tr><th>统计名称</th><th>数值</th></tr></thead><tbody><tr><td>中位数</td><td>2002.0</td></tr><tr><td>均值</td><td>1998.6</td></tr><tr><td>众数</td><td>2004（13 次）</td></tr><tr><td>标准差</td><td>15.6</td></tr><tr><td>极差</td><td>85</td></tr></tbody></table><p>其中距今最久远的电影是《城市之光》，导演是「查理·卓别林」，年份为 1931 年，排名是 No.210。</p><p>其中距今最接近的电影有 5 部，均为 2016 年上映：</p><ul><li>《疯狂动物城》，导演是「拜伦·霍华德」等，制片国家为「美国」，排名为 No.43</li><li>《看不见的客人》，导演是「奥里奥尔·保罗」，制片国家为「西班牙」，排名为 No.83</li><li>《摔跤吧！爸爸》，导演是「涅提·蒂瓦里」，制片国家为「印度」，排名为 No.104</li><li>《海边的曼彻斯特》，导演是「肯尼思·洛纳根」，制片国家为「美国」，排名为 No.151</li><li>《你的名字。》，导演是「新海诚」，制片国家为「日本」，排名为 No.245</li></ul><p>嘿嘿，没想到吧，贡献电影最多的年份并不是「Top 250」前四名中有三部的 1994 年，而是 2004 年。</p><h2 id="评分"><a href="posts/7a8186a0/#评分" class="headerlink" title="评分"></a>评分</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530858864/blog/douban_movie_analytics/grade.png" alt="电影评分统计"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">电影评分统计</figure></p><table><thead><tr><th>统计名称</th><th>数值</th></tr></thead><tbody><tr><td>中位数</td><td>8.70</td></tr><tr><td>均值</td><td>8.78</td></tr><tr><td>众数</td><td>8.7（44 次）</td></tr><tr><td>标准差</td><td>0.27</td></tr><tr><td>极差</td><td>1.40</td></tr></tbody></table><p>其中最高分为 9.6 分，为两部电影所获得：</p><ul><li>《肖申克的救赎》，导演为「弗兰克·德拉邦特」，评分人数为 952814 人，排名为 No.1</li><li>《控方证人》，导演为「比利·怀尔德」，评分人数为 99908 人，排名为 No.41</li></ul><p>其中评分最低的电影为《疯狂的石头》，分数是 8.2 分，导演为「宁浩」，评分人数为 312083 人，排名为 No.230</p><p>可以看出豆瓣在进行「Top 250」排名时，并不是仅看评分，其中评分人数也占了很大的一部分比重，且似乎还有一些其它的因素，比如《血战钢锯岭》这部电影，评分 8.7，评分人数为 310624 人，却并没有上榜，同为评分 8.7，评分人数为 314940 的电影《看不见的客人》排名却早已进前百（No.83）。</p><p>最后，本人并非专业电影人士，无法针对以上数据提出建设性的建议，所做统计也仅仅是出于爱好，也愿自己能在闲暇时间里，多看几部电影。</p>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 豆瓣 </tag>
            
            <tag> 电影 </tag>
            
            <tag> 数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见，2017</title>
      <link href="/posts/5873b0c0/"/>
      <url>/posts/5873b0c0/</url>
      
        <content type="html"><![CDATA[<div id="aplayer" musicid="4010884"></div><script src="https://api.itswincer.com/music/v1/" async></script><p>关于 2017 年，其实还真的有挺多想说的，也早就有想写一篇博客的想法了，差不多到今天才抽得出时间写。</p><p>前几天和朋友聊天时谈到关于今年最有成就感的一件事，我想了一会，应该是搭建了这样一个博客。<a id="more"></a><br>当初搭建博客的初衷其实很单纯：就是为了好玩，谁知从此就沉迷于此了。在之后的写博客的过程中甚至产生了一种当一个作家也还不错的想法（当然前提是我的文章还有人看😋），现在想想，与高中时期相比，我的想法是发生了一些转变（在高中时期的我是绝不可能产生这种想法的）。正如开始所说的，现在遇到点什么事就想写下来，在往年，我一直没有写年末总结的习惯。这种「创作欲」，类似作家：将自己内心的想法写成作品，实则是把自己的内心剖析给别人看。也渐渐有些明白卡尔·雅斯贝尔斯的那句「文学和科学相比，的确没什么用处，但文学最大的用处，也许就是它没有用处」的意思了。</p><hr><p>买了 kpw3 后，我很乐意培养自己的阅读习惯。大学时间其实还是比较宽松的，但我反而不能每天抽出一小时阅读时间。有时候看书没看两分钟，随便手机一个通知消息就能让我转移注意力——这也是我的缺点：当自己没有全神贯注的时候，很容易被其它的事情所吸引注意力（这也算我很迫切想改掉的一个坏习惯），也导致看了近两周才把《黑客与画家》这本书看完（书推过两天会补上）。</p><p>是太浮躁了，也太焦虑了，或许是因为到了大三，面临找工作的压力，这压力不仅体现在看书上，有时我就莫名想快些完成正在做的事情，后来多次发现快速完成的事情必然是敷衍的，而事后一旦想起这件「敷衍」的事情，会更加浮躁。其实这样并不好，道理古人都说给我们听了：「欲速则不达」，以后我会尽量放慢自己做事情的速度，投入自己的内心，问问自己真正想要的是什么。</p><hr><p>今年有过一段恋情，对我产生了一些影响，有好，也有坏，让我成长了许多，也意识到了自己的不足。是的，一段感情之后一定会让你成长的。我在这个过程中有开心、难过、有挂念一个人，甚至有些「病态」的想法——不论好坏，这些特殊的情感都是之前没有体会过的。</p><p>恋爱的时候，双方的关系一定需要去协商、磨合，这也会让你学会更好的与人沟通，同时你会发现有些问题如果脱离恋爱范围的话根本就不是问题。在一段恋情过后，我们获得的不仅仅是恋情，还有更好的、获得了成长的自己。你会更了解自己，也更了解你需要找一个什么样的人。</p><p>要有自己的生活，要坚持做自己。要学会去爱，但要先学会爱自己。</p><hr><p>接下来说说工作。</p><p>其实我很反感工作——即学校安排给你作为学生所必须学习的课程，所以这学期的课我基本没怎么去，因为去了我也不会听：我无法强迫自己去听那些完全没有兴趣的课程，那有点像是别人强迫要你去做的事情，我天生是一个「猫型人格」（即：你让我向左转，我会不由自主的向右转，同时心里还有一点歉疚），所以有些不由自主地抗拒。</p><p>在<a href="../11ab0263/">之前写的那篇文章</a>中就说到，我想更加追随自己内心的意愿去活着。具体到工作的说法就是：我想开始「不以找到工作为目的的学习」，学习自然指的是编程。</p><blockquote><p>编程这么有趣的事，竟然还有钱赚      ——by c++ 之父</p></blockquote><p>我喜欢编程，我愿意将自己的时间花费在上面做一些有趣的小程序，即使这在旁人看来对以后的工作没有什么帮助，我不想抱着太强的目的性、太多的功利心去学习，因为这样，会让学习变味。同时我也乐于看着指尖下的一串串字符到显示器上显示出成果，会有一种小小的满足感。</p><hr><p>最后，小小说一下对 2018 年的展望（这绝对不是 FLAG！）</p><ul><li>希望继续读书的习惯</li><li>希望做事情的时候更专注</li><li>希望能多吃水果、生活作息规律</li><li>希望学会使用 To-Do list（如果能有效治愈我的拖延症的话）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 GnuPG 的使用谈谈密码学</title>
      <link href="/posts/4aa5d46d/"/>
      <url>/posts/4aa5d46d/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="posts/4aa5d46d/#前言" class="headerlink" title="前言"></a>前言</h2><p>我是一个很注重隐私的人，所以对密码学也就很感兴趣，这学期本着想进一步了解密码学的念头选了一门应用密码学的选修课（其实是为了混学分），虽说也没去过几次，但总想着这门课都快结束了总不能像没上过一样。这次借着 GnuPG（以下简称 GPG） 软件的使用也聊聊目前现代密码学中以密钥性质进行区分的两大加密方式。</p><a id="more"></a><h2 id="对称密钥加密"><a href="posts/4aa5d46d/#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h2><p>大概半年前，写过一个暴力破解加密压缩文件的程序，说白了就是跑字典，不断的试密码，这只能破解常用密码，一旦用户采用随机生成的密码就无从下手。我们平时所用到的压缩加密大多都是对称性加密，即我们用同一字符串对文件进行加密，又用同一字符串进行解密（此时为了保证安全，密码需越复杂越好）。</p><blockquote><p>明文 &lt;–> 密钥 &lt;–> 密文</p></blockquote><p>对称加密很方便也很快速，但是也带来了一个很大的缺点，由于加密和解密用的都是同一密钥，在传输的过程中，要求双方取得相同的密钥，这会大大降低加密的安全性（注意：这里所说的不安全不是说对称加密算法不安全，而是从密钥的获取程度来说的，即密钥知道的人越少越安全）。</p><p>在如今的互联网时代，通信双方分隔异地且素为谋面，则对称加密要求事先交换共同密钥的安全性也无法得到保障。</p><h2 id="公开密钥加密"><a href="posts/4aa5d46d/#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h2><p>那么为了解决对称加密的安全隐患，非对称加密诞生了。<br>与对称加密不同的是，非对称加密的加密和解密所需要的密钥是不同的，而且知道了其中一方，想推导出另一方（需要解决一个数学难题），在量子计算机时代来临之前，基本是不可能完成的。<br>因此公开其中一个密钥，并不会对密钥对的安全性有影响。<br>我们常说，公钥可以公开，私钥需要保密，但其实公钥和私钥在生成过程上，并无什么不同。并不是因为公钥公开后，解密出私钥困难，如果公开的是私钥，解密出公钥也同样困难。也就是说我们将一对密钥公开的那部分叫公钥，另一部分叫做私钥。并不是因为公钥，才能公开，私钥，就必须保密。</p><blockquote><p>明文 &lt;–> 公钥 &lt;–> 密文 &lt;–> 私钥 &lt;–> 明文</p></blockquote><p>前一段时间很火的勒索病毒就是采用的非对称加密中的 RSA-4096 加密算法。<br>想具体了解 RSA 加密原理的话，<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" target="_blank" rel="noopener">点击这里</a>。<br>由于公钥加密在计算上相当复杂，导致其加密速度相对于对称加密来说慢。</p><h3 id="数字签名"><a href="posts/4aa5d46d/#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>其中对称加密还有一个用处：数字签名。<br>对称加密的公钥和私钥在使用顺序上并没有什么要求，你可以用公钥加密，私钥解密，这就是非对称加密算法，同样可以用私钥加密，公钥解密，而这就成为数字签名。<br>由于私钥是发送者保存的，发送者用私钥加密后的信息，任何拥有该发送者的公钥的人都可以解密该信息。如果接收用发送者公开的公钥解开了，那么说明这个信息是确实是发送者发送的（没有被篡改，也不是伪造的）。公众也可以信赖这条信息确实来自与该用户，用户无法否认。</p><p>一般来说，不直接对消息进行签名，而是对消息的哈希值进行签名，并将签名附赠在消息一起发送。</p><p>总结一下二者的优点与缺点：</p><ul><li>对称密钥加密（使用最广泛的 AES）：加解密速度很快，强度也足够，但问题在于寻找一个安全通道让通信双方交换密钥很困难</li><li>公开密钥加密（使用最广泛的 RSA）：加解密速度很慢，但可以解决通信双方安全通道的问题</li></ul><p>故现在多将二者结合使用：需要加密的主体内容使用对称加密，对称加密的密钥使用非对称加密。</p><h2 id="GPG-教程"><a href="posts/4aa5d46d/#GPG-教程" class="headerlink" title="GPG 教程"></a>GPG 教程</h2><p>下面说说如何使用 GPG 软件加密文件。</p><p>GPG 支持的算法有很多：</p><blockquote><p>公钥：RSA, ELG, DSA, ECDH, ECDSA, EDDSA</p><p>对称加密：IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256,</p><p>​     TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256</p><p>散列：SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224</p><p>压缩：不压缩，ZIP，ZLIB，BZIP2</p></blockquote><h3 id="对称加密"><a href="posts/4aa5d46d/#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>使用对称加密很简单，只需要一行就可以：</p><pre><code class="bash">gpg --cipher-algo [对称加密算法名称] -c FILENAME</code></pre><p>随后会让你输入两次密码，就会生成一个 FILENAME.gpg 的文件在同目录下。</p><p>解密：</p><pre><code class="bash">gpg -o FILENAME -d FILENAME.gpg</code></pre><p>更多参数请输入 <code>gpg -h</code> 自行查阅。</p><h3 id="非对称加密"><a href="posts/4aa5d46d/#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><h4 id="生成密钥"><a href="posts/4aa5d46d/#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>（这里如果输入的是 <code>--gen-key</code> 的话，会省去一些步骤：自动设置密钥尺寸为 2048 位、有效期限为 2 年、注释留空）：</p><pre><code class="bash">gpg --full-generate-key</code></pre><p>回车后，出现以下文字：</p><pre><code class="bash">gpg (GnuPG) 2.2.3; Copyright (C) 2017 Free Software Foundation, Inc.This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.请选择您要使用的密钥种类：   (1) RSA and RSA (default)   (2) DSA and Elgamal   (3) DSA (仅用于签名)   (4) RSA (仅用于签名)您的选择？ </code></pre><p>选择 1：</p><pre><code class="bash">RSA 密钥长度应在 1024 位与 4096 位之间。您想要用多大的密钥尺寸？(2048)</code></pre><p>选择 4096：</p><pre><code class="bash">请设定这把密钥的有效期限。         0 = 密钥永不过期      &lt;n&gt;  = 密钥在 n 天后过期      &lt;n&gt;w = 密钥在 n 周后过期      &lt;n&gt;m = 密钥在 n 月后过期      &lt;n&gt;y = 密钥在 n 年后过期密钥的有效期限是？(0) </code></pre><p>如果想设置 5 年过期，输入 5y，我这里是自己私人用，选择 0，随后会让你确认以上信息正确与否，输入 y，系统会要求你提供一下个人信息：</p><pre><code class="bash">You need a user ID to identify your key; the software constructs the user IDfrom the Real Name, Comment and Email Address in this form:    &quot;Heinrich Heine (Der Dichter) &lt;heinrichh#duesseldorf.de&gt;&quot;真实姓名：电子邮件地址：注释：</code></pre><p>注释这一栏可以留空。</p><p>随后：</p><pre><code class="bash">您选定了这个用户标识：    &quot;×××××× &lt;××@×××.com&gt;&quot;更改姓名(N)、注释(C)、电子邮件地址(E)或确定(O)/退出(Q)？</code></pre><p>输入 o，会弹框提示设置一个密码，用于保护私钥。</p><p>与此同时，系统也会提示：</p><pre><code class="bash">我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。</code></pre><p>几秒后，系统就会提示密钥已经生成。</p><h4 id="导出密钥"><a href="posts/4aa5d46d/#导出密钥" class="headerlink" title="导出密钥"></a>导出密钥</h4><p>显示系统的私钥：</p><pre><code class="bash">gpg -K</code></pre><p>显示系统的公钥：</p><pre><code class="bash">gpg -k</code></pre><p>删除密钥：</p><pre><code class="bash">gpg --delete-keys [uid]gpg --delete-secret-keys [uid]</code></pre><p>其中 uid 可以使用邮箱代替，下同。</p><p>导出公钥：</p><pre><code class="bash">gpg -o public.key --export [uid]</code></pre><p>导出私钥：</p><pre><code class="bash">gpg -o private.key --export-secret-keys</code></pre><p>这样导出的 key 文件是二进制，不可读，加上 –armor 参数可以保存为 ASCII 码形式。</p><p>导入密钥：</p><pre><code class="bash">gpg --import [key 文件]</code></pre><h4 id="加密"><a href="posts/4aa5d46d/#加密" class="headerlink" title="加密"></a>加密</h4><pre><code class="bash">gpg -r [uid] -o FILENAME.gpg -e FILENAME</code></pre><p>-r 指定用户的公钥，如自己使用改为自己邮箱即可，-o 指定加密后输出文件名称。</p><h4 id="解密"><a href="posts/4aa5d46d/#解密" class="headerlink" title="解密"></a>解密</h4><pre><code class="bash">gpg -o FILENAME -d FILENAME.gpg</code></pre><p>会让你输入密码，即用于保护私钥的密码。</p><p>参考：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">公开密钥加密</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">GPG 入门教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> GPG </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web 性能优化（一）——使用 localStorage</title>
      <link href="/posts/a9d193c6/"/>
      <url>/posts/a9d193c6/</url>
      
        <content type="html"><![CDATA[<h2 id="localStorage-的意义"><a href="posts/a9d193c6/#localStorage-的意义" class="headerlink" title="localStorage 的意义"></a>localStorage 的意义</h2><p>为了针对我的网站提供更好的浏览体验（或者说更接近原生 App 的用户体验），在之前我就已经<a href="https://itswincer.com/posts/a0df572f/" target="_blank" rel="noopener">开启了 Service Worker 技术</a>，针对离线或者网速慢的情况下改善用户体验。但只有少数几个浏览器支持 （Chrome、Firefox、Opera），对目前手机端用户数最多的 QQ 浏览器、UC 浏览器却没有支持，也就是说该方法针对 QQ 浏览器和 UC 浏览器并没有什么实际优化。</p><a id="more"></a><p>而且对于 Service Worker，它并不能减少你的 HTTP 连接数量，只是拦截你的请求，减少 Stalled、Request sent 和 TTFB 的时间，见下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530845454/blog/web_optimization1/contrast.png" alt="左边从 SW 加载，右边正常加载" title="左边从 SW 加载，右边正常加载"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">左边从 SW 加载，右边正常加载</figure></p><p>针对以上两个问题，本博客采用另一种 HTML5 新技术 —— localStorage。</p><h2 id="localStorage-简介"><a href="posts/a9d193c6/#localStorage-简介" class="headerlink" title="localStorage 简介"></a>localStorage 简介</h2><p>localStorage 是在 HTML5 中新引进的一项存储技术，（如果不被清除）存储没有时间限制，但是有大小限制，一般（不同浏览器的限制有所差别）对于每个域名是 5 MB，对于存储一些纯字符串脚本，足够了。且目前<a href="https://caniuse.com/#search=localStorage" target="_blank" rel="noopener">大部分主流浏览器</a>均支持此项技术。</p><p>但是需要注意，Service Worker 是可以将所有的 HTTP 请求全部拦截，无论服务器的 Response Headers 中的 Content-Type 是什么类型都可以拦截从本地加载。而 localStorage 仅能存储静态资源（JavaScript/CSS）。</p><p>而存储在 localStorage 的中的静态资源所带来的优点就在于再次加载时不需要发起 HTTP 请求（Queueing、Stalled、Request sent、TTFB、Content Download 这些都不需要），这可以大大改善不支持 SW 技术的浏览器在访问我网站时的浏览体验。</p><h2 id="本博客的实践"><a href="posts/a9d193c6/#本博客的实践" class="headerlink" title="本博客的实践"></a>本博客的实践</h2><p>本博客采用的是 <a href="https://github.com/addyosmani/basket.js/" target="_blank" rel="noopener">basket.js</a> 方案，将 JavaScript 在 localStorage 中，利用 localStorage 的特性，减少 HTTP 连接的次数，以达到改善页面加载体验的目的。</p><blockquote><p>目前（2018/09）得益于<a href="/posts/50658b02/">新主题的 SPA 特性</a>，我已经移除 localStorage 的功能了：一方面是因为用户每次点击并不用重新请求 JavaScript 和 CSS 和 HTML，存储 JavaScript 有些没必要；另一方面是 localStorage 还存在安全隐患，故暂时去除 localStorage。</p></blockquote><p>为了避免每次刷新页面 main.css 加载先后页面出现抖动的问题，默认不将 main.css 放入 localStorage 中存储。</p><p>另一个问题是 NexT 在设计之初就很依赖于 js（会加载大量的 js 文件），而这些 js 文件的加载顺序是有要求的，jquery 必须优先被加载，否则就会出现奇怪的 bug，好在 basket.js 提供了控制加载先后顺序的方案。</p><h2 id="危险性"><a href="posts/a9d193c6/#危险性" class="headerlink" title="危险性"></a>危险性</h2><p>在<a href="https://www.zhihu.com/question/28467444" target="_blank" rel="noopener">这篇知乎回答</a>中，很详细的列出了 localStorage 的优点和缺点。</p><p>其中最危险的是网站出现 XSS 漏洞，就会被人利用将恶意代码注入到 localStorage 中，导致即便修复了 XSS 漏洞存储的代码依然是被篡改的。</p><p>好在 basket.js 可以提供将 localStorage 中的代码重新从网络加载的问题。具体见<a href="https://addyosmani.com/basket.js/" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> localStorage </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这盛世可如你所愿？</title>
      <link href="/posts/d67271d8/"/>
      <url>/posts/d67271d8/</url>
      
        <content type="html"><![CDATA[<script src=/js/crypto-js.js></script><script>function doDecrypt (pwd, onError) {console.log('in doDecrypt');const txt = document.getElementById('enc_content').innerHTML;let plantext;try {const bytes = CryptoJS.AES.decrypt(txt, pwd);var plaintext = bytes.toString(CryptoJS.enc.Utf8);} catch(err) {if(onError) {onError(err);}return;}document.getElementById('enc_content').innerHTML = plaintext;document.getElementById('enc_content').style.display = 'block';document.getElementById('enc_passwd').style.display = 'none';if(typeof MathJax !== 'undefined') {MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX],['PreProcess', MathJax.Hub],['Reprocess', MathJax.Hub]);}}</script><div id="enc_content" style="display:none">U2FsdGVkX19Sq/JAzcElLFp7TOp853jhWE2sKiNSuRlQL1xNxL2CFKRHd2b2Rgj2/BlpKYWqhnnaibwIrUTk1AWA3SAXLEsmKPwD5v7HWwuByhe9FPDpWvcISXj7GQb5k6IqJUv42N0/6GBWUI+peSZXhFGAUzQopsVLcGhVEHZeB2QdRxA4kVO8uCR/c1KLX3daE6HgWExEquJjsu37KKdpE0PY8CLdR0X9tMVzacNd/HOY/maZzx7bOb+KuVey1zpT9NHLLRMqsPgB5bWXmr94dbN2MK5DtN/MGeYmEWJyTb/GsRTGuulIXagSAStIy37jsiv450Ii+J6TkL5pOaVUsOg2HVFXjfbegY2iw8YHWSvgnXGtsFSIfpI/gVyddSuG1zIMntt3Ho3LSeNN25Kc/gkzXCTLw/E5N97QBDC7adrBmVxoMkPlNHHvn3UAzMDeuyqjRD9FpXF0BnvaRDQWjtcMUSUytCtVtYN0O/tW1LyuK8sax3UAm3bi38/CVJrBkAT7klZSwbg+4St4/Szgqn5Ht+LrSHrHp9FU4GYipFfUPgTjNK54mKCXuFACtaujccgJmuuTGTfLfVyxkH7Y+GjzRtKUwPFfu/qRwygV7D2fV1mpzWlQjoFsBb1OgRlXnPVLOMiP6fpU2sNqmX7JXj5xZJi5Zi89bF6Yhh8OX6FWPv5bWbFiworltCYVyB6hMmJqDw9ho94htrEforrz363Bd+MlKBcij2vfrAJp4REGLXq2R3nMf10GcPw/5Iyuzn+Gb1382KJr/Q+rP7EX5Nd/LPbresjOx2RABAl/EFRVn9v75WGFHDzV+mz/Xb4Bg9knoWE5UXwmWVodETpHl6mf0ThdujnzgCX2WRUrUoALTkihaMrvwSfHIug15u+h4a3Lbroh/LMOGFDNnSwuSDv9lCIPiQsr/+SH4bsUWuSPSuGhKEj0qsLThN6rar8KMRQPFfLCXp6Og2TfzG0BsCHLmZpReO7ARx7w1kl6SwKUDRRNOxUWZSyQHn32OXlH8/kMlUIBr4x5OpLo2z8Qrd1m838OnllvOUDkpLtNpaeopwt0TmqDT2vCysEkkVPOQHKZSPEyUKU3HPM66pgiFBhr3SkC+Vkm2PD4fqt/57vnUFWGhwI6DJOaGxkTLAG3h2vrcluVDGwH86dLnvHcPtYOZFX0L3NAG4y9HOC9o7oollPgEJWaOft4jMEo4b6xnq0rJzVcQgmPadgTCjpEAFOjUFiP2FhVWf1EkzBzzgj77e3t5g+ej4Yf5SA0ZjEx2t1EIKEzP3guBTRq1GR8OZ9waUrMAm3/0ZguDgR0BPNPcAqSJHURo+7Vh2dWxfZN/68/7bXZQQVNyul2nv35LzHhTcpLhliFERegcRsDZk3cyFQFkmB7I6cGdobGHf51+Bnt9pK/L/qlrfAB/gqU6ScbqzrYLdsoPg2ThxE8xsl5mrR8R2nm0XoBQ+iN6TWGvYy8Wc25FfDHSv7z6pfzSRKhv/Btj7d/GjskWgwVsqKruiZ1Hde7DlDFwIpBgU1ZcwJBd+jlvqHqxHDutB6EKbodd52tfIQXJZb/+Of17YwtgCQGbQo3nbcyBAD9XFTdAFLhh/9YFSFQ5sGiN2bRWSef0sHYxDNKDC2inFp5pMAaMKjpf0C2njlfMMLFyt6BZJlAKdrvHQBY8r0k9xPUEmJCiUoE3HDsInW8vy+q5stiP2+rw+FggNBIp7LSYXZqQ7t3ctVhbtA8dyJaPpDIWsXmGD/AEgGz1/f66T9IKRqY9NKtFJqlMZeqqB/wH74EniE/xlqrPBK+tsMH2CF2rAGqI8IsFK22Sbk/YAdKduO/Xcw8wWbrx6r1a2BRMIccs611HC4UjdL3I4XfvTmm9Z7/sjpHWIAIgnEXq8vK3a+u7SWwTwoaTnT7+JzSgBOdXWJ3qqH/ZeWJDzqHADuvwO2bBlNoLXzNq7tzJJcpS3v7P8FMBfsvp0K/EOGgHcFU5OhsFL5qxVAylH8M7RdhXqryIajd3lGaofJsqJ2y8smOtXDHcFmsJ11SDhEAydNaIa/slnKYDGcsFIXT0QBWq6AOrOPBkhz8hl1AQUstD4kFmAi8uAbJSvLp7XzTReuExusSIqu9YLBcMxZyJUqwzjvfIhElZcbxwFFJ/MF4i7bBdYOAWis4cbUvE5inwqlmazVUZ3mikMG3sxY0YHkhCoKT28ljanOxHvqgUCEdvmHFC42tzkrWHrjpk5f6F0JhdXWPmcqo60Oq6HTLPqSXfAxeNCwPSVw1Rffope3umgK6YHwAsn28gtobudQ4LSA57OpOZMnkF8uuuL2E189WG22kAea/ZiBvtVE9NePO114qWhwMrd+Un3L0uOdn1Jtz1GUESmHIpMw+OViyIzxQlbHHnGyfYcrcUfHZUObsdK4NHOv0DXka7DNpSggA3wnH+ddBOaryTOdcUcKb69OMBwX/sZC2X9rftKdqu5hAsnML3KxquMXZCsaU6aZObVFTEicioyi4oUPc6djzUl7mEgX18cBQwtFR0p47ovTtosZ4EGWQ9rU3DTjw8d2CKtHhuknUBHXdUtm/5zqPSDUCsVKirNWrMO6ZA0/HIQ8/68auE2UKeCFykNRe+VmyE4V1SkR5T5XlYY5fuXa3oJboVasL+93/JTetZVVmtRA0atweufdilU/WlQcSRQ8dNLjEdHk3INVLTpLU/wC8B32EwcF6MPLo8uAgalYLeTf/QH6qMr0fIKJZMLEYpQfmRTguPOIUZW1YZZ56T4W3i9x88S46cvcdh+PQlNZ75MfUM0fDkmYffAjLnSqO14dustwdy4FOaUOszUXryImRAe09JVc5gr5ArytUxP3LORBnA4VVnAS23yMCzUPpG3oztjiDBuVQqQ8QLToeeM/7osN7iKr6t3jMzvwpYJypPjpudRtpKfuUy+ua5Kgeu5Xj8QD2bNiG0INcTzboNR8/fPs9BjJ4pN0eyTtJraYwGjFlDBUrw4rFrnRK25kTT3Owh9mHTtUgPawC6QurLfUremTNakegHwimjyTn2XfX/OmP1zXkOUZokFciQT9T0cmFoB+XE7SjBk3rL1yfuI+vuNCRKSDCjcA7CJFOmHQA7Pi4+hR7GFRlYoUMamuWlSWKC8WdQ0ZnNlhgyW6nn/q3mkIdEvoRj58eB5ZhWKRZEqaupq+1xgFR6mOQtIpldaXxQKa+Z2mTIpB4QcYUe47ZECsl4oMlX22IscJctNOvEMVy3ON5pZXvc1LDfvtsHCxxiLjZ75mpfcgy5ohipmopcFKW1B2VTMx5Ff/qDlIdmVQweq/zBi57AzcQO2BMKUVMeGJqar3C1OXzYb7FlMxlm51rd58U+b0IlhS+mop8zpiWEla9akWOFpoUs2wKAonFqVpmzp7TaA1AvNYrzCkrJ63ozKxg26FIjuseX1pK47zCkQw9DuJwY+uil+DNh3PbNm3zfmooq7f1udNgO++Q2rird8cG2AxinHeqt13yiZa+XJ6LVuEgfm2tvHqhKJ/UqTS8cj5KSbduh+7cI7pjwzuwP3z9CKZlR7YCEK+i8BLWRwFgC2VtHBfCtn/NhPoD3t7C5E7Hp821TkpFNnifRndjcd2GDEraQHY81c8y0ifR4bEsCJDLpFsasavP0Q+nmoiwrfXC7s7MCVIlUL4tCdrj++TltGnKgW5TLfE0WmssMtOmVON5lr5cDjmq89Ot/Y22UOdIW4eZCkOKNARpQeB6pwbvBgDxyM0QFuznMPFhnEzh2KBYHyRLkGr+8UEWXO5Ki1SEdj9b09xtA7/IUtw4DuCRVTamcP0zvjdWfUVjy0aCA1g9WeHkFvK90P03fS1pcNifpd+9/D1/UiOHBqwuQPlGNY5u2gepD06xebg2tAcJCwg+R3e3SUrjuNlTHAU3PUS2/KZEsw4uw1c5L6oVsIgtXWift/0+G6PZizjZ0EhEgF//hSvotHLU904laTpFqFz9sISxYeunq7d+FJaNLEmR1NWbjorW5ZIk53Xu4srnm62OBcJiWxG878zRq7qeYSmawtC0n02FehfNPSlwrw4ghGcLGNKpIaJESZfeQlcf4xFfWBDRRpTCIZ2ZKlGxggonEQO0lOget/qqFFSQHq0wp44U2BCDpBjLFHrUW0TSxT1heKZYphslst5aMc1obug8LfOrMJT2hih4LpDyZiobJ7TLmzyWVxVOrAZufOWO/lMGWENoIJ5fIA71WHpVGP6DVPzavoj0QW7gJTHFlPk3JZixCuuUbWCzOgqgIk4pTvehQUdrji953aPvivqcFeWSn1EOt2T3K6zhX5UACNadUJ89qm2PiuYs/TSHN2ISxCdBMwGDJeFGNBzXz0WajrhdDArMyv6psvuFgWx6S5Zrdvw7we6jKiP4wVSmgnjyVEwjTM8WcWUU1/tl9WQdZhySPFhAoJ6AHfiFfGWtgnmVTOKCnkc+EA3/GUoQ7BfVF62xScE3Pf+A1qXERIAeY9/Nc24CFCJvyRLdnmmtCbU14wOgOfgElQ0/zN5/F2oX0vL2lP1u3/32/cdHYz1h8GQ+IlooIoZGS4MJqbHOGCMlwzOP5VY6yx7oyeAlrqqZ2QnuF9OofMdaBRt/7K/mTSStREohL+/giOkO8jOoicybDju0uL0rCMfU6MEznEpm0O3i+TNE90pvqYHHLHS0zkXtvb/oyYMY0YFOu3eaOpu0zEWkuyoiRGKPZxo=</div><div id="enc_passwd"> <iframe id="encrypt" height="0" frameborder="0" src="https://blog.itswincer.com/encrypt/"></iframe> <div class="encrypt"> <input type="text" onkeydown="document.querySelector(`#encrypt`).contentWindow.EnterPress" onkeypress="document.querySelector(`#encrypt`).contentWindow.EnterPress(event)" style="border-style: groove;border-bottom: 2px solid #0097a7;border-top:0px;border-left:0px;border-right:0px;height: 30px;width: 61.8%;cursor: auto;font-size: 102%;color: currentColor;outline: none;text-overflow: initial;background: #61616;padding-left: 5px" placeholder="输入密码后请按回车"> <div id="enc_error" style=" display: inline-block; color: #d84527; font: large; "> </div> </div> </div>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 政治 </tag>
            
            <tag> 国情 </tag>
            
            <tag> 严肃向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Poker 机械键盘开箱与简评</title>
      <link href="/posts/72474942/"/>
      <url>/posts/72474942/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一入外设深似海，从此钱财是路人。</p></blockquote><h2 id="初识"><a href="posts/72474942/#初识" class="headerlink" title="初识"></a>初识</h2><p>第一次知道外设这个概念，是在高中的时候，在网上偶然逛到机械键盘贴吧，只是当时忙于准备高考，而外设又价格不菲，于是念头便搁置了。</p><p>后来上了大学，买了笔记本，敲着笔记本自带的键盘「 shit 」一般的手感，才想到我应该买一把机械键盘了。于是就在网上找，看到一个段子说：</p><p>年轻人千万别碰哪些东西？</p><ol><li>毒品</li><li>游戏显卡</li><li>Hi-Fi 耳机</li><li>固态硬盘</li><li>机械键盘</li><li>Steam Origin Uplay</li><li>. . .</li></ol><a id="more"></a><p>当时大一，看到这个段子就笑了一笑，面对从一百多到一千多价位不等的机械键盘，还是比较理智的，听人说凯华轴的手感也是最接近 Cherry 轴的，于是就买了贼鸥 87，用了快两年，这期间：鼠标换了两个，耳机也买了两个，键盘却一直在用这一个，最近有几个键不灵了，正好趁着双十一，想着干脆换一把新的。心中对 Poker 那独特的键位种草已久，可惜京东没有 Poker II 的红轴版本，于是便入手了一代。</p><h2 id="外观"><a href="posts/72474942/#外观" class="headerlink" title="外观"></a>外观</h2><p>不愧是「二手东」，这饱经沧桑的包装盒：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844580/blog/poker_unpacking/packaging.jpg" alt="Poker 外包装" title="Poker 外包装"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">Poker 外包装</figure></p><p>关于包装盒，去拿快递的时候还发生了一个小插曲：当时京东的人问我手机尾号，我告诉了她，然后又问我是什么东西，我说是一把键盘，然后他就去找，找了半天，没找到，然后就问另一个人，说：“尾号是 6 的快件都在这里了吧，怎么没有键盘啊？”，然后转头问我：“键盘应该是挺大的吧？”，我说：“不，不大，挺短的”，然后她又去找小一点的包裹，结果一找就找到了。</p><p>回到寝室，迫不及待的拆开了包装：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844624/blog/poker_unpacking/package_contents.jpg" alt="Poker 包装内容" title="Poker 包装内容"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">Poker 包装内容</figure></p><p>这便是全家福了，包含：键盘本体、USB 连接线、RGB 的大键键帽、说明书、拔键器。</p><p>其中连接线带有屏蔽磁环，做工也算精良。</p><h2 id="60"><a href="posts/72474942/#60" class="headerlink" title="60%"></a>60%</h2><p>Poker 这一系列，最大的特点应当就是 60% 尺寸的设计了，准确来说是 61 键。相对于普通 87 键的键盘，尺寸更加玲珑小巧，省去了方向键和功能键，改为用 <code>FN</code> 的组合键来实现相应功能。方向键是用 <code>Fn</code> + WASD 来实现，不过，对于用 Spacemacs 的我来说，没啥影响，哈哈。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844657/blog/poker_unpacking/ontology.jpg" alt="键盘本体" title="键盘本体"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">键盘本体</figure></p><p>真正拆开的时候才发现 60% 尺寸带来的冲击有多么大。</p><p>说到组合键，<code>Fn</code> 与组合键的功能在侧刻上都已标注：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844715/blog/poker_unpacking/side_engraved.jpg" alt="Poker 的侧刻" title="Poker 的侧刻"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">Poker 的侧刻</figure></p><p><code>Fn</code> 与数字键组合就是 F1~F12。<code>Fn</code> + N、M、&lt; 分别是音量 -、+、静音等。</p><h2 id="轴和键帽"><a href="posts/72474942/#轴和键帽" class="headerlink" title="轴和键帽"></a>轴和键帽</h2><p>说道机械键盘的核心，应当就是轴体和键帽了。</p><h3 id="轴体"><a href="posts/72474942/#轴体" class="headerlink" title="轴体"></a>轴体</h3><p>轴体方面，采用的是 Cherry 原厂轴体，大键也是卫星轴设计。手感嘛，自然是没话说了。我这里购买的是红轴的版本，毕竟用了两年，还是红轴最为顺手。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844769/blog/poker_unpacking/cherry_axis.jpg" alt="Cherry 红轴" title="Cherry 红轴"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">Cherry 红轴</figure></p><h3 id="键帽"><a href="posts/72474942/#键帽" class="headerlink" title="键帽"></a>键帽</h3><p>键帽采用的是 PBT 材质，对于 ABS 来说，PBT 的好处就是绝不会打油。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844798/blog/poker_unpacking/hand_rest.jpg" alt="键盘 + 手托" title="键盘 + 手托"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">键盘 + 手托</figure></p><p>而且这款 PBT 键帽比我之前在网上购入的 PBT 键帽手感要更胜一筹，对着光看起来还闪着微弱的光，挺有意思。</p><p>在上图键 F、G、H 的侧面，可以看到有三个数字，分别是 15ms、0.1s、0.5s，这是允许用户调整按下键帽时的响应速度。这一点也是比较新奇。</p><h2 id="背部"><a href="posts/72474942/#背部" class="headerlink" title="背部"></a>背部</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844838/blog/poker_unpacking/front.jpg" alt="正面&#39;遗照&#39;" title="正面&#39;遗照&#39;"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">正面&#39;遗照&#39;</figure></p><p>相对与小巧玲珑的正面来说，背部就没有那么精致了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530844860/blog/poker_unpacking/back.jpg" alt="键盘背部" title="键盘背部"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">键盘背部</figure></p><p>四周是四个黑色的防滑垫，没有撑脚，可能是为了缩减体积来作出的取舍（当然键盘也设计成了前高后低的人体工学形状），防滑垫对我来说用处不大，因为我是把键盘放在鼠标垫上使用的。</p><p>中间那块金属铭牌上刻着一句英文：「<strong>The keyboard to cheer you up</strong>」（用这把键盘让你高兴起来！）</p><p>可能会注意到在底部的右侧有四个很小的指拨开关，作用分别是：</p><ul><li>开关 1：CAP = 左 WIN；CAP 灯 = 左 WIN 灯</li><li>开关 2：右 CTRL = `~</li><li>开关 3：左 WIN = 左 FN</li><li>开关 4：写保护键盘</li></ul><h2 id="编程功能"><a href="posts/72474942/#编程功能" class="headerlink" title="编程功能"></a>编程功能</h2><p>这一功能也算是 Poker 的特色了，目前还不是很了解，先放一放，过几天等了解了再补上。</p><h2 id="总结"><a href="posts/72474942/#总结" class="headerlink" title="总结"></a>总结</h2><p>换上附赠的 RGB 键帽后，白色素雅的 Poker 顿时骚了起来，哈哈。</p><p>由于是 mini 键盘，我的手托也就不那么合适（长了一截，无关紧要）。</p><p>一把 60% 键盘，精简了多余的按键和尺寸，为便携带来了许多好处（要是再赠送一个保护套就更完美了）。做工上乘，手感尚佳，不过大键的手感稍肉，Cherry 原厂轴加上 PBT 键帽，算的是 IKBC 的良心之作，值得入手。（怎么感觉写成了软文 23333</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开箱 </tag>
            
            <tag> 键盘 </tag>
            
            <tag> 评测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建一言 API 踩坑记录</title>
      <link href="/posts/f6e1eb2a/"/>
      <url>/posts/f6e1eb2a/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="posts/f6e1eb2a/#前言" class="headerlink" title="前言"></a>前言</h2><p>最初是在手机上一个叫「一言」的 App 接触到 Hitokoto，一见倾心啊。之前我看书时遇到写的不错的句子就喜欢摘录下来，在有自己的博客之后，本想是单独写一篇博文来存放，后来分析了 NexT 的布局后，就想到在侧栏底部可以加上一个单独的模块。</p><p>最开始，是使用别人的 API，后来觉得不太好，有诸多限制，而我又没有主机，于是就自己用 Javascript 写了一个本地的脚本。后来发现这样也不太好，因为本地的脚本每次加载势必要加载存放 Hitokoto 的 JSON 文件一次，当记录越来越多时，会消耗不必要的资源。毕竟每次只需要加载一条。<br><a id="more"></a></p><h2 id="获取一言"><a href="posts/f6e1eb2a/#获取一言" class="headerlink" title="获取一言"></a>获取一言</h2><p>最开始准备构建的时候，就遇到了一个问题：一言的数据库去哪里找。我翻便了 Google，基本都是提供 API 的，并不会将完整的数据库给你。这想想也正常，都把数据库给你了，那谁还用你的 API 呢。</p><p>我就花了一下午，写了一个爬虫，对准了几个提供 API 的网站，开始爬去数据。但是由于 API 产生的数据是随机的，难免会有重复。所以爬取之后又要查重，着实花费了我不少时间。</p><p>整个过程大概花了一天多，做成了一个 JSON 格式的文件，然后用 JS 导入成为数组，再随机访问数组的某一项，这便是最初“本地版”的「一言」了。</p><h2 id="转化数据库"><a href="posts/f6e1eb2a/#转化数据库" class="headerlink" title="转化数据库"></a>转化数据库</h2><p>先前已经说过，一旦数据多了起来。那么数组的访问和加载都是问题，而访问慢的问题可以用数据库来解决。而这学期正好在学数据库这门课，于是便花了点时间将 JSON 格式的数据转化成 sqlite 数据库。JSON 格式的数据有需要的只有 3 项，分别是 ID（用以标识每个 Hitokoto）、HITOKOTO（每个 Hitokoto 的内容）、SOURCE（每个 Hitokoto 的出处）。知道了这些，转化的代码就呼之欲出了：</p><pre><code class="python">import jsonimport sqlite3JSON_FILE = &quot;hitodb.json&quot;DB_FILE = &quot;HITODB.db&quot;conn = sqlite3.connect(DB_FILE)with open(JSON_FILE, &#39;r&#39;) as load_f:    data = json.load(load_f)    for line in data:        print(int(line[&quot;id&quot;]), line[&quot;hitokoto&quot;], line[&quot;from&quot;])        conn.execute(            &#39;INSERT INTO HITOKOTO (ID, HITO, SOURCE) VALUES ({a}, \&#39;{b}\&#39;, \&#39;{c}\&#39;)&#39;.            format(a=line[&#39;id&#39;], b=line[&#39;hitokoto&#39;], c=line[&#39;from&#39;]))        conn.commit()print(&#39;Successfully&#39;)conn.close()</code></pre><p>截至至本文发布，该「一言」数据库共收录了 880 条记录，以后我还会陆续添加。</p><h2 id="生成-API"><a href="posts/f6e1eb2a/#生成-API" class="headerlink" title="生成 API"></a>生成 API</h2><p>有了数据库，自然要构建一个 API，这里选用的是 Flask 框架提供的接口。</p><p>首先你需要安装 Flask，而 Python 是自带 sqlite3 模块的。直接上代码：</p><pre><code class="python">import sqlite3from flask import Flask, jsonifyapp = Flask(__name__)@app.route(&#39;/&#39;)def index():    return &#39;Hello World!&#39;@app.route(&#39;/api/&#39;)def get_hito():    conn = sqlite3.connect(&#39;HITODB.db&#39;)    hito = conn.execute(        &#39;select * from hitokoto order by random() limit 1&#39;).fetchone()    hitokoto = &quot;{} ——「{}」&quot;.format(hito[1], hito[2])    return &#39;function hitokoto() { &#39; + &#39;document.write(\&#39;{}\&#39;);&#39;.format(        hitokoto) + &#39;}&#39;@app.route(&#39;/api/json/&#39;)def get_json():    conn = sqlite3.connect(&#39;HITODB.db&#39;)    hito = conn.execute(        &#39;select * from hitokoto order by random() limit 1&#39;).fetchone()    hitokoto = {}    hitokoto[&#39;id&#39;] = hito[0]    hitokoto[&#39;hito&#39;] = hito[1]    hitokoto[&#39;source&#39;] = hito[2]    return jsonify(hitokoto)if __name__ == &#39;__main__&#39;:    app.run(host=&#39;0.0.0.0&#39;, debug=True)</code></pre><p>保存为 <code>run.py</code>。然后运行，打开 <code>http://0.0.0.0/api/</code> 如果没有意外的话，应当是成功了。接下来就是部署了。</p><h2 id="部署至-Heroku"><a href="posts/f6e1eb2a/#部署至-Heroku" class="headerlink" title="部署至 Heroku"></a>部署至 Heroku</h2><h3 id="环境准备"><a href="posts/f6e1eb2a/#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>一开始担心是没有主机，后来才知道有「<a href="https://dashboard.heroku.com/" target="_blank" rel="noopener">Heroku</a>」这个造福大众的云平台服务。</p><p>首先你需要安装 <a href="https://toolbelt.heroku.com/" target="_blank" rel="noopener">Heroku 客户端工具</a>，安装完成后，输入以下命令来验证安装是否成功：</p><pre><code class="bash">$ heroku --version</code></pre><p>安装成功后，在本地命令行登录 Heroku：</p><pre><code class="bash">$ heroku login</code></pre><p>然后输入你的帐号和密码即可</p><h3 id="创建应用"><a href="posts/f6e1eb2a/#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>可以在<a href="https://dashboard.heroku.com/apps" target="_blank" rel="noopener">网页端创建</a>，也可以在命令行创建：</p><pre><code class="bash">$ heroku create wincer-hito</code></pre><p>这里或许会提示你名字已经被使用了，换一个就好。接下来要初始化本地和远程代码库。</p><pre><code class="bash">$ mkdir hitokoto                    # 创建本地代码仓库$ cd hitokoto                        # 切换至本地仓库目录$ git init                            # 初始化本地仓库$ heroku git:remote -a wincer-hito    # 链接到远程仓库</code></pre><h3 id="部署应用"><a href="posts/f6e1eb2a/#部署应用" class="headerlink" title="部署应用"></a>部署应用</h3><p>除了代码和数据库外，两个必要的文件：<code>requirements.txt</code> 部署应用时，远程环境会自动安装 <code>requirements.txt</code> 文件中列出的依赖。我们 <code>requirements.txt</code> 文件内容如下：</p><pre><code class="python">Flask==0.12.2gunicorn==19.4.5</code></pre><p>接下来，我们如何告诉服务器如何运行这个文件呢？就要通过 <code>Procfile</code> 文件了。</p><pre><code>web: gunicorn run:app</code></pre><p>以上就是 <code>Procfile</code> 的内容。</p><p>另根据习惯，可自行添加对该项目的描述。</p><p>接下来就是激动人心的提交了：</p><pre><code class="bash">$ git add .$ git commit -m &quot;Init commit&quot;$ git push heroku master</code></pre><p>打开 <a href="https://wincer-hito.herokuapp.com/api/" target="_blank" rel="noopener">https://wincer-hito.herokuapp.com/api/</a> 看看效果吧！</p><h3 id="升级应用"><a href="posts/f6e1eb2a/#升级应用" class="headerlink" title="升级应用"></a>升级应用</h3><p>升级程序的时候，在所有的改动提交后，建议按照如下步骤升级：</p><pre><code class="bash">$ heroku maintenance:on$ git push heroku master$ heroku run python run.py deploy        # run.py改成自己的文件名$ heroku restart$ heroku maintenance:off</code></pre><h2 id="使用-API"><a href="posts/f6e1eb2a/#使用-API" class="headerlink" title="使用 API"></a>使用 API</h2><p>数据获取：</p><ul><li>请求地址：<a href="https://wincer-hito.herokuapp.com/api/" target="_blank" rel="noopener">https://wincer-hito.herokuapp.com/api/</a></li><li>请求方式：GET</li><li>返回函数名 hitokoto 的 js 脚本，本质为 document.write 函数的脚本</li><li>如果需要 json 格式的数据：<a href="https://wincer-hito.herokuapp.com/api/json/" target="_blank" rel="noopener">https://wincer-hito.herokuapp.com/api/json/</a></li><li>如果仅需要 hitokoto 主体：<a href="https://wincer-hito.herokuapp.com/api/main/" target="_blank" rel="noopener">https://wincer-hito.herokuapp.com/api/main/</a></li></ul><p>在你想使用「一言」的地方插入以下代码：</p><pre><code class="html">&lt;script type=&quot;text/javascript&quot; src=&quot;https://wincer-hito.herokuapp.com/api/&quot;&gt;&lt;/script&gt;&lt;script&gt;hitokoto();&lt;/script&gt;</code></pre><p>演示效果看侧栏。</p><p>注：由于是 Heroku 的主机是在美国，所以该 API 延迟可能会有一点高。</p>]]></content>
      
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API </tag>
            
            <tag> Hitokoto </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 与 Windows 10 用 GRUB 引导教程</title>
      <link href="/posts/ad42f575/"/>
      <url>/posts/ad42f575/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="posts/ad42f575/#前言" class="headerlink" title="前言"></a>前言</h2><p>去年暑假的时候，写了一篇如何装 Linux 和 Windows 10 双系统的文章发在了简书上，我写这篇文章的原因是当初装双系统确实是折腾了许久，网上也找不到一篇详尽的教程。由于去年对于写教程还不是熟练，而这一年多的使用过程也遇到了一些问题，所以就准备「Refactoring」这篇文章。<br><a id="more"></a></p><h2 id="EFI-分区"><a href="posts/ad42f575/#EFI-分区" class="headerlink" title="EFI 分区"></a>EFI 分区</h2><p>在教程正式开始之前，先花一点时间说明 EFI 分区的组成和作用。<br>首先，在你装了 Windows 之后，Windows 在装机过程中会将硬盘划分出一个约 100m 大小的分区，称为 EFI 分区这个分区就是起引导作用的。在资源管理器中是看不到的这个分区的，可以在磁盘管理中看到，管理则需要借助 <a href="http://www.diskgenius.cn/" target="_blank" rel="noopener">DG 工具</a>。便于说明，在装好了 Linux 之后，我将 EFI 挂载至 boot 分区截图：<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1xK8ydi6guuRjy0Fm7610DXXac.png" alt><br>可以看到，该分区包含 3 个文件夹（如果你没有装 Linux 的话，就只有两个），分别是 Boot、Microsoft 和 Manjaro，其中 Boot 文件夹就是 UEFI 引导所必需的文件。<br>我们继续打开 <code>Microsoft/Boot</code> 文件夹：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB10sdFdjbguuRkHFrd762.LFXa9.png" alt></p><p>这些文件就是启动 Windows 10 所必需的，包含了语言包、字体等，BCD 包含了 Windows 引导开始以后的信息。其中，<strong>bootmgfw.efi 是 Windows 默认引导文件</strong>。</p><ol><li>EFI/Boot/bootx64.efi</li><li>EFI/Microsoft/Boot/bootmgfw.efi</li></ol><p>以上是采用 UEFI 启动 Windows 10 的文件结构，也就是说，当你按下开机按钮的时候，首先 UEFI 找到 EFI 分区的 Boot 文件夹，然后加载 <code>bootx64.efi</code> 文件，读取文件信息，找到 <code>EFI/Microsoft/Boot/bootmgfw.efi</code>，按照 <code>bootmgfw.efi</code> 的要求，加载所需的启动信息，启动 Windows 10。</p><h2 id="准备工作"><a href="posts/ad42f575/#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在正式装系统之前，我们还需要做一些准备工作：</p><h3 id="关闭-Windows-的快速启动"><a href="posts/ad42f575/#关闭-Windows-的快速启动" class="headerlink" title="关闭 Windows 的快速启动"></a>关闭 Windows 的快速启动</h3><p>这个功能的作用是在于关机的时候不完全断电，类似将系统处于「休眠」状态，这样可以让开机更加迅速。但这也就导致了只能使用 Windows 系统。</p><h3 id="关闭-BIOS-的-Secure-Boot-的功能"><a href="#关闭-BIOS-的-Secure-Boot-的功能" class="headerlink" title="关闭 BIOS 的 Secure Boot 的功能"></a>关闭 BIOS 的 Secure Boot 的功能</h3><p>在默认情况下，UEFI 固件只会加载那些被签名的引导程序。在缺少 Secure Boot 功能的传统 PC 机上，恶意的后门程序可以加载自身，进而摇身一变伪装成一个引导程序。这样的话，BIOS 就会在启动的时候加载后门程序，这样它就可以躲过操作系统，把自己隐藏得很深。<br>但是不得不说，这对我们安装 Linux 造成了很大的困扰，也是直接导致我们重启到 Windows 10 后进不去 Linux 的原因。<br>首先我们要关闭这个功能：进入 BIOS 找到 Secure Boot，选择 disabled，这样就关闭了。当然，有些人进入 BIOS 会发现 Secure Boot 这个选项是灰色的（比如我的就是），这时你需要先给你的 BIOS 设一个密码，然后就能关 Secure Boot 了。</p><h2 id="安装-Linux"><a href="posts/ad42f575/#安装-Linux" class="headerlink" title="安装 Linux"></a>安装 Linux</h2><p>所有的准备都已经完成，这时就可以准备刻录 U 盘了，不推荐 UltraISO，经亲测，软碟通仅刻录 Ubuntu 能成功，其它绝大多数发行版都会失败。推荐「<a href="https://rufus.akeo.ie/" target="_blank" rel="noopener">Rufus</a>」和「<a href="https://sourceforge.net/projects/usbwriter/" target="_blank" rel="noopener">USBWriter</a>」，这两个软件都可以。<br>刻录完成后，重启按 <code>f12</code>，选择从 USB 设备启动，对于绝大多数发行版来说一路回车就行了，只需要注意一点：<strong>在选择挂载 boot 位置的时候，一定要挂载在 efi 分区</strong>，别的都不行。<br>重启之后，不出意外的话，你会直接进入 Windows 10，不要担心，这时 Linux 已经安装成功了，我们只需要将引导文件替换一下。</p><h2 id="替换引导文件"><a href="posts/ad42f575/#替换引导文件" class="headerlink" title="替换引导文件"></a>替换引导文件</h2><p>先用 DG 打开 EFI 分区，你会看到多了一个文件夹，名称取决于你安装的是哪一个发行版。我安装的是 Manjaro Linux，名称就是 Manjaro，打开之后会发现里面有一个名为 grubx64.efi 的文件，这就是启动 Linux 的引导文件。和 Windows 10 的 bootmgfw.efi 类似，我们想要用 grubx64.efi 引导代替掉 bootmgfw.efi，这样就可以用 GRUB 引导了。步骤：</p><ol><li>进入管理员命令行。方法：win + x，再按 a</li><li>输入 <code>bcdedit /set {bootmgr} path \EFI\Manjaro\grubx64.efi</code>。提示操作成功的话，就完成了。</li></ol><blockquote><p>注：经人提醒，如果输入以上命令提示「参数错误」的话，将 {bootmgr} 改为 ‘{bootmgr}’，原因是 PowerShell 和 CMD 语法的差别。</p></blockquote><p>至此，如果你安装的是除 Arch 之外绝大多数发行版，那么接下来就和你没有啥关系了，你已经成功了，好好享受吧！</p><p>开机之后会发现进入 GRUB 的引导了，通常会包含至少三个选项（以 Manjaro 举例）：Manjaro、Manjaro 高级选项和 Windows Manager。这就代表你已经完美的解决了 Windows 和 Linux 双系统引导的问题。</p><h2 id="修复-Windows-引导"><a href="posts/ad42f575/#修复-Windows-引导" class="headerlink" title="修复 Windows 引导"></a>修复 Windows 引导</h2><p>这一点是我安装 Arch Llinux 的时候发现的，Arch Linux 安装过程是手动安装的，在编写 GRUB 的时候会扫描不到 Windows Manager 所在的分区（当然可能不是所有人都会遇到），所以在 GRUB 界面可能会看不到 Windows Manager 选项，导致进不去 Windows 10，这里就需要手动编辑 GRUB 信息，我们打开 <code>/boot/grub/grub.cfg</code> 文件，发现里面确实没有 Windows 10 的启动信息，在后面加上：</p><pre><code class="bash">menuentry &quot;Microsoft Windows 10&quot; {  insmod part_get  insmod fat  insmod search_fs_uuid  insmod chain  search --fs-uuid --set=root $hints_string $fs_uuid  chainloader /EFI/Microsoft/Boot/bootmgfw.efi}</code></pre><p><strong>注意</strong>：</p><p>这里的 <code>$hints_string</code>，代表的是终端执行命令：</p><pre><code class="bash">sudo grub-probe --target=hints_string /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi</code></pre><p>后的输出；</p><p>而 <code>$fs_uuid</code> 代表的是：</p><pre><code class="bash">sudo grub-probe --target=fs_uuid /boot/efi/EFI/Microsoft/Boot/bootmgfw.efi</code></pre><p>的输出。</p><p>然后保存。在终端执行命令：<code>sudo grub-mkconfig -o /boot/grub/grub.cfg</code>，就 OK 了。</p><p>到此，Arch Linux 和 Windows 10 双系统也配置完毕了。</p><h2 id="附加问题"><a href="posts/ad42f575/#附加问题" class="headerlink" title="附加问题"></a>附加问题</h2><p>在使用这一年多的时间，遇到了以下的几个问题：</p><ol><li>在 Windows 10 进行了一个大更新后，会发现 GRUB 引导界面没有了，还是直接进入了 Windows 10，这时只需要按照 <code>替换引导文件</code> 的方法重新输入一遍命令就行。</li><li>使用 Linux 某个发行版一段时间之后，难免会想尝试一下另一个发行版。这时请务必将之前的发型版的引导文件删除，否则可能会出现无论怎么设置都无法进入 GRUB 的情况。例如：我之前用的是 Ubuntu，我现在换成了 Manjaro，我就需要用 DG 删除 EFI 分区的 Ubuntu 文件夹。</li><li>在我使用 Manjaro 更新了一次 Linux 的内核后，进不去 Windows 10 了，这个时候千万不要直接修复 Windows 10 引导，这会格式化 EFI 分区，只需要按上面 <a href="https://itswincer.com/posts/ad42f575/#%E4%BF%AE%E5%A4%8D-Windows-%E5%BC%95%E5%AF%BC" target="_blank" rel="noopener">修复 Windows 引导</a> 的方法编辑一下 GRUB 就可以了。</li></ol><p>最后：祝使用愉快。</p>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Windows </tag>
            
            <tag> GRUB </tag>
            
            <tag> 双系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kindle Papwerwhite 开箱 &amp; 简评</title>
      <link href="/posts/6619f85a/"/>
      <url>/posts/6619f85a/</url>
      
        <content type="html"><![CDATA[<blockquote><p>If you don’t let go old things, new ones wouldn’t come.                   —— Nicolas Wincer</p></blockquote><h2 id="前言"><a href="posts/6619f85a/#前言" class="headerlink" title="前言"></a>前言</h2><p>时间是在 9 月 27 日晚，我用了一年零 8 个月的 Kindle 正式宣布坏掉，原因是充不进电，我的第一反应是想着去修，后来还是打消了这个念头。主要是这个 Kindle 实在算是家族里的「老古董」了，我对 kpw3 的 300 ppi 也是种草许久，正好本着“旧的不去，新的不来”的观念，就入了一部 kpw3，其实在我想着要买  kpw3 的时候，是有点纠结 Voyage 的，因为用了快两年的 Kindle3 我已经习惯了实体翻页键，奈何囊中羞涩，只是为了这一个功能就要多花 600 +，有些不值当，想着等工作了之后直接上 Oasis。</p><a id="more"></a><p>其实我最近是比较少看书了，现在看的这本《雪中悍刀行》看了半年多才看了一半，上本《将夜》看了一年，一方面是看的书越多，品味自然也高了起来，现在写的好的小说是越来越少，之前一直很喜欢的几个作者要么更新是越来越慢（比方说：烽火戏诸侯，愤怒的香蕉）、要么是书的质量不如之前（比方说：烟雨江南、猫腻），有点担心自己看完了就书荒了。</p><p>我买 Kindle 不是为了亚马逊庞大的图书资源（我看书只自己在网上找），而是因为那块 E-ink 屏幕，而且因为 Kindle 那可怜兮兮的娱乐功能，用 Kindle 时可以更专注于看书。而国庆前几天一直忙于跑亲戚，所以直到今天才有空闲时间开箱。</p><h2 id="开箱"><a href="posts/6619f85a/#开箱" class="headerlink" title="开箱"></a>开箱</h2><p>这就是全部的配件（裸机 + 数据线）了：右边是卖家附赠的</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861449/blog/kindle_unpacking/pic1.jpg" alt></p><table><thead><tr><th>参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>阅读灯</td><td style="text-align:left">4 颗</td></tr><tr><td>解析度</td><td style="text-align:left">300 ppi</td></tr><tr><td>重量</td><td style="text-align:left">205 g</td></tr><tr><td>尺寸</td><td style="text-align:left">169 × 117 × 9.1 mm</td></tr><tr><td>屏幕</td><td style="text-align:left">6 吋</td></tr><tr><td>容量</td><td style="text-align:left">4 GB</td></tr><tr><td>连接</td><td style="text-align:left">Wi-Fi</td></tr><tr><td>运存</td><td style="text-align:left">512 mb</td></tr></tbody></table><h2 id="简评"><a href="posts/6619f85a/#简评" class="headerlink" title="简评"></a>简评</h2><p>开完箱经过简单的设置之后，迫不及待的从电脑传了几本书（谁都阻止不了我想读书的心情！）。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861472/blog/kindle_unpacking/pic2.png" alt></p><p>吐槽一下，这里是无法像多看一样做成文件浏览的形式，也就是说，即使你把一些书放进新建的文件夹里（便于归类管理），它也是直接在首页显示。</p><p>这就是阅读界面的选项了，选项少的可怜，而且页边距太大！我这已经设置页边距最小了。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861491/blog/kindle_unpacking/pic3.png" alt></p><p>得益于 Kindle 这块 4:3 的屏幕，看漫画可以说是比手机更具优势。清晰度是够了，要是屏幕再大一些就好了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861506/blog/kindle_unpacking/pic4.png" alt></p><p>如果想要购买正版书，就在上方的搜索按钮输入书名：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861524/blog/kindle_unpacking/pic5.png" alt></p><p>设置界面确实寒酸，不过想想要的只是纯粹的阅读体验，也就释然了：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861537/blog/kindle_unpacking/pic6.png" alt></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861554/blog/kindle_unpacking/pic7.png" alt></p><p>使用了<del>半个多小时</del>两天多了，简单总结一下感受：</p><ol><li>300 ppi 看起书来真的是太 ™ 爽了</li><li>在翻页的速度上，相比前几代快了不少，当然和手机还是没法比</li><li>阅读灯对我来说没啥用，我晚上看书也会开台灯</li><li>页边距实在太大，我都已经调整成了最小边距了，可还是留白太多</li><li>系统功能相比多看来说还是少了一些，比如无法设置全刷页数</li></ol><h2 id="后记"><a href="posts/6619f85a/#后记" class="headerlink" title="后记"></a>后记</h2><p>买 kpw3 之前其实还有一个顾虑，就是刷不了「多看」，我的电子书资源多是 「epub」格式的，而 Kindle 的原生系统是<strong>不支持</strong>「epub」格式的（我一直搞不懂为什么亚马逊不支持）现在我每一本书都要转成 「mobi」 才能在 Kindle 上看。</p><p>还有就是实体翻页键了，等我经济独立之后，一定要买 Oasis！</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开箱 </tag>
            
            <tag> Kindle </tag>
            
            <tag> 简评 </tag>
            
            <tag> 电子书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spacemacs 生存指北</title>
      <link href="/posts/2aa541e6/"/>
      <url>/posts/2aa541e6/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="posts/2aa541e6/#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="http://spacemacs.org/" target="_blank" rel="noopener">Spacemacs</a> 是一份 <a href="https://www.gnu.org/s/emacs/" target="_blank" rel="noopener">Emacs</a> 的配置文件，将 <a href="https://github.com/vim/vim" target="_blank" rel="noopener">Vim</a> 的快捷键移植到了 Emacs 上，可以提供 Vimer 至 Emacs 的无缝衔接。有了 Spacemacs，你不需要花那么多时间去学习 Emacs 就可以真正用 Spacemacs 开始做一些事情。</p><a id="more"></a><h2 id="安装"><a href="posts/2aa541e6/#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="bash">$ mv ~/.emacs.d ~/.emacs.d.bak$ git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d$ emacs</code></pre><p>Clone 至本地后，第一次使用 Spacemacs 时要加载一些 Package，以及根据你的喜好所生成的配置，建议一路回车。</p><p>此时会加载很多的 Package，如果没有挂代理的话，就会很慢很慢，可以采用 <a href="https://elpa.emacs-china.org/" target="_blank" rel="noopener">emacs-china</a> 的配置源。</p><h2 id="快捷键"><a href="posts/2aa541e6/#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>Spacemacs 基本使用的是原生 Vim 的快捷键，此前请先熟悉 Vim 的操作。我这里只贴出个人认为比较常用的快捷键。</p><h3 id="配置文件"><a href="posts/2aa541e6/#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><code>SPC f e d</code> 快速打开配置文件</p><p><code>SPC f e R</code> 同步配置文件</p><p><code>SPC q q</code> 退出 Emacs</p><p><code>SPC q R</code> 重启 Emacs</p><h3 id="文件管理"><a href="posts/2aa541e6/#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p><code>SPC f f</code> 打开文件</p><p><code>SPC f t</code> neotree 方式显示文件路径</p><p><code>Ctrl s</code> 搜索当前文件（需安装 ivy layer）</p><p><code>*</code> 另一种搜索文件的姿势（需将光标置于需搜索的单词处）</p><ul><li><code>n</code>  下一个匹配</li><li><code>N/p</code> 前一个匹配</li><li><code>r</code> 改变范围：当前屏幕，当前函数，当前 buffer</li><li><code>e</code> 编辑所有匹配（类似于替换）</li><li><code>/</code> 在当前 project 搜索</li></ul><p><code>SPC s c</code> 清除搜索高亮</p><p><code>SPC f R</code> 重命名当前文件</p><p><code>SPC f E</code> 使用 sudo 来编辑文件（当某些文件的权限是只读的时候）</p><p><code>SPC f D</code> 删除当前文件</p><p><code>SPC f r</code> 打开最近文件列表（需安装 ivy layer）</p><p><code>SPC f y</code> 复制当前文件的绝对路径</p><p><code>SPC f c</code> 复制文件</p><h3 id="buffer-管理"><a href="posts/2aa541e6/#buffer-管理" class="headerlink" title="buffer 管理"></a>buffer 管理</h3><p><code>SPC b b</code> 显示已经打开的 buffer</p><p><code>SPC b d</code> 关闭当前 buffer</p><p><code>SPC b h</code> 进入 Spacemacs 初始界面</p><p><code>SPC b N</code> 新建一个 buffer</p><p><code>SPC b R</code> 从自动备份的文件中恢复</p><p><code>SPC b Y</code> 复制整个 buffer 的内容</p><p><code>SPC b P</code> 将剪贴板的内容粘贴到整个 buffer</p><p><code>SPC Tab</code> 切换至上一个 buffer</p><h3 id="窗口管理"><a href="posts/2aa541e6/#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><p><code>SPC n(number)</code> 跳转至第 n 号窗口</p><p><code>SPC 0</code> 跳转至 neotree 侧边栏</p><p><code>SPC w m</code> 当前窗口最大化</p><p><code>SPC w s</code> 或 <code>SPC w -</code> 水平分割窗口</p><p><code>SPC w v</code> 或 <code>SPC w /</code> 竖直分割窗口</p><p><code>SPC w =</code> 平衡窗口</p><p><code>SPC w d</code> 删除当前窗口</p><p><code>SPC w o</code> 切换至其他窗口</p><p><code>SPC t g</code> 将当前窗口与其他窗口 黄金分割</p><h3 id="project-管理"><a href="posts/2aa541e6/#project-管理" class="headerlink" title="project 管理"></a>project 管理</h3><p><code>SPC p f</code> 在当前 project 中查找文件</p><p><code>SPC p p</code> 切换项目</p><p><code>SPC /</code> 在该项目中搜索字符串</p><p><code>SPC p R</code> 在项目中替换字符串，先输入「匹配」的，再输入「替换」的字符串（我一般不使用这种方式，我用<code>*</code>来替换）</p><h3 id="缩进代码"><a href="posts/2aa541e6/#缩进代码" class="headerlink" title="缩进代码"></a>缩进代码</h3><p><code>SPC j =</code> 自动对齐</p><p><code>SPC m =</code> 美化代码（不适用于所有语言）</p><h3 id="shell-操作"><a href="posts/2aa541e6/#shell-操作" class="headerlink" title="shell 操作"></a>shell 操作</h3><p><code>SPC &#39;</code> 打开/关闭 Eshell（需安装 shell layer）</p><p><code>SPC a s</code> 打开其它种类的 Shell</p><h3 id="中断操作"><a href="posts/2aa541e6/#中断操作" class="headerlink" title="中断操作"></a>中断操作</h3><p><code>C g</code> 输错命令时，可取消该次输入</p><h2 id="显示动态行号"><a href="posts/2aa541e6/#显示动态行号" class="headerlink" title="显示动态行号"></a>显示动态行号</h2><p>将  <code>dotspacemacs-line-numbers</code> 的值改为 ‘relative</p><h2 id="Magit"><a href="posts/2aa541e6/#Magit" class="headerlink" title="Magit"></a>Magit</h2><p>Spacemacs 中集成了 Git 管理工具，需先安装 git layer。</p><p>常用的快捷键：</p><table><thead><tr><th>git</th><th>magit</th></tr></thead><tbody><tr><td><code>git init</code></td><td><code>SPC g i</code></td></tr><tr><td><code>git status</code></td><td><code>SPC g s</code></td></tr><tr><td><code>git add</code></td><td><code>SPC g s</code> 弹出然后按 <code>s</code></td></tr><tr><td><code>git add currentfile</code></td><td><code>SPC g</code></td></tr><tr><td><code>git commit</code></td><td><code>SPC g c c</code></td></tr><tr><td><code>git push</code></td><td><code>SPC g P</code></td></tr><tr><td><code>git log</code></td><td><code>SPC g l l</code></td></tr><tr><td><code>git checkout xxx</code></td><td><code>SPC gn C</code></td></tr><tr><td><code>git checkout -- xxx</code></td><td><code>SPC g s</code> 弹出然后按 <code>u</code></td></tr><tr><td><code>git reset --hard xxx</code></td><td><code>SPC g s</code> 弹出然后按 <code>x</code></td></tr></tbody></table><h2 id="守护模式"><a href="posts/2aa541e6/#守护模式" class="headerlink" title="守护模式"></a>守护模式</h2><p>终端使用 <code>emacs -daemon</code> 以守护模式开启 emacs：</p><p><code>$ emacsclient -c</code> 打开 Emacs GUI<br><code>$ emacsclient -t</code> 打开 命令行 Emacs</p><p>当开启守护进程时，点击关闭按钮后进程还是会保留在后台，如果想要彻底关闭 Emacs 可以：<code>SPC q q</code> 或者<code>$ killall emacs</code></p><p>以下是我针对我常用的一些语言做的一些特殊的设置：</p><h2 id="C-C"><a href="posts/2aa541e6/#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><p>我没有采用 Spacemacs 提供的 c/c++ layer，而是采用的 <a href="https://github.com/Sarcasm/irony-mode" target="_blank" rel="noopener">Irony-Mode</a>，因为原生的 c/c++ layer 自动补全需要 ycmd，而 ycmd 安装配置起来实在太麻烦了。</p><h3 id="快捷键-1"><a href="posts/2aa541e6/#快捷键-1" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>:gdb</code> 启用 gdb 调试</p><p><code>SPC c C</code> 编译程序</p><ul><li>默认是用 <code>cmake</code> 编译，可以替换成 <code>clang/gcc -g main.C -o main</code> （这些参数会被记住）</li></ul><h2 id="Python"><a href="posts/2aa541e6/#Python" class="headerlink" title="Python"></a>Python</h2><p>Python 用的 Spacemacs 自带的 python layer，添加了一些参数：</p><pre><code class="emacs-lisp">(python :variables        python-enable-yapf-format-on-save t ;; 当保存的时候自动 `yapf&#39; 美化        python-fill-column 80                ;; 开启 80 列的提示        python-sort-imports-on-save t)        ;; 当保存的时候自动排序导入的包</code></pre><h3 id="快捷键-2"><a href="posts/2aa541e6/#快捷键-2" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>, c c</code> 运行当前文件</p><p><code>, =</code> 美化代码</p><p><code>, &#39;</code> 打开 IPython repl</p><p><code>, g</code> 跳转至定义处：</p><ul><li><code>, g g</code> 在当前窗口跳转至定义处</li><li><code>, g G</code> 在另一窗口跳转至定义处</li><li><code>, g b</code> 回到原处</li></ul><p><code>, s</code> 将当前文件发送至 repl:</p><ul><li><code>, s b</code> 将当前 buffer 发送至 repl</li><li><code>, s f</code> 将当前 defun 发送至 repl</li><li><code>, s r</code> 将当前选中内容发送至 repl</li></ul><h2 id="JavaScript"><a href="posts/2aa541e6/#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>我将 JavaScript layer 自带的 repl 换成了 nodejs，自带的不太好用。</p><pre><code class="emacs-lisp">(javascript :variables            tern-command &#39;(&quot;node&quot; &quot;/home/wincer/.npm-global/bin/tern&quot;)    ;; 指定 `tern&#39; 的路径            javascript-disable-tern-port-files nil)</code></pre><p>设置了一些快捷键：(o 开始的默认为用户自定义的)</p><p><code>SPC o s i</code> 启动 nodejs repl</p><p><code>SPC o s b</code> 将当前 buffer 发送至 repl</p><p><code>SPC o s r</code> 将选中内容发送至 repl</p><p><code>SPC o s l</code> 将当前行发送至 repl</p><h2 id="Scheme"><a href="posts/2aa541e6/#Scheme" class="headerlink" title="Scheme"></a>Scheme</h2><p>我是在学 sicp 时才用到 Scheme，所以采用的 Scheme 实现是 MIT-Scheme，并将其设置为默认 repl：</p><h3 id="快捷键-3"><a href="posts/2aa541e6/#快捷键-3" class="headerlink" title="快捷键"></a>快捷键</h3><p><code>, &#39;</code> 切换至 repl</p><p><code>, s</code> 评估算式：</p><ul><li><code>, s b</code> 计算当前 buffer</li><li><code>, s e</code> 计算最后一个表达式</li><li><code>, s f</code> 计算当前定义的函数</li><li><code>, s r</code> 计算当前选中的内容</li></ul><h2 id="结语"><a href="posts/2aa541e6/#结语" class="headerlink" title="结语"></a>结语</h2><p>我的 Spacemacs 配置放在了 GitHub 上，<a href="https://github.com/WincerChan/Spacemacs-Config" target="_blank" rel="noopener">这是地址</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spacemacs </tag>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写给 20 岁的自己</title>
      <link href="/posts/11ab0263/"/>
      <url>/posts/11ab0263/</url>
      
        <content type="html"><![CDATA[<blockquote><p>凡心所向，素履所往，生如逆旅，一苇以航。</p></blockquote><p>一直很喜欢海子对于时间的说法——“打马而过”。就像我还没来得及细数，20 个年头匆匆已逝。没有那么多时间细想，这一天就这么来临了，来不及回忆过去，也来不及憧憬未来，一眨眼，就发现自己已经 20 岁了。</p><p>在许久之前，我便对自己的 20 岁有过憧憬，想着，20 岁的我会在哪里，做着什么事情。是有了一项划时代的发明，成为震惊世界的奇才；还是偏居一隅，发出「天地与我并生 万物与我为一」的感慨。是的，我希望自己能真实的活着，不像那些忙忙碌碌一辈子不知道为谁而活的人那样。不在意别人的眼光，不为了生存而活。</p><a id="more"></a><p>但是，现在的我，也就只是在大学里，做着大多数人应该做的事情，过着大多数人应该过的生活。看来在这二十年的生命中，我还是不够坚韧。</p><p>我想我是不甘于于平凡的，很小的时候，我就会告诉自己，不要去重复别人做过的事情，因为我是独一无二的（后来才知道原来小孩都会有这样的想法），我有自己的事情去做。现在回想起来，还真的觉得挺可爱的。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1dc97B5OYBuNjSsD4762SkFXaC.png" alt="搏击俱乐部" title="搏击俱乐部"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">搏击俱乐部</figure></p><p>《搏击俱乐部》里泰勒抢了一个便利店员（雷蒙）的钱包并拿枪指着他的后脑勺，雷蒙跪在地上颤抖着，泰勒问他想做什么，同时扳下击锤，雷蒙颤抖得更厉害了。</p><p>“兽医”，雷蒙颤几乎是带着哭腔说了出来。</p><p>“我知道了，我要拿走你的驾照。我随时会去看你，我知道你住在哪”，泰勒说。</p><p>“要是在六星期内你没当上兽医，你就死定了”，泰勒把钱包还给他了，并让他跑回了家。</p><p>同行的杰克表示不理解：“拜托 那有什么好玩的？那样做有什么意义？”</p><p>泰勒背对着他，“明天会是他一生中最美的一天，他的早餐会比我们吃过的都甜美。”</p><hr><p>蒋勋在《孤独六讲》中写到，好像只有孤独，生命可以变得丰富而华丽。</p><p>无人理解的泰勒，他的人生想必是华丽到了极点。他内心所真正向往的地方是只有自己知晓的一方天地，他会去做自己想做的事，并因此让自己的生命变得有意义起来。</p><p>这一切都是因为做自己喜欢的事情，无关别人，只是为了自己的热爱。</p><p>从小到大，父母乃至老师灌输的思想就是：用心念书，从市重点初中，到省重点高中，再到一本大学，过更好的生活。</p><p>是的，过去二十年我仿佛就是按照这个既定的轨迹，一步一步活成了别人眼中的自己。等到我现在可以反思我的生活时，才发现<strong>我想做的事情</strong>和<strong>我应该做的事情</strong>那条清楚的界限早已模糊不清，长期的压力仿佛让自己对一切都失去了兴趣。</p><p>我抗争过吗？当然抗争过，不过一个人的力量终究是难以改变什么，泰勒也深知这一点，才会成立“搏击俱乐部”。</p><p>这样的生活很可怕。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1O5AhKhSYBuNjSspj76073VXaT.png" alt="三傻大闹宝莱坞" title="三傻大闹宝莱坞"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">三傻大闹宝莱坞</figure></p><p>《三傻大闹宝莱坞》兰彻对法汗说：</p><blockquote><p>知道我为什么第一名吗？因为我热爱机械，工程学就是我的兴趣所在，知道你的兴趣吗？这就是你的兴趣……跟工程学说拜拜，跟摄影业结婚，发挥你的才能，想想迈克尔杰克逊的爸爸硬逼他成为拳击手，拳王阿里的爸爸非要他去唱歌，想想后果多可怕？</p></blockquote><p>是的，被别人强迫去做自己不喜欢的事情，是很可怕的。更可怕的是，被强迫的多了，就会麻木。</p><p>从小学到高中，我的生活一直像父母要求的那样，努力，不轻言放弃。被强迫穿着这许多外衣的我，沿着既定的轨迹一点一点的行进。</p><p>如果说，之前的我，不是为自己而活，那么从此时此刻，我就要像小时候自己想的那样，不为别人而活，为自己真实地活着。去寻找自己喜欢且甘之如饴的事情。</p><hr><p>作家吴晓波在《把生命浪费在美好的事情上》中写到：</p><blockquote><p>喜欢，是一切付出的前提。只有真心的喜欢了，你才会去投入，才不会抱怨这些投入，无论是时间、精力还是感情。</p></blockquote><blockquote><p>在这个世界上，不是每个国家每个时代每个家庭的年轻人，都有权利去追求自己所喜欢的未来，所以，如果你侥幸可以请千万不要错过。</p></blockquote><p>我还年轻，以后的路还很长，我可以做得更好。</p><p>不要害怕前路，我会迈着缓慢而坚定的步伐走下去。</p><p>我不要自己做到最好、最优秀，只希望能在接下来的时光里，变得柔软而坚韧。</p><p>最后，二十岁快乐，送给自己。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
            <tag> 感想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见 LiveRe，拥抱 Disqus</title>
      <link href="/posts/e5d13eb/"/>
      <url>/posts/e5d13eb/</url>
      
        <content type="html"><![CDATA[<p>没错，我又双叒叕换评论系统了，从最初的网易云跟帖，到后来的 LiveRe，再到现在的 Disqus，两个多月就换了好了三四次（中间从 LiveRe 切换过一次 Disqus，后来又换回来了）了，仿佛我在折腾这些非博客主体的路上越走越远，也幸好我的博客才建成，没啥人留言，不然就得不偿失了。</p><a id="more"></a><h2 id="LiveRe"><a href="posts/e5d13eb/#LiveRe" class="headerlink" title="LiveRe"></a>LiveRe</h2><p>其实 LiveRe 真的做的挺棒的，中国的本地化做的更是没话说，支持国内的社交媒体：微信、QQ、百度、人人、豆瓣、新浪，国外的支持的就更多了，上次我因为评论框颜色的问题发送了邮件，结果不到 12 个小时 LiveRe 中国区的负责人亲自发邮件解答了这个疑问，就这点来说简直太良心了。</p><p>但是美中不足的是：</p><ol><li>不支持游客评论（其实这点倒无关紧要）</li><li>不支持导出评论</li><li>在我博客的加载速度问题</li></ol><p>我最不能忍受的就是第三点了，由于我博客是采用了 CloudFlare 的 Keyless SSL 技术，流量都会走 CloudFlare 的 CDN 节点，但是由于节点在国外，国内访问速度实在是太慢了，每次点开网页都会看到圈圈不停的转，这简直不能忍啊，于是我就想做一个延时加载的，后来想想，既然都要做延时加载的了，那我为什么不干脆换成 Disqus 呢？</p><h2 id="Disqus"><a href="posts/e5d13eb/#Disqus" class="headerlink" title="Disqus"></a>Disqus</h2><p>那么说到 Disqus，之前为什么会不用 Disqus 呢，主要还是担心国内不会翻墙用户无法评论的问题，后来想想其实这点不重要，因为：</p><ol><li>我的博客只是在 <a href="https://www.google.com/webmasters/tools/home#utm_source=zh-CN-wmxmsg&amp;utm_medium=wmxmsg&amp;utm_campaign=bm&amp;authuser=0" target="_blank" rel="noopener">Google Search Console</a> 添加了信息，没有在百度站长平台添加，<del>所以百度是搜索不到我的网站</del>现在貌似已经可以搜到了；既然是从谷歌搜索进入的话，那自然也就不存在不会翻墙的问题了；</li><li>不是所有的用户都需要看评论，于是我就把评论功能隐藏了起来，<del>需要的话点击下方按钮加载评论</del>，如果网络比较好的话，会自动显示，否则需要手动点击；</li></ol><p>这样优化过后，总算好多了。</p><h2 id="延迟加载"><a href="posts/e5d13eb/#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><p>原理嘛，先用 ajax 异步发送一个 get 请求至 Disqus 服务器，接收成功则屏蔽按钮，加载评论；超时则自动断开，并显示加载按钮：</p><pre><code class="ejs">&lt;button class=&quot;disqus_click_btn&quot;&gt;点击以加载评论&lt;/button&gt;&lt;%/*延迟加载 disqus，timeout 可以自己设置时长*/%&gt;&lt;script type=&quot;text/javascript&quot; id=&quot;disqus-lazy-load-script&quot;&gt;    $.ajax({    url: &#39;https://disqus.com/next/config.json&#39;,    timeout: 300,    type: &#39;GET&#39;,    success: function(){        var d = document;        var s = d.createElement(&#39;script&#39;);        s.src = &#39;//&lt;%= theme.comment.shortname %&gt;.disqus.com/embed.js&#39;;        s.setAttribute(&#39;data-timestamp&#39;, + new Date());        (d.head || d.body).appendChild(s);        $(&#39;.disqus_click_btn&#39;).css(&#39;display&#39;, &#39;none&#39;);    },    error: function() {        $(&#39;.disqus_click_btn&#39;).css(&#39;display&#39;, &#39;block&#39;);    }    });&lt;/script&gt;&lt;%/*由于我超时时长设置得比较短，所以可能翻墙了还是没有自动加载评论，这时就需要手动点击加载了*/%&gt;&lt;script type=&quot;text/javascript&quot; id=&quot;disqus-click-load&quot;&gt;    $(&#39;.btn_click_load&#39;).click(() =&gt; {  //click to load comments        (() =&gt; { // DON&#39;T EDIT BELOW THIS LINE            var d = document;            var s = d.createElement(&#39;script&#39;);            s.src = &#39;//&lt;%= theme.comment.shortname %&gt;.disqus.com/embed.js&#39;;            s.setAttribute(&#39;data-timestamp&#39;, + new Date());            (d.head || d.body).appendChild(s);        })();        $(&#39;.disqus_click_btn&#39;).css(&#39;display&#39;,&#39;none&#39;);    });&lt;/script&gt;</code></pre><p>最后，列一下我对博客的优化：</p><ol><li>使用 glup 插件压缩 html、css、js、img 等；</li><li>CloudFlare 的 CDN 加速访问资源；</li><li>ServiceWorker 提供离线访问技术；</li><li>延时加载 Disqus 评论；</li></ol><p>每一点优化我都有写文章，文章链接可以通过搜索关键字获取。</p>]]></content>
      
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 评论 </tag>
            
            <tag> Disqus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Service Worker 优化网站</title>
      <link href="/posts/a0df572f/"/>
      <url>/posts/a0df572f/</url>
      
        <content type="html"><![CDATA[<p>静态博客的内容是很适合用缓存来加速访问的，除了采用常见的 CDN 加速和压缩博文等方法，通过客户端也可以实现加速访问，本文介绍的是「服务工作线程—— Service Worker」。关于 Service Worker 的具体介绍见<a href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="noopener">这里</a>。本文主要需要的是它的离线加载的特性。</p><a id="more"></a><p>本博客使用 Service Worker 可分为两个阶段，在我最初撰写本文的时候，使用的是 Service Worker 原生的接口。在不久之后，Google 推出了 <a href="https://github.com/GoogleChromeLabs/sw-toolbox" target="_blank" rel="noopener">sw-toolbox</a> 和 <a href="https://github.com/GoogleChromeLabs/sw-precache" target="_blank" rel="noopener">sw-precache</a> 用以让用户更全面的掌控 Service Worker 缓存的方式：包括版本控制、文件缓存级别、具体路径等，于是在我经历了漫长的实践后（其实是因为懒），有了本文 Version 2.0。</p><h2 id="启用-Service-Worker"><a href="posts/a0df572f/#启用-Service-Worker" class="headerlink" title="启用 Service Worker"></a>启用 Service Worker</h2><h3 id="添加注册代码"><a href="posts/a0df572f/#添加注册代码" class="headerlink" title="添加注册代码"></a>添加注册代码</h3><p>以下注册代码需要在网站的根目录添加，这样才能保证接管整个网站的全部资源。</p><pre><code class="javascript">if (&#39;serviceWorker&#39; in navigator) {    navigator.serviceWorker.register(&#39;/sw.js&#39;)    .then(function() {        console.log(&#39;A new service worker is being installed.&#39;);    })    .catch(function(error) {      console.log(&#39;Service worker registration failed:&#39;, error);    });  } else {    console.log(&#39;Service workers are not supported.&#39;);  }</code></pre><p>将以上代码加入主题中，至于加在哪需要根据主题的结构决定。你只需要保证生成的静态资源中包含以上代码，那么就算添加成功。以 NexT 为例，你可以把以上代码添加到 <code></code>/next/layout/_thrid-party/comments/ ` 下的任一评论配置文件中（前提是你开启了该评论组件）。</p><h3 id="添加静态资源"><a href="posts/a0df572f/#添加静态资源" class="headerlink" title="添加静态资源"></a>添加静态资源</h3><p>将以下代码保存为 <code>sw.js</code>，并确保生成静态文件的时候，<code>sw.js</code> 在网站根目录下（你可以把它放在 <code>source</code> 文件夹内）。</p><pre><code class="javascript"> &quot;use strict&quot;; (function() {     var cacheVersion = &quot;-180503&quot;;     var staticCacheName = &quot;asset&quot; + cacheVersion;     var maxEntries = 100;     self.importScripts(&quot;https://cdn.jsdelivr.net/npm/sw-toolbox@3.6.0/sw-toolbox.js&quot;);     self.toolbox.options.debug = false;     self.toolbox.options.networkTimeoutSeconds = 1;     /* staticImageCache */     self.toolbox.router.get(&quot;/(.*)&quot;,self.toolbox.cacheFirst, {         cache: {          name: staticCacheName,             maxEntries: maxEntries         }     }) })();</code></pre><p>首先指定 cacheVersion，在刷新缓存的时候会进行匹配；其次是一个 Cache Storage 名称的有关变量，我这里只是简单划分为静态资源——全部从缓存中加载的资源；关闭 debug 模式，设置 Timeout 时间为 1s。</p><p>其中 sw-toolbox 的<a href="https://github.com/GoogleChromeLabs/sw-toolbox/blob/master/docs/api.md#handlers" target="_blank" rel="noopener">缓存级别</a>共有 5 个（网络优先、缓存优先、速度优先、仅缓存、仅网络）。</p><p>我这里采用的是 <code>cacheFirst</code>，即缓存优先加载。可针对具体的资源进行不同的缓存级别分配。</p><p>其中 <code>self.toolbox.router.get</code> 表示每一个你需要操作的资源，第一个参数表示匹配的网址，第二个表示缓存级别，第三个是回调函数。</p><p>具体到以本站为例的话，你可以参考本站的<a href="https://github.com/WincerChan/MyBlog/blob/hexo/source/sw.js" target="_blank" rel="noopener">配置文件</a>。</p><h2 id="加速效果"><a href="posts/a0df572f/#加速效果" class="headerlink" title="加速效果"></a>加速效果</h2><h3 id="离线"><a href="posts/a0df572f/#离线" class="headerlink" title="离线"></a>离线</h3><p>可以看到在启用了 <code>Offline</code> 仍然可以加载页面</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862392/blog/sw_optimize/pic1.gif" alt="效果1"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">效果1</figure></p><h3 id="缓存"><a href="posts/a0df572f/#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>刷新页面可以看到许多资源是直接 ( from ServiceWorker ) 加载的，并未发起新的 http 请求。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862438/blog/sw_optimize/pic2.gif" alt="效果2"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">效果2</figure></p><h2 id="先决条件"><a href="posts/a0df572f/#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><h3 id="浏览器"><a href="posts/a0df572f/#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p> <a href="https://jakearchibald.github.io/isserviceworkerready/" target="_blank" rel="noopener">is Serviceworker ready</a> 详细列出了所有浏览器支持的情况。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530862459/blog/sw_optimize/broswer_support.png" alt></p><h3 id="HTTPS"><a href="posts/a0df572f/#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>服务器工作线程只能工作在 HTTPS 加密的网站上，本地的 <code>localhost</code> 是默认安全。</p><p>参考文章：</p><ul><li><a href="https://developer.google.com/web/fundamentals/getting-started/primers/service-workers" target="_blank" rel="noopener">服务工作线程：简介</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration" target="_blank" rel="noopener">ServiceWorkerRegistration</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> ServiceWorker </tag>
            
            <tag> 优化 </tag>
            
            <tag> sw-toolbox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 实现多线程下载器</title>
      <link href="/posts/80689c8d/"/>
      <url>/posts/80689c8d/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="posts/80689c8d/#前言" class="headerlink" title="前言"></a>前言</h2><p>我为什么会想到要写一个下载器呢，实在是被百度云给逼的没招了，之前用 Axel 配合直链在百度云下载视频能达到满速，结果最近两天 Axel 忽然不能用了，于是我就想着要不干脆自己写一个吧，就开始四处查询资料，这就有了这篇博客。</p><p>我假设阅读这篇博客的你已经对以下知识有所了解：</p><ul><li>Python 的文件操作</li><li>Python 的多线程</li><li>Python 的线程池</li><li>Python 的 requests 库</li><li>HTTP 报文的首部信息</li></ul><a id="more"></a><h2 id="下载"><a href="posts/80689c8d/#下载" class="headerlink" title="下载"></a>下载</h2><p>获取文件采用的是 requests 库，该已经封装好了许多 http 请求，我们只需要发送 get 请求，然后将请求的内容写入文件即可：</p><pre><code class="python">import requestsr = requests.get(&#39;http://files.smashingmagazine.com/wallpapers/july-17/summer-cannonball/cal/july-17-summer-cannonball-cal-1920x1080.png&#39;)with open(&#39;wallpaper.png&#39;, &#39;wb&#39;) as f:    f.write(r.content)</code></pre><p>随后看看文件夹，那张名为 <code>wallpaper.png</code> 的图片就是我们刚刚下载的。</p><p>但是这个功能太简单了，甚至简陋，我们需要多线程并发执行下载各自的部分，然后再汇总。</p><h2 id="拆分"><a href="posts/80689c8d/#拆分" class="headerlink" title="拆分"></a>拆分</h2><p>为了拆分，首先得知道数据块的大小，HTTP 报文首部提供了这样的信息：</p><ul><li>用 head 方法去获取 http 首部信息，再从获取的信息提取出 <code>Content-Length</code> 字段（上文图片大小为 261258 bytes）</li></ul><pre><code class="python">import requestsheaders = {&#39;Range&#39;: &#39;bytes={}-{}&#39;.format(0, 100000)}r = requests.get(&#39;http://files.smashingmagazine.com/wallpapers/july-17/summer-cannonball/cal/july-17-summer-cannonball-cal-1920x1080.png&#39;, headers = headers)with open(&#39;wallpaper.png&#39;, &#39;wb&#39;) as f:    f.write(r.content)</code></pre><p>我们得到了图片的前 100001 个字节（Range 的范围是包括起始和终止的），打开 <code>wallpaper.png</code> 你应该能看到一幅“半残”的图。</p><p>这样我们里目标更近了一步，继续：</p><ul><li>确认线程数（比如 8 个），261258//8 = 32657，前 7 个线程都取 32657 个 bytes，第八个取剩余的</li></ul><pre><code class="python">part = size // numsfor i in range(nums):        start = part * i        if i == num_thread - 1:   # 最后一块            end = file_size        else:            end = start + part</code></pre><ul><li>每个线程获取到的内容按顺序写入文件（file.seek() 调节文件指针）</li></ul><pre><code class="python">def down(start, end):    headers = {&#39;Range&#39;: &#39;bytes={}-{}&#39;.format(start, end)}    # 这里最好加上 stream=True，避免下载大文件出现问题    r = requests.get(self.url, headers=headers, stream=True)    with open(filename, &quot;wb+&quot;) as fp:        fp.seek(start)        fp.write(r.content)</code></pre><p>嘛，线程多了起来就扔到线程池让它来帮我们调度。</p><h2 id="封装"><a href="posts/80689c8d/#封装" class="headerlink" title="封装"></a>封装</h2><p>功能复杂了，用对象来封装整理一下：</p><pre><code class="python">class Downloader():     def __init__(self, url, num, name):        self.url = url        self.num = num        self.name = name        r = requests.head(self.url)        self.size = int(r.headers[&#39;Content-Length&#39;])     def down(self, start, end):        headers = {&#39;Range&#39;: &#39;bytes={}-{}&#39;.format(start, end)}        r = requests.get(self.url, headers=headers, stream=True)        # 写入文件对应位置        with open(self.name, &quot;rb+&quot;) as f:            f.seek(start)            f.write(r.content)    def run(self):        f = open(self.name, &quot;wb&quot;)        f.truncate(self.size)        f.close()        futures = []        part = self.size // self.num         pool = ThreadPoolExecutor(max_workers = self.num)        for i in range(self.num):            start = part * i            if i == self.num - 1:                   end = self.size            else:                end = start + part - 1            # 扔进线程池            futures.append(pool.submit(self.down, start, end))        wait(futures)</code></pre><p>至此，核心功能都完成了，剩下的就是实际体验的优化了。</p><p>完整的代码已托管至 GitHub，地址见<a href="https://github.com/WincerChan/Py-Downloader" target="_blank" rel="noopener">这里</a>。</p><h2 id="结语"><a href="posts/80689c8d/#结语" class="headerlink" title="结语"></a>结语</h2><p>很可惜，我写的这个下载器还是不能下载百度云直链，不过嘛，好多人都说结果不重要，都说重要的是过程，不是么？写这个下载器我也确实学到了许多，至于一开始我是出于什么样的目的？管他呢</p>]]></content>
      
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导出 QQ 聊天记录</title>
      <link href="/posts/1060d444/"/>
      <url>/posts/1060d444/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="posts/1060d444/#前言" class="headerlink" title="前言"></a>前言</h2><p>从 2013 年开始，手机 QQ 就已经不支持私人聊天记录的导出功能了（群聊的记录还是可以导出），目的当然是为了推广超级会员，毕竟超级会员的聊天记录有 2 年漫游时间，而不想给腾讯送钱的我，就只好另辟蹊径了。</p><a id="more"></a><p>配合视频教程食用更加哦~：<a href="https://youtu.be/Y4y-UWg5vco" target="_blank" rel="noopener">https://youtu.be/Y4y-UWg5vco</a></p><h2 id="准备"><a href="posts/1060d444/#准备" class="headerlink" title="准备"></a>准备</h2><p>我并不算是那种埋头造轮子的人，所以遇到问题总是先问谷歌，确实也寻找到了一些工具，可惜有的不能用能用的还要收费。看来还是需要自己动手（当然，不动手也就没有这篇文章了）。</p><h3 id="数据库位置"><a href="posts/1060d444/#数据库位置" class="headerlink" title="数据库位置"></a>数据库位置</h3><p>安卓手机 QQ 的数据库文件保存在 <code>data/data/com.tencent.monileqq/databases/{QQ 号}.db</code> 下，所以需要 Root（更改 AndroidManifest.xml 的 debuggable 属性之后可以使用 adb 工具导出），这里并非本文的重点，就不展开说了。数据库里面不仅有聊天记录，基本上包括了 QQ 号的所有信息。</p><p>不幸的是，里面的重要数据被加密了。</p><h3 id="加密方式"><a href="posts/1060d444/#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><p>另外很幸运的是，加密方式采用的是「<a href="https://zh.wikipedia.org/zh-hans/%E5%BC%82%E6%88%96%E5%AF%86%E7%A0%81" target="_blank" rel="noopener">异或加密</a>」，而用于加密的字符串就是你手机的 <a href="https://zh.wikipedia.org/wiki/IMEI" target="_blank" rel="noopener">IMEI</a>，所有手机的 IMEI 都是不同的，这样也可以确保加密后的数据是唯一的，既然知道了加密方式和密钥，那么解密自然也就不是难事了。</p><h2 id="开始"><a href="posts/1060d444/#开始" class="headerlink" title="开始"></a>开始</h2><p>先想一下，我们聊天记录想导出成什么格式：</p><p>我的想法是：<code>时间--发信人--内容</code> 这样的格式。打开数据库文件：</p><p>如下图，mr_friend_** **_New 就是你与每一个好友聊天的信息，包括昵称、备注、qq 号码、聊天记录等，直接查看就会发现是被加密过的。这一串 32 位的字符串就是 QQ 号码的 md5 值。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1gaMPKeySBuNjy1zd760PxFXak.png" alt></p><p>由于 QQ 在手机端使用的数据库是 sqlite，Python 有很方便的 sqlite 的工具，而且 Python 针对字符串处理很方便，这里就采用 Python 来解密。</p><p>用浏览工具打开数据库，以我的数据库为例：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1Pf7yKkOWBuNjSspp760PgpXar.png" alt></p><p><code>msgData</code> 保存的就是聊天记录，<code>selfuin</code> 就是聊天对象的 QQ 号码，<code>time</code>就是发送消息的时间，既然知道了这三个就是我们想要的，那么接下来的就好办多了，解密这三个就好了。</p><h2 id="解密"><a href="posts/1060d444/#解密" class="headerlink" title="解密"></a>解密</h2><p>既然牵扯到解密，自然也就逃不掉编码和解码。尤其是 <code>msgData</code> 项，确实是花费了我好久才解决（哼，我才不会说这是因为我对 Python 的编码不熟悉呢）。</p><p>代码已托管至 Gist，见<a href="https://gist.github.com/362331456a6e0417c5aa1cf3ff7be2b7.git" target="_blank" rel="noopener">这里</a>。</p><p>参考：</p><ul><li><a href="http://www.freebuf.com/articles/terminal/68224.html" target="_blank" rel="noopener">用 Python 解密手机 QQ 聊天记录</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实验室 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于男乒退赛的一点看法</title>
      <link href="/posts/2cdb7149/"/>
      <url>/posts/2cdb7149/</url>
      
        <content type="html"><![CDATA[<blockquote><p>6 月 23 日。马龙、樊振东、许昕宣布退出 2017 年国际乒联中国公开赛。</p></blockquote><p>本来针对这个事，我想写一篇长文来讲讲最近中国某些「魔幻」的地方，奈何后天就要考网络，只好暂且放下。</p><p>我一般不在博客上转载文章，不过鉴于这几天实在没有时间写，于是决定转载一下微博的一篇文章，出处已无法考证。</p><a id="more"></a><hr><p>憋了一晚上了，大半夜了，看着事情从最初了英勇豪迈，从振奋人心，担忧，到最后深深的无能为力。<br>看它空降热搜，一路爬到第一，半个榜内都是国乒。<br>看它被封，被禁，被删博。<br>截了一路的图。<br>这是国球。</p><p>国家体育总局关心的是那几块闪闪发亮的金牌。所以呢，给他们空降教练组长，突然之间毫无征兆的给他们的恩师「另谋高就」，他们没法反抗，禁言，被收手机，不能发声，不能上微博。<br>金牌可以再有，但国乒，这个从 2006 到 2016 年，敢在体育总局面前下军令状的梦之队，被瓦崩了，就不能重来。<br>看到了吗，从杜塞世乒赛临阵换走孔令辉，到成都公开赛明升暗降刘国梁，风云诡辩，赛场上闪闪发亮的新老双子星，四个大满贯，转眼间就只剩下了马龙一人。<br>有人说他们，不爱国，退赛，逃避，搞得和国旗上印的是刘国梁的脸一样。<br>那你是没有看过，孔令辉在夺冠后的瞬间扯起衣服亲吻胸口的那个国旗小标。你是没有看过，许昕在赢下赛点后，扯着衣服指给全世界看，他是中国人，然后指着背后的 CHINA 留给世人一个坚不可摧的背影。<br>你是没有见过，一个体育项目，2006 至 2016，在漫长的十年里，一个队伍包揽了世界大赛中，他们在制度约束下所能获得的所有金牌银牌，以及铜牌。<br>是中国乒乓球。<br>爱不爱国，铁骨铮铮，天地可鉴。<br>所以为什么他们会放弃他们热爱的赛场，扣除上百的世界排名积分，在一个不用升国旗奏国歌的比赛中以这种极端的方式伸张正义？<br>他们心寒。<br>孔令辉走了，刘国梁走了。捧起国球一片天，使这个精神漫漫延续的人，都以这样的方式离开了他们所热爱的赛场，不是功满圆退，而是二话不说让你离开。<br>国乒在今年刚刚重新聘选重组完教练组，刘国梁说不想从政只想呆在球场。马琳王皓，曾经世界冠军重新回到了国家队，以另一种方式，教练员的方式。<br>然而，半年未到，体育总局下令国乒取消总教练主教练职位，设立组长分管男女队，让刘国梁去做乒协副主席。<br>连李永波在内，有 20 多位的乒协副主席。<br>毫无征兆。<br>你让他们如何接受。<br>这几天里，从东京到成都，他们到底经历了什么，只有他们自己知道。<br>下午蔡振华蔡局到了成都，对刘国梁的卸任发表了态度。<br>晚上，所有能发生声的运动员，无论是国家一队二队还是省队，退役没退役，还有教练员，都发了一条微博。他们都选择了用这种方式来抗议。<br>后果是什么，禁赛，谩骂，卸甲归田？<br>他们知道吗，同样也不知道。<br>马龙，赌上了他最好的现在，樊振东，赌上了他前途无量的未来，许昕，赌上了奥运后好不容易重拾的好状态。<br>他们怎么可以这么傻。<br>国乒不是没了刘国梁就转不下去，也不是没了许昕马龙张继科樊振东就转不下去，事实上，马龙，刘国梁在里约后都有过退役的念头，但是又是什么让他们选择了依旧留在了赛场上？<br>是那方寸球台，和牵动着万千国人心的白色小球。<br>刘国梁，大满贯。退役后的第一天站在了教练员的位置上，至此，整整十四年。<br>在这十四年，他有了两个可爱的女儿，一个叫赢赢，一个叫一一。<br>赢，是中国队赢。一，使中国队第一。<br>他这半生，都叱咤风云于这赛场，这一生中最重要的人，也与乒乓球挂了勾。</p><p>发声，这只是见不惯也不能接受一代功臣沦落如此地步。<br>不能反抗，唯有自燃。</p><p>没有任何一个项目可以做到如此地步。教练员，运动员，把自己串在一起，做同一条绳上的蚂蚱。<br>没有任何一个项目可以做到如此地步。女队教练员不够，男队教练去补，男队教练员不够，那运动员还可以坐镇场外。<br>没有一个项目任何一个项目，和乒乓球一样可以看到四面五星红旗闪闪升旗的模样。</p><p>拿什么赌？拿自己赌，拿世界第一去赌，拿整个职业生涯去赌。<br>他们是连赛后忘记握手都要大肆报道严重批评的运动员，罢赛简直是想都不敢想的事情，而如今却发生了。<br>为何会做出如此举动，我们都应该明白。</p><p>这是中国乒乓球队历史上最没有把握的一次比赛。<br>但我希望他们赢。</p><p>那句话没有变，无论怎样都不会变，国乒长虹，剑指东京。</p><p>不知道他们在酒店怎么样，有没有手机，看不看得到我们。</p><p>如果看得到，想告诉他们。</p><p>整个中国都在支持他们。</p><hr><p>很奇怪，国乒为什么要改革？改革不是应该改掉不好的吗？日本队今年复制中国管理模式，韩国金泽洙回来重新凝聚团队，各国都在学习认可的管理模式，就因为上层的政治斗争，就随意改革？</p><p>要建立一个国乒体系花了刘国梁 20 年的心血，而毁掉只需要一个会议。</p><p>教练组扁平化，这是好听的说法，真实意思是业务和权力分开，由官僚进行垂直管理，中央集权。新建的“管理组”谁来空降？懂不懂乒乓球？会比一群世界冠军的教练还要懂？和教练组有分歧，谁听谁的？外行领导内行？</p><p>政治斗争，高于金牌利益，高于项目，高于运动员。这就是中国体育界。</p><p>为什么每一次，都要在巅峰的时候收割别人的心血，提走功勋，然后等低谷了再急巴巴请人来「临危受命」？前有中国女排，后，可能就是乒乓球。</p><p>不仅是体育总局，其实这就是中国的现实。</p><p>我很乐意看到中国这样最后会变得怎么样 :D</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国乒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解除百度云下载限速</title>
      <link href="/posts/cfd78fa9/"/>
      <url>/posts/cfd78fa9/</url>
      
        <content type="html"><![CDATA[<p>目前关于破解百度云限速的方法网上提供了许多种，实则是殊途同归，即：高速链接 + 多线程下载工具。而目前获取的链接的方法并非完美且存在一些限制，但聊胜于无。我将目前网上能搜集到的方法一一列举，同时也会针对每个方法的适用性与方便性做出评价。</p><a id="more"></a><h2 id="TL-DR"><a href="posts/cfd78fa9/#TL-DR" class="headerlink" title="TL; DR"></a>TL; DR</h2><p>Windows 用 <a href="/posts/cfd78fa9/#PanDownload">PanDownload</a>。</p><p>其它平台用 <a href="/posts/cfd78fa9/#Pandownload">PanDownload 网页版</a>。</p><h2 id="获取下载直链"><a href="posts/cfd78fa9/#获取下载直链" class="headerlink" title="获取下载直链"></a>获取下载直链</h2><p>这一类方法都是以插件获取下载直链，再辅以多线程下载工具来达到不限速的目的，以下为各个插件的具体说明：（有关多线程下载工具 Axel 见文章末端）</p><h3 id="下载助手"><a href="posts/cfd78fa9/#下载助手" class="headerlink" title="下载助手"></a>下载助手</h3><ol><li><p>下载<a href="http://tampermonkey.net/" target="_blank" rel="noopener">油猴脚本管理器</a></p></li><li><p>安装<a href="https://greasyfork.org/zh-CN/scripts/39776" target="_blank" rel="noopener">下载助手修改版</a>脚本</p></li><li><p>打开百度云，勾选需要下载的文件</p></li><li><p>上方会出现「下载助手」的按钮，依次点击：<em>压缩按钮 -&gt; 获取压缩按钮</em>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1XhIyKkOWBuNjSspp760PgpXaD.png" alt="下载助手"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">下载助手</figure></p></li></ol><p>此方法适用性应当比较高。以下是 Axel 开启 128 线程的示例：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1vlqNKgaTBuNjSszf760gfpXaF.png" alt="下载实例"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">下载实例</figure></p><p>缺点就是有些麻烦：需复制 Header 信息才可掉调用下载工具（如 Axel 等）下载，获得 Header 的方法就是打开调试窗口，粘贴该链接在 Chrome 地址栏，在 Network 选项卡中查看该链接的 Request Headers，至少需要将 Cookie、User-Agent 两项传入给下载工具。</p><blockquote><p><strong>注意：这里的 Cookie 并不是当前域名（pan.baidu.com）的 Cookie，是 <code>pcs.baidu.com</code> 的 Cookie，其实所需要的仅仅是 Cookie 的 <code>BDUSS</code> 和 <code>pcsett</code> 值</strong></p></blockquote><h3 id="Pandownload"><a href="#Pandownload" class="headerlink" title="Pandownload"></a>Pandownload</h3><p>在提供 Windows 客户端的同时，PanDownload 还于最近提供了网页版，可直接将分享的文件提取出直链 ：</p><ol><li><p>打开<a href="https://www.baiduwp.com/" target="_blank" rel="noopener">PanDownload 网页版</a>，输入分享链接和提取码</p></li><li><p>会生成一个包含你想要下载文件的页面，点击</p></li><li><p>会进入这样的界面：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1.xsVcUuF3KVjSZK9762VtXXau.png" alt="Pandownload 网页版界面"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">Pandownload 网页版界面</figure></p></li></ol><p>直接点击即可通过浏览器下载（如果你想用其它的工具下载，记得传递 Cookie），当然你也可以使用 Aria2 RPC 下载。</p><p>这是我使用 Aria2 下载的速度，配置文件见<a href="https://gist.github.com/WincerChan/40a63819b0fdd629e57e202ad82dbbee" target="_blank" rel="noopener">这里</a>：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1Ql7VcUGF3KVjSZFv762_nXXa3.png" alt="配合 Aria2 的速度"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">配合 Aria2 的速度</figure></p><p>此方法的优点在于不用安装额外的浏览器插件，也不用下载客户端，比较方便手机和 Linux 用户。缺点在于 Aari2 的线程仍然有限，所以速度不会特别快，但也算比较理想了。</p><h3 id="BaiduExporter"><a href="posts/cfd78fa9/#BaiduExporter" class="headerlink" title="BaiduExporter"></a>BaiduExporter</h3><blockquote><p><del>自本文最近一次更新起，该方法获取的链接已无法在 Axel 中使用，原因是 URL 参数中的 app_id 失效，但这失效的 app_id 的 URL 却仍然可以用 aria2c 下载。</del>可以使用我 <a href="https://github.com/WincerChan/BaiduExporter" target="_blank" rel="noopener">Fork 后修改</a>的版本作为代替。</p><p>我的小号在使用这个方法的时候被封了，直接 403，更换帐号后可正常下载。被封之后大概两天内会解封。建议线程数不要开太多，被封之后可以更换速盘下载。</p></blockquote><ol><li><p>clone 该仓库</p></li><li><p><em>Chrome -&gt; 更多工具 -&gt; 扩展程序 -&gt; 加载已解压的扩展程序（需勾选开发者模式） -&gt; chrome/release（文件夹）</em></p></li><li><p>进入想要下载文件的界面</p></li><li><p>勾选，点击 <em>导出下载 -&gt; 文本导出 -&gt; 拷贝下载链接</em>：<img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB11O.dttcnBKNjSZR0763FqFXam.png" alt="导出下载"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">导出下载</figure></p></li><li><p>复制链接后，是一串格式类似以下内容的命令：</p><pre><code class="bash">axel -o &quot;xxxxxx&quot; -H &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot; -H &quot;Cookie: BDUSS=9aRnpJYjF-THlHUbbjxkTYUnjk^&amp;8naddR2NscTF-cFZJVWV3cDBvVkVaeHpHOFNJcXRhQVFBQUFBJCQAAAAAAAAAAAEAAADvjlIvY3cwODI5OQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABKVg1oSlYNaS0; pcsett=4789643579-hukfa445465a15156c1515a5f12cxzw4&quot; &quot;URL&quot; -n 233</code></pre><p>其中包含两个 HTTP 首部信息：分别是 UA、Cookie，这两个信息在上一步骤的框里均会显示，<strong>不要直接复制我的，Cookie 会过期</strong>。其中最后一个参数 <code>-n 233</code> 是需要你手动输入的线程数量，即为采取 233 个线程下载。</p></li></ol><p><a href="https://github.com/acgotaku/BaiduExporter" target="_blank" rel="noopener">该项目</a>算是目前比较完美的解决方案了，以下是使用 Axel 开启 256 个线程后的速度（不要在意中间的乱码）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1YuS7B5OYBuNjSsD4762SkFXai.png" alt="截图"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">截图</figure></p><p>原项目是将链接导出至 ariac2 下载，但是 ariac2 却只能最多开启 16 个线程，这对一般下载任务也够了，但是对于百度这种老流氓来说（每个连接限速至 10Kb/s ），还是不够用的，所以我 Fork 后采用 Axel 代替 ariac2，Axel 可以设置任意连接数）。</p><p>此方法也是我目前一直在使用的方法。</p><h3 id="ADM-ES"><a href="posts/cfd78fa9/#ADM-ES" class="headerlink" title="ADM + ES"></a>ADM + ES</h3><p>这个方法是酷安上流传已久的方法，但我一直都无法满速，还是在这里提一下吧，造福一下手机党：</p><ol><li>安装 <a href="https://www.coolapk.com/apk/com.estrongs.android.pop" target="_blank" rel="noopener">ES 文件浏览器</a></li><li>安装 ADM（酷安手机客户端下载）</li><li>ADM 线程数调至最高</li><li>修改 User-Agent：<em>ADM -&gt; 设置 -&gt; 下载 -&gt; 用户代理 -&gt; \<custom></custom></em>，将以下内容复制进去：<code>netdisk;7.8.1;Red;android-android;4.3</code></li><li><em>ES 文件浏览器 -&gt; 网络 -&gt; 新建 -&gt; 百度网盘</em>，随后登录就会进入网盘界面，进入文件夹找到需要下载的文件后 <em>长按 -&gt; 更多 -&gt; 打开为 -&gt; 视频 -&gt; ADM</em>，这样就会调用 ADM 下载了</li></ol><p>同样该方法并非完美，用「ES 文件浏览器」获取的百度云链接只能在该手机端使用，因为该链接是通过本地端口远程链接所生成的，故还是有一些限制，速度不稳定（会有一些不稳定的波动）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1hMjxB2uSBuNkHFqD760fhVXaI.png" alt="ADM 下载"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">ADM 下载</figure></p><h2 id="第三方客户端"><a href="posts/cfd78fa9/#第三方客户端" class="headerlink" title="第三方客户端"></a>第三方客户端</h2><p>这一类方法使用的是别人已经封装好了的第三方客户端，其实就相当于把 获取链接的插件 + 多线程下载工具 打包好成为一个客户端。比上一类方法方便性会强一些，但适用性会弱一些。</p><h3 id="PanDownload"><a href="#PanDownload" class="headerlink" title="PanDownload"></a>PanDownload</h3><p>该软件只有 Windows 版。</p><p><a href="https://pandownload.com/document/download.html" target="_blank" rel="noopener">该软件</a>不仅支持加速下载，并支持在线解压缩，并且文档很详细。</p><p>并且个人认为比速盘好，我有时候使用速盘下载提示限速，但此软件却能达到满速，推荐使用。</p><h3 id="速盘"><a href="posts/cfd78fa9/#速盘" class="headerlink" title="速盘"></a>速盘</h3><p><a href="https://www.speedpan.com/" target="_blank" rel="noopener">该软件</a>同样是由爱吾一位大神创作，同样只有 Windows 版。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB1wVyNKqmWBuNjy1Xa760CbXXah.png" alt="SpeedPan 1"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">SpeedPan 1</figure></p><p>与其它软件的不同之处在于它还支持网盘资源搜索的功能。</p><p>据说是支持直接通过分享链接下载的，但我试了一下通过分享链接下载总是报错。但登录后下载还是可以的。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://ae01.alicdn.com/kf/HTB18HzCKeuSBuNjy1Xc763YjFXaP.png" alt="SpeedPan 2"><figure style="font-size: 14px; color: #747474; text-align: center" class="image-caption">SpeedPan 2</figure></p><h3 id="BaiduPCS-Go（全平台）"><a href="posts/cfd78fa9/#BaiduPCS-Go（全平台）" class="headerlink" title="BaiduPCS-Go（全平台）"></a>BaiduPCS-Go（全平台）</h3><p><a href="https://github.com/iikira/BaiduPCS-Go" target="_blank" rel="noopener">该项目</a>是使用 Go 语言编写的<strong>命令行</strong>客户端，支持下载、分享、上传、离线下载等功能。</p><p>我没有使用过该项目，但该项目在 GitHub 上收获 6.5k 的 star，应当是获得了许多人的认可。</p><h2 id="附-Axel-使用方法"><a href="posts/cfd78fa9/#附-Axel-使用方法" class="headerlink" title="附 Axel 使用方法"></a>附 Axel 使用方法</h2><p>我为什么提倡使用 Axel 来代替 aria2c 作为多线程下载工具呢，原因是 aria2c 最多只能设置 16 线程下载，虽说网上有修改成 512 线程的版本，但我试了之后发现速度并没有提升。而 Axel 对此则没有限制。</p><h3 id="安装"><a href="posts/cfd78fa9/#安装" class="headerlink" title="安装"></a>安装</h3><p>该软件已经附在各发行版的源仓库中了，直接安装就行。对于 Windows 来说可以自行从源码编译，这是<a href="https://github.com/axel-download-accelerator/axel#3-building-from-source" target="_blank" rel="noopener">教程</a>。</p><h3 id="使用"><a href="posts/cfd78fa9/#使用" class="headerlink" title="使用"></a>使用</h3><p>终端输入 <code>axel --help</code>：</p><pre><code class="bash">用法: axel [选项] 地址1 [地址2] [地址...]--max-speed=x        -s x    指定最大速率（字节 / 秒）--num-connections=x    -n x    指定最大连接数--output=f        -o f    指定本地输出文件--search[=x]        -S [x]    搜索镜像并从 X 服务器下载--no-proxy        -N    不使用任何代理服务器--quiet            -q    使用输出简单信息模式--verbose        -v    更多状态信息--alternate        -a    文本式进度指示器--help            -h    帮助信息--version        -V    版本信息</code></pre><p>本文持续更新中。</p>]]></content>
      
      
      <categories>
          
          <category> 分享境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 百度云加速 </tag>
            
            <tag> 百度云 </tag>
            
            <tag> 限速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manjaro 大法好</title>
      <link href="/posts/7e325dad/"/>
      <url>/posts/7e325dad/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="posts/7e325dad/#前言" class="headerlink" title="前言"></a>前言</h3><p>从去年 8 月到现在，终于无法忍受 Ubuntu 了，原因有以下几点：</p><ol><li>依赖太过混乱，自带 Python 默认版本居然是 2.7，而且更改默认版本后安装软件会各种报错</li><li>时不时报一个内部错误</li><li>软件版本更新太慢</li></ol><p>考虑到以上三点，我选择了  <a href="https://www.archlinux.org/" target="_blank" rel="noopener">Arch</a> 系的 <a href="https://manjaro.org/" target="_blank" rel="noopener">Manjaro Linxu</a>，选择 Arch 是因为去年有装过，是滚动更新模式，提供最新版本的软件，而不直接用的原因是安装步骤太过繁琐，没有必要，故而选择了基于 Arch 的 Manjaro 发行版。<br><a id="more"></a></p><h3 id="制作启动盘"><a href="posts/7e325dad/#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><p>建议采用「<a href="https://rufus.akeo.ie/" target="_blank" rel="noopener">rufus</a>」烧制到 u 盘，制作的时候选择 dd 模式，不要选择 iso 模式，否则会无法从 u 盘启动，随后一路点点点。</p><h3 id="安装后的配置"><a href="posts/7e325dad/#安装后的配置" class="headerlink" title="安装后的配置"></a>安装后的配置</h3><p>安装完成后，界面挺丑的，首先：</p><ol><li>更换中国的源，建议 USTC，这是<a href="https://mirrors.ustc.edu.cn/help/manjaro.html" target="_blank" rel="noopener">教程</a></li><li>换一张壁纸</li><li>将面板从底部删除，在顶部新建一个，添加一些部件</li><li>工作空间主题中更换观感和桌面主题</li><li>应用风格中更换窗口样式</li><li>更换图标包</li><li>fcitx 输入法</li><li>安装 docky</li><li>美化终端，安装 zsh、Oh my zsh、powerline</li><li>配置 conky（之前 Ubuntu 上的不知道为什么不能用了）</li></ol><h3 id="使用感想"><a href="posts/7e325dad/#使用感想" class="headerlink" title="使用感想"></a>使用感想</h3><ol><li>Arch 的包管理 pacman 比 Ubuntu 的不知道高到哪里去了，还有 Octopi 图形界面客户端</li><li>特效比 Ubuntu 华丽多了</li><li>可随意切换工作区，效率确实高了一些</li><li>KDE 设置确实较多，需要花时间</li><li>KDE Connect 简直方便到爆炸！</li></ol><h3 id="效果图"><a href="posts/7e325dad/#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACwAAAAAAQABAAACAkQBADs=" data-original="https://res.cloudinary.com/wincer/image/upload/v1530861702/blog/manjaro_great/result.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KDE </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客备份</title>
      <link href="/posts/7efd2818/"/>
      <url>/posts/7efd2818/</url>
      
        <content type="html"><![CDATA[<p>使用 Hexo 在 GitHub Pages 搭建博客时，博客作为一个单独的 GitHub 仓库存在，但是这个仓库只有生成的静态网页文件，并没有 Hexo 的源文件。这样一来换电脑或者重装系统后，再想找回源文件就比较麻烦了，这里推荐一种比较完美的方法解决备份问题。</p><a id="more"></a><h2 id="备份"><a href="posts/7efd2818/#备份" class="headerlink" title="备份"></a>备份</h2><ol><li>创建仓库 <a href="https://github.com/WincerChan/MyBlog" target="_blank" rel="noopener">WincerChan.github.io</a>，如果同名仓库之前已经创建，请将之前的仓库改名，新建的仓库必须是 Username.github.io（如果你是将 Hexo 博客部署到了自己的服务器，那么仓库名可以随意设置，我这里就是随意设置的仓库）；</li><li>创建两个分支：master 和 hexo；</li><li>设置 hexo 为默认分支；</li><li>将刚刚创建的新仓库 <code>clone</code> 至本地，将之前的 hexo 文件夹中的 _config.yml、themes/、source/、scaffolds/、package.json 和 .gitignore 复制至 WincerChan.github.io 文件夹；</li><li>将 themes/next/（我用的是 NexT 主题）中的 <code>.git/</code> 删除，否则无法将主题文件夹 push（也可以将主题文件夹使用<a href="https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">子模块</a>的方式添加到该仓库)；</li><li>在 WincerChan.github.io 文件夹执行 <code>npm install</code> 和 <code>npm install hexo-deployer-git</code>（这里可以看一看分支是不是显示为 hexo）；</li><li>执行 <code>git add</code>、<code>git commit -m &quot;&quot;</code>、<code>git push origin hexo</code> 来提交 hexo 网站源文件；</li><li>执行 <code>hexo g -d</code> 生成静态网页部署至 Github 上。</li></ol><p>这样一来，<a href="https://github.com/WincerChan/MyBlog" target="_blank" rel="noopener">WincerChan.github.io</a> 仓库就有 master 分支和 hexo 分支，分别保存静态网页和源文件。</p><h2 id="修改"><a href="posts/7efd2818/#修改" class="headerlink" title="修改"></a>修改</h2><p>在本地对博客修改（包括修改主题样式、发布新文章等）后：</p><ol><li>依次执行 <code>git add</code>、<code>git commit -m &quot;&quot;</code> 和 <code>git push origin hexo</code> 来提交 hexo 网站源文件；</li><li>执行 <code>hexo g -d</code> 生成静态网页部署至 Github 上。</li></ol><p>即重复备份的 7-8 步骤，以上两步没有严格的顺序。</p><h2 id="恢复"><a href="posts/7efd2818/#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>重装电脑后，或者在其它电脑上想修改博客：</p><ol><li>安装 git；</li><li>安装 Nodejs 和 npm；</li><li>使用 <code>git clone git#github.com:WincerChan/WincerChan.github.io.git</code> 将仓库拷贝至本地；</li><li>在文件夹内执行以下命令 <code>npm install hexo-cli -g</code>、<code>npm install</code>、<code>npm install hexo-deployer-git</code>。</li></ol><h2 id="附录"><a href="posts/7efd2818/#附录" class="headerlink" title="附录"></a>附录</h2><p>这里稍作说明：</p><h3 id="添加-ssh-keys"><a href="posts/7efd2818/#添加-ssh-keys" class="headerlink" title="添加 ssh-keys"></a>添加 ssh-keys</h3><ol><li>在终端下运行：<code>ssh-keygen -t rsa -C &quot;yourname#email.com&quot;</code>，一路回车；</li><li>会在 .ssh 目录生成 <code>id_rsa</code>、<code>id_rsa.pub</code> 两个文件，这就是密钥对，id_rsa 是私钥，千万不能泄漏出去；</li><li>登录 Github，打开「Settings」–&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意 Title，在 Key 文本框里粘贴公钥 <code>id_rsa.pub</code> 文件的内容，注意不要粘贴成 <code>id_rsa</code>，最后点击「Add SSH Key」。</li></ol><h3 id="hexo-的源文件"><a href="posts/7efd2818/#hexo-的源文件" class="headerlink" title="hexo 的源文件"></a>hexo 的源文件</h3><p>这里说一下步骤 4 为什么只需要拷贝 6 个，而不需要全部：</p><ol><li><code>_config.yml</code>站点的配置文件，需要拷贝；</li><li><code>themes/</code>主题文件夹，需要拷贝；</li><li><code>source</code> 博客文章的 .md 文件，需要拷贝；</li><li><code>scaffolds/</code> 文章的模板，需要拷贝；</li><li><code>package.json</code> 安装包的名称，需要拷贝；</li><li><code>.gitignore</code> 限定在 push 时哪些文件可以忽略，需要拷贝；</li><li><code>.git/</code> 主题和站点都有，标志这是一个 git 项目，不需要拷贝；</li><li><code>node_modules/</code> 是安装包的目录，在执行 <code>npm install</code> 的时候会重新生成，不需要拷贝；</li><li><code>public</code> 是 <code>hexo g</code> 生成的静态网页，不需要拷贝；</li><li><code>.deploy_git</code> 同上，<code>hexo g</code> 也会生成，不需要拷贝；</li><li><code>db.json</code>文件，不需要拷贝。</li></ol><p>其实不需要拷贝的文件正是 <code>.gitignore</code> 中所忽略的。</p><h3 id="持续部署"><a href="posts/7efd2818/#持续部署" class="headerlink" title="持续部署"></a>持续部署</h3><p>关于如何使用 CI/CD 持续部署可以参考我<a href="posts/f011ea9c/">这篇文章</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 博客栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端午记</title>
      <link href="/posts/859c63e4/"/>
      <url>/posts/859c63e4/</url>
      
        <content type="html"><![CDATA[<p>5 月马上就要过去</p><p>似乎还没开始的这个学期，怎么就快结束了</p><p>时间怎么这么快？</p><a id="more"></a><p>长眠于 4 月之前的海子，对于时间，有一个生动的说法叫「打马而过」</p><p>有时觉得，这种匀速流淌不可改变的东西，才是真 TMD 残忍。</p><p>雨滴的出生到结束，就是从天空落向大地</p><p>似乎它的宿命就是滴落大地</p><p><br></p><p>回到家中，躺在沙发上</p><p>空气中弥漫着「熟悉的味道」</p><p>想必那就是家的味道吧？</p><p><br></p><p>临近期末</p><p>似乎应该很担心成绩挂科</p><p>我理想中的大学不是这样的</p><p>我讨厌把自己的能力和思考，都锁在一个 for 循环里</p><p>循环的条件是：你是一个大学生</p><p>那样该多无趣啊</p><p>我想 break，就像现在躺在沙发上</p><p>可以暂时跳出这个循环</p><p><br></p><p>突兀的断网</p><p>调试了许久之后</p><p>终于意识到可能没有网了</p><p>这是 break 出循环的代价？</p><p><br></p><p>在家里总可以敞开去吃</p><p>喝啤酒到胃涨还能强迫去吃饭</p><p>吃的饱了</p><p>总算能真切感受到自己不在循环里</p><p><br></p><p>明媚而灿烂的五月啊</p><p>要是心情烦躁的时候，写写博客吧</p><p>这也是断网唯一能做的开心事了</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随感 </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书推：雪中悍刀行</title>
      <link href="/posts/9a260fa1/"/>
      <url>/posts/9a260fa1/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="posts/9a260fa1/#简介" class="headerlink" title="简介"></a>简介</h3><p>有个白狐儿脸，佩双刀绣冬春雷，要做那天下第一；</p><p>湖底有白发老魁爱吃荤；</p><p>缺门牙老仆背剑匣；</p><p>山上有个骑青牛的年轻师叔祖，不敢下山；</p><p>有个骑熊猫扛向日葵不太冷的少女杀手；</p><p>这个江湖，高人出行要注重出尘装扮，女侠行走江湖要注意培养人气，宗派要跟庙堂打好关系；</p><p>而主角，则潇洒带刀，把江湖捅了一个通透；</p><p>江湖是一张珠帘。大人物小人物，是珠子，大故事小故事，是串线。情义二字，则是那些珠子的精气神。</p><a id="more"></a><div id="aplayer" musicid="33544132"></div><script src="https://api.itswincer.com/music/v1/" async></script><h3 id="简评（转）"><a href="posts/9a260fa1/#简评（转）" class="headerlink" title="简评（转）"></a>简评（转）</h3><p>年少时，看武侠电视剧里的侠踪剑影，总是莫名憧憬，甚至意犹未尽处，还会忍不住幻想自己是位飞流倜傥、快意恩仇的大侠，剑收于鞘时渊渟岳峙、剑起时又能挥出一片水银泻地云卷云舒。</p><p>日思夜想久了，于是便在心中有了一片江湖，有了一场江湖梦。</p><p>我想不止我是如此。</p><p>有句老话说，一千个读者的心中，就有一千个哈姆雷特。</p><p>同样的，一千个被现实社会的条条框框桎梏住的俗人们心间，便也有一千座不同的江湖。</p><p>求名者得名、求利者得利、求快意者得快意、求安稳者得安稳——这些在现实中并不存在的江湖就像是我们圆梦的地方，我们被称之为“规矩”“方圆”“社会准则”的枷锁束缚得越紧，就越是想要在内心最深处那片江湖里翻江倒海自在逍遥。</p><p>说白了，我们心中江湖上的那个状若侠客的自己，才是我们真正想成为的自己。</p><p>但人生有太多弯路，太多不可回头的路，一步踏错便再无转圜的余地，南辕北撤说的便是这个道理——有时候回头看，我们一路行来的方向，竟是和最初的梦想背道而驰，可我们被所谓社会的进步、所谓年轻人的成熟、所谓命运的安排这一类的东西追迫着、驱赶着，又着实没有时间停下来感伤，于是渐行渐远、梦想和现实也被拉扯得越来越沧海桑田。</p><p>到最后，我们的梦想，只剩下一副骨架、一副残骸，即是那座每每热血沸腾时便在心间浮起的海市蜃楼般的偌大一个江湖。</p><p>在那个江湖里，我们是最自在最洒脱不羁的那位侠客。</p><h3 id="文摘"><a href="posts/9a260fa1/#文摘" class="headerlink" title="文摘"></a>文摘</h3><hr><p><strong>李淳罡</strong>：</p><ol><li><p>大雨依旧磅礴。</p><p>她不起身，徐凤年便一直撑着伞。</p><p>老剑神李淳罡望向这一幕，瞪大眼睛。</p><p>随即眼中黯然落寞缅怀追忆皆有。</p><p>那一年背负那女子上斩魔台，一样是大雨天气，一样是撑伞。</p><p>世人不知这位剑神当年被齐玄帧所误，木马牛被折并不算什么，只剩独臂也不算什么，这都不是李淳罡境界大跌的根由，哪怕在听潮亭下被困二十年，李淳罡也不曾走出那个自己的画地为牢。</p><p>原本与世已是无敌，与己又当如何？</p><p>李淳罡想起她临终时的容颜，当时她已说不出一个字，可今曰想来，不就是那不悔两字吗？</p><p>李淳罡走到大雪坪崖畔，身后是一如他与绿袍女子场景的撑伞男女。</p><p>她被一剑洞穿心胸时，曾惨白笑言：“天不生你李淳罡，很无趣呢。”</p><p>李淳罡大声道：“剑来！”</p><p>徽山所有剑士的数百佩剑一齐出鞘，向大雪坪飞来。</p><p>龙虎山道士各式千柄桃木剑一概出鞘，浩浩荡荡飞向牯牛大岗。</p><p>两拨飞剑。</p><p>遮天蔽日。</p><p>这一日，剑神李淳罡再入陆地剑仙境界。</p><p>​</p><p>​</p></li></ol><hr><p><strong>洪洗象</strong>：</p><ol><li><p>正在经楼找寻一部典籍的陈繇踉跄跑到窗口，颤颤巍巍推开窗户，老泪纵横，嘴唇颤抖道：“王师兄，小师弟成了！”</p><p>山中炼丹的宋知命顾不得一鼎炉被凡人视作仙物的丹药，扑通一声跪下去，磕头道：“武当三十六弟子宋知命，恭迎祖师爷！”</p><p>在东海寻觅到一名骨骼清奇闭关弟子的俞兴瑞，正坐蒲台上传授那名弟子内功心法，抚掌大笑，笑出了眼泪，激动万分道：“李玉釜，你掌教师叔终于要下山了！”</p><p>七十二峰朝大顶，二十四涧水长流。其中最长一条飞流直下的瀑布犹如神助，低端被掀起拉直，通向毗邻那座唯有一名年轻道人修习天道的小莲花峰，瀑布如一条白练横贯长空，数万香客见到此景，仿佛置身仙境，更加寂静无声，偌大一座武当山，几乎落针可闻。水起作桥为谁横？齐仙侠亲眼见到古剑连鞘飞出太虚宫，尾随其后，沿着悬挂两峰峰顶水桥奔掠向小莲花峰，看到骑牛的怔怔靠着龟驼碑，喃喃自语：“今曰解签，宜下江南。”</p><p>一身朴素道袍的洪洗象拍了拍尘土，骑上一只体型巨大的黄鹤，望向江南。</p><p>江南好，最好是红衣。</p></li><li><p>徐脂虎缓缓转头，问道：“你到底是谁？”  一直被寄予厚望去肩扛天道的年轻道士羞赧嚅喏道：“洪洗象啊。”</p><p>徐脂虎重复问道：“你来做什么？”</p><p>年轻道士壮着胆子说道：“那年在莲花峰，你说你想骑鹤。”</p><p>她转过身，背对着这个胆小鬼。</p><p>这个放言要斩断赵氏王朝气运的道人，深呼吸一口，笑道：“徐脂虎，我喜欢你。” </p><p>“不管你信不信，我已经喜欢你七百年。” </p><p>“所以这世上再没有人比我喜欢你更久了。” </p><p>“下辈子，我还喜欢你。”</p><p>丫鬟二乔眨巴眨巴水灵眸子，小脑袋一团浆糊，只看到小姐捂着嘴哭哭笑笑的，就更不懂了，唉，看来小姐说自己年纪小不懂事是真的呀。</p><p>年轻道士伸出手，轻声道：“你想去哪里，我陪你。”</p><p>这一曰，武当年轻掌教骑鹤至江南，与徐脂虎骑鹤远离江湖。</p><p>仙人骑鹤下江南，才入江湖，便出江湖。</p></li><li><p>年轻道士深呼吸一口，等女子依偎在他怀中，那柄横放在龟驼碑边缘的所谓吕祖佩剑出鞘，冲天而起，朝天穹激射而去，仿佛要直达天庭才罢休。</p><p>九天之云滚滚下垂。</p><p>整座武当山紫气浩荡。</p><p>他朗声道：“贫道五百年前散人吕洞玄，五十年前龙虎山齐玄帧，如今武当洪洗象，已修得七百年功德。”</p><p>“贫道立誓，愿为天地正道再修三百年！”</p><p>“只求天地开一线，让徐脂虎飞升！”</p><p>年轻道士声如洪钟，响彻天地间。</p><p>“求徐脂虎乘鹤飞升！”</p><p>黄鹤齐鸣。</p><p>吕祖转世的年轻道士盘膝坐下，望着注定要兵解自己的那下坠一剑，笑着合上眼睛。</p><p>陈繇等人不忍再看，老泪纵横。</p><p>有一虹在剑落后，在年轻道士头顶生出，横跨大小莲花峰，绚烂无双。</p><p>千年修行，只求再见。</p></li></ol><hr><p><strong>轩辕敬城：</strong></p><ol><li><p>修身在正其心。</p><p>莫道书生无胆气，敢叫天地沉入海。</p><p>成事者，不惟有超世之才，亦必有坚韧不拔之志。</p><p>轩辕青锋脑海中走马观灯，那些诗词文章一一浮现。</p><p>“我入陆地神仙了。”</p><p>轩辕敬城闭上眼睛，只见他七窍流血，却神情自若地双手摊开，似乎想要包容那整座天地。</p><p>以他为圆心，大雪坪积水层层向外炸起。</p><p>那一瞬间，有九道雷电由天庭而来。</p></li><li><p>辕敬城每年酿当归酒三坛，两坛都让人送来庭院，自己只余一坛。</p><p>所以他从来都是喝不够酒，而这里却是从来不喝，任由年年两坛酒搁着闲置，年复一年，酒坛子越多，酒香也愈发醇厚。</p><p>她终于启封一坛酒，搬来一套尘封多年的酒具，酒具是那男人自制而成。<br>反正除了习武，那人仿佛没有不擅长的事情。</p><p>独坐的她盛了一杯酒，放在桌上，好似对于喝不喝酒，犹豫不决，她没来由开始恼恨自己，伸手猛地拍掉酒杯。</p><p>半响后她起身去拿回酒杯，才发现杯底刻有两行小字，字迹清逸出尘。</p><p>人生当苦无妨，良人当归即好。</p></li></ol><hr><p><strong>许涌关：</strong></p><ol><li><p>一刹那。</p><p>瞎子老许头脑一片空白。</p><p>他既然能活着走下累累白骨破百万的沙场，能是一个蠢蛋？</p><p>在北凉，谁敢说这一句徐骁不过是驼背老卒？</p><p>除了大柱国，还有谁？</p><p>瞎子老许那一架需要拐杖才能行走的干枯身体剧烈颤颤巍巍起来。</p><p>最后这位北凉赖活着的老卒竟是泪流满面，转过头，嘴唇颤抖，哽咽道：“大柱国？”</p><p>那人并未承认也未否认，只是喊了一声瞎子老许：“许老弟。”</p><p>只见瞎子老许如同癫狂，挣扎着起身，不顾大柱国的阻止，丢掉拐杖，跪于地上，用尽全身所有力气，用光了三十年转战六国的豪气，用光了十年苟延残喘的精神，死死压抑着一位老卒的激情哭腔，磕头道：“锦州十八-老字营之一，鱼鼓营末等骑卒，许涌关，参见徐将军！”</p><p>锦州十八营，今曰已悉数无存，如那威名曰渐逝去的六百铁甲一样，年轻一些的北凉骑兵，最多只是听说一些热血翻涌的事迹。</p><p>鱼鼓营。</p><p>号称徐字旗下死战第一。</p><p>最后一战便是那西垒壁，王妃缟素白衣如雪，双手敲鱼鼓营等人高的鱼龙鼓，一鼓作气拿下了离阳王朝的问鼎之战。近千人鱼鼓营死战不退，最终只活下来十六人，骑卒许涌关，便是在那场战役中失去一目，连箭带目一同拔去，拔而再战，直至昏死在死人堆中。</p><p>其实，在老卒心中，大柱国也好，北凉王也罢，那都是外人才称呼的，心底还是愿意喊一声徐将军！</p><p>被徐骁搀扶着重新坐在木墩上的瞎子老许，满脸泪水，却是笑着说道：“这辈子，活够了。徐将军，小卒斗胆问一句，那徐小子莫不是？”</p><p> 徐骁轻声道：“是我儿徐凤年。”</p><p>老卒脸贴着被大柱国亲手拿回的拐杖，重复呢喃道：“活够了，活够了……”</p><p>鱼鼓营最后一人，老卒许涌关缓缓闭目。</p><p>徐将军，王妃，有一个好儿子啊。</p><p>我老许得下去找老兄弟们喝酒去了，与他们说一声，三十万北凉铁骑的马蹄声只会越来越让敌人胆寒，小不去，弱不了。</p><p>徐字王旗下，鱼龙鼓响。</p><p>老卒许涌关，死于安详。</p></li></ol><hr><p><strong>温华：</strong></p><ol><li><p>一个时辰后黄龙士缓缓走下马车，马车渐渐远去，消失于风雪中。</p><p>黄龙士没有急于入院，而是在巷弄来回走了两趟，这才推开门扉。</p><p>短短一炷香后，一名年轻男子断一臂，瘸一腿，自断全身筋脉，只存一条性命，只拎上那柄原本就属于自己的木剑，离开了院子。</p><p>巷中雪上长长一条血。</p><p>“在老子家乡那边，借人钱财，借你十两就还得还十二三两，我温华的剑，是你教的，我废去全身武功，再还你一条手臂一条腿！”</p><p>他在院中，就对那个黄老头说了这么一句话。</p><p>然后这个雪中血人在拐角处颓然蹲下，手边只剩下一柄带血木剑。</p><p>年轻游侠儿泪眼模糊，凄然一笑，站起身，拿木剑对准墙壁，狠狠折断。</p><p>此后江湖再无温华的消息，这名才出江湖便已名动天下的木剑游侠儿，一夜之间，以最决然的苍凉姿态，离开了江湖。</p><p>刺骨大雪中，他最后对自己说了一句。</p><p>“不练剑了。”</p></li></ol><hr><p><strong>徐凤年：</strong></p><ol><li><p>徐凤年闭上眼睛，双手搭在春雷上，有些明白一些事情了，为何徐骁如今还像个老农那般喜欢缝鞋？轩辕敬城本该像张巨鹿那般经略天下，最不济也可以去跟荀平靠拢，却被自己堵在了一家三口的家门以外，堵在了轩辕一姓的徽山之上，即使一举成为儒圣，仍是不曾跨出半步。骑牛的最终还是下了山，但这种下山与在山上，又有什么两样？羊皮裘李老头儿十六岁金刚十九岁指玄二十四岁达天象，为何断臂以后仍是在江上鬼门关为他当年的绿袍儿，几笑一飞剑？</p><p>说到底，都是一个字。</p><p>徐凤年想着她的酒窝，摇晃站起身。</p><p>他就算不承认，也知道自己喜欢她。不喜欢，如何能看了那么多年，却也总是看不厌？</p><p>只是不知道，原来是如此的喜欢。</p><p>既然喜欢了，却没能说出口，那就别死在这里！</p><p>徐凤年睁眼以后，拿袖口抹了抹血污，笑着喊道：“姜泥！老子喜欢你！”</p><p>拓跋春隼冷笑不止，只不过再一次笑不出来。</p><p>一名年轻女子御剑而来，身后有青衫儒士凌波微步，逍遥踏空。</p><p>女子站在一柄长剑之上，在身陷必死之地的家伙身前悬空。</p><p>她瞪眼怒道：“喊我做什么？不要脸！”</p></li></ol><hr><p><strong>李当心：</strong></p><ol><li><p>唉，闺女，等你大些，就会明白只要在一个男人心中好看，你就是天下最好看的姑娘了。”</p><p>“啊？可徐凤年说我长得一般呐，完了！”</p><p>“闺女真是长大了，娘很欣慰呐。闺女，娘真不好看？不行，再下山一趟，还得买些胭脂水粉，多扑一些在脸上就好看了。”</p><p>“娘你又乱花钱，爹肯定要跟笨南北蹲墙角唠叨去了，他们一起叨叨叨，可烦了。”</p><p>“让他们叨叨去。哪天不叨了才不好。”</p><p>这娘俩，似乎挺俗气。</p><p>亏得各自身后爱慕着她们两个的光头，是那般佛气。</p><p>小和尚将洗好的袈裟晾好，望向房内自语到，“又是一个天晴的好日子。李子，师父说我没悟性，你也说我笨，咱们寺里两个禅，我都不修。你便是我的禅，秀色可参。”</p><p>千山以外是千山，这就是江山；六宫粉黛独看你，这就是美人。</p><p>白衣僧人笑道：“去吧，睡觉去。” 小和尚嗯了一声，道：“东西怕打雷，我去门外给她念经去。” 白衣僧人摸了摸自己光头，这徒弟。站在千佛殿门口，看到在泥泞中奔跑顾不得雨水的笨南北，白衣僧人呢喃道：“笨南北啊，你有一禅，不负如来不负卿。</p><p>少妇才喊完，嗖一下，一名白衣僧人就以屁滚尿流的姿态窜出那栋巍峨阁楼，来到少妇面前，笑呵呵道：“媳妇，走累了没，给敲敲腿？”</p><p>若是外人在场，定要认为以这女子一路行来表现出的蛮横，肯定要好生拾掇一番白衣僧人才会罢休，但真见着了自己男人，她却是轻柔说道：“不累呢，只是好几天没见着你，有点想你啦。”</p><p>本名原来是李当心的白衣僧人笑容醉人，也不说话。</p><p>既然有她，天下无禅。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 文字阁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书推 </tag>
            
            <tag> 文摘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<p><strong>在</strong>朋友的推荐下，这个简易的博客搭建起来了。</p><p><strong>折腾</strong>了一天多，第一天结束的时候在 Github Pages 上看到自己的博客加载出来的时候，突然有种错综复杂的恍惚感。是的，它不是自己的 QQ 空间，不是新浪博客，不是豆瓣小站，也不是百度贴吧。它更像是属于自己的一块小小的领地，因而我满足这种归属感。我愿意、更乐于在上面安静劳作。</p><p><strong>一个</strong>之前为地主打工的农民，现在通过自身努力终于分到了一块地，不再需要帮地主的土地创造价值时，于是，这个农民重生了，他可以自豪的宣告：Hello World。当然，这个农民确切的来说是个码农。<a id="more"></a></p><p><strong>主题</strong>采用的是 Next，很好看的主题，使用文档见<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> Hexo </tag>
            
            <tag> NexT </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
